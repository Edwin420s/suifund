import {
  any,
  array,
  assert,
  assign,
  bigint,
  blake2b,
  boolean,
  bytesToHex,
  create,
  define,
  hexToBytes,
  hmac,
  integer,
  is,
  literal,
  mask,
  mnemonicToSeedSync,
  nullable,
  number,
  object,
  optional,
  record,
  require_bs58,
  require_nacl_fast,
  sha5122 as sha512,
  string,
  tuple,
  union,
  unknown
} from "./chunk-EVC6KHFR.js";
import {
  require_jsx_runtime
} from "./chunk-I5XTAQL2.js";
import {
  require_react_dom
} from "./chunk-FLOPFXLX.js";
import {
  require_react
} from "./chunk-7VXOCHOV.js";
import {
  __toESM
} from "./chunk-AUZ3RYOM.js";

// node_modules/@tanstack/react-virtual/dist/esm/index.js
var React = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());

// node_modules/@tanstack/virtual-core/dist/esm/utils.js
function memo(getDeps, fn, opts) {
  let deps = opts.initialDeps ?? [];
  let result;
  function memoizedFunction() {
    var _a, _b, _c, _d;
    let depTime;
    if (opts.key && ((_a = opts.debug) == null ? void 0 : _a.call(opts)))
      depTime = Date.now();
    const newDeps = getDeps();
    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);
    if (!depsChanged) {
      return result;
    }
    deps = newDeps;
    let resultTime;
    if (opts.key && ((_b = opts.debug) == null ? void 0 : _b.call(opts)))
      resultTime = Date.now();
    result = fn(...newDeps);
    if (opts.key && ((_c = opts.debug) == null ? void 0 : _c.call(opts))) {
      const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
      const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;
      const resultFpsPercentage = resultEndTime / 16;
      const pad = (str, num) => {
        str = String(str);
        while (str.length < num) {
          str = " " + str;
        }
        return str;
      };
      console.info(
        `%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,
        `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(
          0,
          Math.min(120 - 120 * resultFpsPercentage, 120)
        )}deg 100% 31%);`,
        opts == null ? void 0 : opts.key
      );
    }
    (_d = opts == null ? void 0 : opts.onChange) == null ? void 0 : _d.call(opts, result);
    return result;
  }
  memoizedFunction.updateDeps = (newDeps) => {
    deps = newDeps;
  };
  return memoizedFunction;
}
function notUndefined(value, msg) {
  if (value === void 0) {
    throw new Error(`Unexpected undefined${msg ? `: ${msg}` : ""}`);
  } else {
    return value;
  }
}
var approxEqual = (a11, b8) => Math.abs(a11 - b8) < 1.01;
var debounce = (targetWindow, fn, ms) => {
  let timeoutId;
  return function(...args) {
    targetWindow.clearTimeout(timeoutId);
    timeoutId = targetWindow.setTimeout(() => fn.apply(this, args), ms);
  };
};

// node_modules/@tanstack/virtual-core/dist/esm/index.js
var getRect = (element) => {
  const { offsetWidth, offsetHeight } = element;
  return { width: offsetWidth, height: offsetHeight };
};
var defaultKeyExtractor = (index) => index;
var defaultRangeExtractor = (range) => {
  const start = Math.max(range.startIndex - range.overscan, 0);
  const end = Math.min(range.endIndex + range.overscan, range.count - 1);
  const arr = [];
  for (let i9 = start; i9 <= end; i9++) {
    arr.push(i9);
  }
  return arr;
};
var observeElementRect = (instance, cb) => {
  const element = instance.scrollElement;
  if (!element) {
    return;
  }
  const targetWindow = instance.targetWindow;
  if (!targetWindow) {
    return;
  }
  const handler = (rect) => {
    const { width, height } = rect;
    cb({ width: Math.round(width), height: Math.round(height) });
  };
  handler(getRect(element));
  if (!targetWindow.ResizeObserver) {
    return () => {
    };
  }
  const observer = new targetWindow.ResizeObserver((entries) => {
    const run = () => {
      const entry = entries[0];
      if (entry == null ? void 0 : entry.borderBoxSize) {
        const box = entry.borderBoxSize[0];
        if (box) {
          handler({ width: box.inlineSize, height: box.blockSize });
          return;
        }
      }
      handler(getRect(element));
    };
    instance.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();
  });
  observer.observe(element, { box: "border-box" });
  return () => {
    observer.unobserve(element);
  };
};
var addEventListenerOptions = {
  passive: true
};
var supportsScrollend = typeof window == "undefined" ? true : "onscrollend" in window;
var observeElementOffset = (instance, cb) => {
  const element = instance.scrollElement;
  if (!element) {
    return;
  }
  const targetWindow = instance.targetWindow;
  if (!targetWindow) {
    return;
  }
  let offset = 0;
  const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : debounce(
    targetWindow,
    () => {
      cb(offset, false);
    },
    instance.options.isScrollingResetDelay
  );
  const createHandler = (isScrolling) => () => {
    const { horizontal, isRtl } = instance.options;
    offset = horizontal ? element["scrollLeft"] * (isRtl && -1 || 1) : element["scrollTop"];
    fallback();
    cb(offset, isScrolling);
  };
  const handler = createHandler(true);
  const endHandler = createHandler(false);
  endHandler();
  element.addEventListener("scroll", handler, addEventListenerOptions);
  const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;
  if (registerScrollendEvent) {
    element.addEventListener("scrollend", endHandler, addEventListenerOptions);
  }
  return () => {
    element.removeEventListener("scroll", handler);
    if (registerScrollendEvent) {
      element.removeEventListener("scrollend", endHandler);
    }
  };
};
var measureElement = (element, entry, instance) => {
  if (entry == null ? void 0 : entry.borderBoxSize) {
    const box = entry.borderBoxSize[0];
    if (box) {
      const size = Math.round(
        box[instance.options.horizontal ? "inlineSize" : "blockSize"]
      );
      return size;
    }
  }
  return element[instance.options.horizontal ? "offsetWidth" : "offsetHeight"];
};
var elementScroll = (offset, {
  adjustments = 0,
  behavior
}, instance) => {
  var _a, _b;
  const toOffset = offset + adjustments;
  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {
    [instance.options.horizontal ? "left" : "top"]: toOffset,
    behavior
  });
};
var Virtualizer = class {
  constructor(opts) {
    this.unsubs = [];
    this.scrollElement = null;
    this.targetWindow = null;
    this.isScrolling = false;
    this.measurementsCache = [];
    this.itemSizeCache = /* @__PURE__ */ new Map();
    this.pendingMeasuredCacheIndexes = [];
    this.scrollRect = null;
    this.scrollOffset = null;
    this.scrollDirection = null;
    this.scrollAdjustments = 0;
    this.elementsCache = /* @__PURE__ */ new Map();
    this.observer = (() => {
      let _ro = null;
      const get2 = () => {
        if (_ro) {
          return _ro;
        }
        if (!this.targetWindow || !this.targetWindow.ResizeObserver) {
          return null;
        }
        return _ro = new this.targetWindow.ResizeObserver((entries) => {
          entries.forEach((entry) => {
            const run = () => {
              this._measureElement(entry.target, entry);
            };
            this.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();
          });
        });
      };
      return {
        disconnect: () => {
          var _a;
          (_a = get2()) == null ? void 0 : _a.disconnect();
          _ro = null;
        },
        observe: (target) => {
          var _a;
          return (_a = get2()) == null ? void 0 : _a.observe(target, { box: "border-box" });
        },
        unobserve: (target) => {
          var _a;
          return (_a = get2()) == null ? void 0 : _a.unobserve(target);
        }
      };
    })();
    this.range = null;
    this.setOptions = (opts2) => {
      Object.entries(opts2).forEach(([key, value]) => {
        if (typeof value === "undefined")
          delete opts2[key];
      });
      this.options = {
        debug: false,
        initialOffset: 0,
        overscan: 1,
        paddingStart: 0,
        paddingEnd: 0,
        scrollPaddingStart: 0,
        scrollPaddingEnd: 0,
        horizontal: false,
        getItemKey: defaultKeyExtractor,
        rangeExtractor: defaultRangeExtractor,
        onChange: () => {
        },
        measureElement,
        initialRect: { width: 0, height: 0 },
        scrollMargin: 0,
        gap: 0,
        indexAttribute: "data-index",
        initialMeasurementsCache: [],
        lanes: 1,
        isScrollingResetDelay: 150,
        enabled: true,
        isRtl: false,
        useScrollendEvent: false,
        useAnimationFrameWithResizeObserver: false,
        ...opts2
      };
    };
    this.notify = (sync) => {
      var _a, _b;
      (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);
    };
    this.maybeNotify = memo(
      () => {
        this.calculateRange();
        return [
          this.isScrolling,
          this.range ? this.range.startIndex : null,
          this.range ? this.range.endIndex : null
        ];
      },
      (isScrolling) => {
        this.notify(isScrolling);
      },
      {
        key: "maybeNotify",
        debug: () => this.options.debug,
        initialDeps: [
          this.isScrolling,
          this.range ? this.range.startIndex : null,
          this.range ? this.range.endIndex : null
        ]
      }
    );
    this.cleanup = () => {
      this.unsubs.filter(Boolean).forEach((d17) => d17());
      this.unsubs = [];
      this.observer.disconnect();
      this.scrollElement = null;
      this.targetWindow = null;
    };
    this._didMount = () => {
      return () => {
        this.cleanup();
      };
    };
    this._willUpdate = () => {
      var _a;
      const scrollElement = this.options.enabled ? this.options.getScrollElement() : null;
      if (this.scrollElement !== scrollElement) {
        this.cleanup();
        if (!scrollElement) {
          this.maybeNotify();
          return;
        }
        this.scrollElement = scrollElement;
        if (this.scrollElement && "ownerDocument" in this.scrollElement) {
          this.targetWindow = this.scrollElement.ownerDocument.defaultView;
        } else {
          this.targetWindow = ((_a = this.scrollElement) == null ? void 0 : _a.window) ?? null;
        }
        this.elementsCache.forEach((cached) => {
          this.observer.observe(cached);
        });
        this._scrollToOffset(this.getScrollOffset(), {
          adjustments: void 0,
          behavior: void 0
        });
        this.unsubs.push(
          this.options.observeElementRect(this, (rect) => {
            this.scrollRect = rect;
            this.maybeNotify();
          })
        );
        this.unsubs.push(
          this.options.observeElementOffset(this, (offset, isScrolling) => {
            this.scrollAdjustments = 0;
            this.scrollDirection = isScrolling ? this.getScrollOffset() < offset ? "forward" : "backward" : null;
            this.scrollOffset = offset;
            this.isScrolling = isScrolling;
            this.maybeNotify();
          })
        );
      }
    };
    this.getSize = () => {
      if (!this.options.enabled) {
        this.scrollRect = null;
        return 0;
      }
      this.scrollRect = this.scrollRect ?? this.options.initialRect;
      return this.scrollRect[this.options.horizontal ? "width" : "height"];
    };
    this.getScrollOffset = () => {
      if (!this.options.enabled) {
        this.scrollOffset = null;
        return 0;
      }
      this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset === "function" ? this.options.initialOffset() : this.options.initialOffset);
      return this.scrollOffset;
    };
    this.getFurthestMeasurement = (measurements, index) => {
      const furthestMeasurementsFound = /* @__PURE__ */ new Map();
      const furthestMeasurements = /* @__PURE__ */ new Map();
      for (let m13 = index - 1; m13 >= 0; m13--) {
        const measurement = measurements[m13];
        if (furthestMeasurementsFound.has(measurement.lane)) {
          continue;
        }
        const previousFurthestMeasurement = furthestMeasurements.get(
          measurement.lane
        );
        if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {
          furthestMeasurements.set(measurement.lane, measurement);
        } else if (measurement.end < previousFurthestMeasurement.end) {
          furthestMeasurementsFound.set(measurement.lane, true);
        }
        if (furthestMeasurementsFound.size === this.options.lanes) {
          break;
        }
      }
      return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a11, b8) => {
        if (a11.end === b8.end) {
          return a11.index - b8.index;
        }
        return a11.end - b8.end;
      })[0] : void 0;
    };
    this.getMeasurementOptions = memo(
      () => [
        this.options.count,
        this.options.paddingStart,
        this.options.scrollMargin,
        this.options.getItemKey,
        this.options.enabled
      ],
      (count, paddingStart, scrollMargin, getItemKey, enabled) => {
        this.pendingMeasuredCacheIndexes = [];
        return {
          count,
          paddingStart,
          scrollMargin,
          getItemKey,
          enabled
        };
      },
      {
        key: false
      }
    );
    this.getMeasurements = memo(
      () => [this.getMeasurementOptions(), this.itemSizeCache],
      ({ count, paddingStart, scrollMargin, getItemKey, enabled }, itemSizeCache) => {
        if (!enabled) {
          this.measurementsCache = [];
          this.itemSizeCache.clear();
          return [];
        }
        if (this.measurementsCache.length === 0) {
          this.measurementsCache = this.options.initialMeasurementsCache;
          this.measurementsCache.forEach((item) => {
            this.itemSizeCache.set(item.key, item.size);
          });
        }
        const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;
        this.pendingMeasuredCacheIndexes = [];
        const measurements = this.measurementsCache.slice(0, min);
        for (let i9 = min; i9 < count; i9++) {
          const key = getItemKey(i9);
          const furthestMeasurement = this.options.lanes === 1 ? measurements[i9 - 1] : this.getFurthestMeasurement(measurements, i9);
          const start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;
          const measuredSize = itemSizeCache.get(key);
          const size = typeof measuredSize === "number" ? measuredSize : this.options.estimateSize(i9);
          const end = start + size;
          const lane = furthestMeasurement ? furthestMeasurement.lane : i9 % this.options.lanes;
          measurements[i9] = {
            index: i9,
            start,
            size,
            end,
            key,
            lane
          };
        }
        this.measurementsCache = measurements;
        return measurements;
      },
      {
        key: "getMeasurements",
        debug: () => this.options.debug
      }
    );
    this.calculateRange = memo(
      () => [
        this.getMeasurements(),
        this.getSize(),
        this.getScrollOffset(),
        this.options.lanes
      ],
      (measurements, outerSize, scrollOffset, lanes) => {
        return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({
          measurements,
          outerSize,
          scrollOffset,
          lanes
        }) : null;
      },
      {
        key: "calculateRange",
        debug: () => this.options.debug
      }
    );
    this.getVirtualIndexes = memo(
      () => {
        let startIndex = null;
        let endIndex = null;
        const range = this.calculateRange();
        if (range) {
          startIndex = range.startIndex;
          endIndex = range.endIndex;
        }
        this.maybeNotify.updateDeps([this.isScrolling, startIndex, endIndex]);
        return [
          this.options.rangeExtractor,
          this.options.overscan,
          this.options.count,
          startIndex,
          endIndex
        ];
      },
      (rangeExtractor, overscan, count, startIndex, endIndex) => {
        return startIndex === null || endIndex === null ? [] : rangeExtractor({
          startIndex,
          endIndex,
          overscan,
          count
        });
      },
      {
        key: "getVirtualIndexes",
        debug: () => this.options.debug
      }
    );
    this.indexFromElement = (node) => {
      const attributeName = this.options.indexAttribute;
      const indexStr = node.getAttribute(attributeName);
      if (!indexStr) {
        console.warn(
          `Missing attribute name '${attributeName}={index}' on measured element.`
        );
        return -1;
      }
      return parseInt(indexStr, 10);
    };
    this._measureElement = (node, entry) => {
      const index = this.indexFromElement(node);
      const item = this.measurementsCache[index];
      if (!item) {
        return;
      }
      const key = item.key;
      const prevNode = this.elementsCache.get(key);
      if (prevNode !== node) {
        if (prevNode) {
          this.observer.unobserve(prevNode);
        }
        this.observer.observe(node);
        this.elementsCache.set(key, node);
      }
      if (node.isConnected) {
        this.resizeItem(index, this.options.measureElement(node, entry, this));
      }
    };
    this.resizeItem = (index, size) => {
      const item = this.measurementsCache[index];
      if (!item) {
        return;
      }
      const itemSize = this.itemSizeCache.get(item.key) ?? item.size;
      const delta = size - itemSize;
      if (delta !== 0) {
        if (this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this) : item.start < this.getScrollOffset() + this.scrollAdjustments) {
          if (this.options.debug) {
            console.info("correction", delta);
          }
          this._scrollToOffset(this.getScrollOffset(), {
            adjustments: this.scrollAdjustments += delta,
            behavior: void 0
          });
        }
        this.pendingMeasuredCacheIndexes.push(item.index);
        this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size));
        this.notify(false);
      }
    };
    this.measureElement = (node) => {
      if (!node) {
        this.elementsCache.forEach((cached, key) => {
          if (!cached.isConnected) {
            this.observer.unobserve(cached);
            this.elementsCache.delete(key);
          }
        });
        return;
      }
      this._measureElement(node, void 0);
    };
    this.getVirtualItems = memo(
      () => [this.getVirtualIndexes(), this.getMeasurements()],
      (indexes, measurements) => {
        const virtualItems = [];
        for (let k4 = 0, len = indexes.length; k4 < len; k4++) {
          const i9 = indexes[k4];
          const measurement = measurements[i9];
          virtualItems.push(measurement);
        }
        return virtualItems;
      },
      {
        key: "getVirtualItems",
        debug: () => this.options.debug
      }
    );
    this.getVirtualItemForOffset = (offset) => {
      const measurements = this.getMeasurements();
      if (measurements.length === 0) {
        return void 0;
      }
      return notUndefined(
        measurements[findNearestBinarySearch(
          0,
          measurements.length - 1,
          (index) => notUndefined(measurements[index]).start,
          offset
        )]
      );
    };
    this.getOffsetForAlignment = (toOffset, align, itemSize = 0) => {
      const size = this.getSize();
      const scrollOffset = this.getScrollOffset();
      if (align === "auto") {
        align = toOffset >= scrollOffset + size ? "end" : "start";
      }
      if (align === "center") {
        toOffset += (itemSize - size) / 2;
      } else if (align === "end") {
        toOffset -= size;
      }
      const maxOffset = this.getTotalSize() + this.options.scrollMargin - size;
      return Math.max(Math.min(maxOffset, toOffset), 0);
    };
    this.getOffsetForIndex = (index, align = "auto") => {
      index = Math.max(0, Math.min(index, this.options.count - 1));
      const item = this.measurementsCache[index];
      if (!item) {
        return void 0;
      }
      const size = this.getSize();
      const scrollOffset = this.getScrollOffset();
      if (align === "auto") {
        if (item.end >= scrollOffset + size - this.options.scrollPaddingEnd) {
          align = "end";
        } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {
          align = "start";
        } else {
          return [scrollOffset, align];
        }
      }
      const toOffset = align === "end" ? item.end + this.options.scrollPaddingEnd : item.start - this.options.scrollPaddingStart;
      return [
        this.getOffsetForAlignment(toOffset, align, item.size),
        align
      ];
    };
    this.isDynamicMode = () => this.elementsCache.size > 0;
    this.scrollToOffset = (toOffset, { align = "start", behavior } = {}) => {
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {
        adjustments: void 0,
        behavior
      });
    };
    this.scrollToIndex = (index, { align: initialAlign = "auto", behavior } = {}) => {
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      index = Math.max(0, Math.min(index, this.options.count - 1));
      let attempts = 0;
      const maxAttempts = 10;
      const tryScroll = (currentAlign) => {
        if (!this.targetWindow)
          return;
        const offsetInfo = this.getOffsetForIndex(index, currentAlign);
        if (!offsetInfo) {
          console.warn("Failed to get offset for index:", index);
          return;
        }
        const [offset, align] = offsetInfo;
        this._scrollToOffset(offset, { adjustments: void 0, behavior });
        this.targetWindow.requestAnimationFrame(() => {
          const currentOffset = this.getScrollOffset();
          const afterInfo = this.getOffsetForIndex(index, align);
          if (!afterInfo) {
            console.warn("Failed to get offset for index:", index);
            return;
          }
          if (!approxEqual(afterInfo[0], currentOffset)) {
            scheduleRetry(align);
          }
        });
      };
      const scheduleRetry = (align) => {
        if (!this.targetWindow)
          return;
        attempts++;
        if (attempts < maxAttempts) {
          if (this.options.debug) {
            console.info("Schedule retry", attempts, maxAttempts);
          }
          this.targetWindow.requestAnimationFrame(() => tryScroll(align));
        } else {
          console.warn(
            `Failed to scroll to index ${index} after ${maxAttempts} attempts.`
          );
        }
      };
      tryScroll(initialAlign);
    };
    this.scrollBy = (delta, { behavior } = {}) => {
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      this._scrollToOffset(this.getScrollOffset() + delta, {
        adjustments: void 0,
        behavior
      });
    };
    this.getTotalSize = () => {
      var _a;
      const measurements = this.getMeasurements();
      let end;
      if (measurements.length === 0) {
        end = this.options.paddingStart;
      } else if (this.options.lanes === 1) {
        end = ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0;
      } else {
        const endByLane = Array(this.options.lanes).fill(null);
        let endIndex = measurements.length - 1;
        while (endIndex >= 0 && endByLane.some((val) => val === null)) {
          const item = measurements[endIndex];
          if (endByLane[item.lane] === null) {
            endByLane[item.lane] = item.end;
          }
          endIndex--;
        }
        end = Math.max(...endByLane.filter((val) => val !== null));
      }
      return Math.max(
        end - this.options.scrollMargin + this.options.paddingEnd,
        0
      );
    };
    this._scrollToOffset = (offset, {
      adjustments,
      behavior
    }) => {
      this.options.scrollToFn(offset, { behavior, adjustments }, this);
    };
    this.measure = () => {
      this.itemSizeCache = /* @__PURE__ */ new Map();
      this.notify(false);
    };
    this.setOptions(opts);
  }
};
var findNearestBinarySearch = (low, high, getCurrentValue, value) => {
  while (low <= high) {
    const middle = (low + high) / 2 | 0;
    const currentValue = getCurrentValue(middle);
    if (currentValue < value) {
      low = middle + 1;
    } else if (currentValue > value) {
      high = middle - 1;
    } else {
      return middle;
    }
  }
  if (low > 0) {
    return low - 1;
  } else {
    return 0;
  }
};
function calculateRange({
  measurements,
  outerSize,
  scrollOffset,
  lanes
}) {
  const lastIndex = measurements.length - 1;
  const getOffset = (index) => measurements[index].start;
  if (measurements.length <= lanes) {
    return {
      startIndex: 0,
      endIndex: lastIndex
    };
  }
  let startIndex = findNearestBinarySearch(
    0,
    lastIndex,
    getOffset,
    scrollOffset
  );
  let endIndex = startIndex;
  if (lanes === 1) {
    while (endIndex < lastIndex && measurements[endIndex].end < scrollOffset + outerSize) {
      endIndex++;
    }
  } else if (lanes > 1) {
    const endPerLane = Array(lanes).fill(0);
    while (endIndex < lastIndex && endPerLane.some((pos) => pos < scrollOffset + outerSize)) {
      const item = measurements[endIndex];
      endPerLane[item.lane] = item.end;
      endIndex++;
    }
    const startPerLane = Array(lanes).fill(scrollOffset + outerSize);
    while (startIndex >= 0 && startPerLane.some((pos) => pos >= scrollOffset)) {
      const item = measurements[startIndex];
      startPerLane[item.lane] = item.start;
      startIndex--;
    }
    startIndex = Math.max(0, startIndex - startIndex % lanes);
    endIndex = Math.min(lastIndex, endIndex + (lanes - 1 - endIndex % lanes));
  }
  return { startIndex, endIndex };
}

// node_modules/@tanstack/react-virtual/dist/esm/index.js
var useIsomorphicLayoutEffect = typeof document !== "undefined" ? React.useLayoutEffect : React.useEffect;
function useVirtualizerBase(options) {
  const rerender = React.useReducer(() => ({}), {})[1];
  const resolvedOptions = {
    ...options,
    onChange: (instance2, sync) => {
      var _a;
      if (sync) {
        (0, import_react_dom.flushSync)(rerender);
      } else {
        rerender();
      }
      (_a = options.onChange) == null ? void 0 : _a.call(options, instance2, sync);
    }
  };
  const [instance] = React.useState(
    () => new Virtualizer(resolvedOptions)
  );
  instance.setOptions(resolvedOptions);
  useIsomorphicLayoutEffect(() => {
    return instance._didMount();
  }, []);
  useIsomorphicLayoutEffect(() => {
    return instance._willUpdate();
  });
  return instance;
}
function useVirtualizer(options) {
  return useVirtualizerBase({
    observeElementRect,
    observeElementOffset,
    scrollToFn: elementScroll,
    ...options
  });
}

// node_modules/@headlessui/react/dist/components/combobox/combobox.js
var import_react19 = __toESM(require_react(), 1);

// node_modules/@headlessui/react/dist/hooks/use-computed.js
var import_react3 = __toESM(require_react(), 1);

// node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js
var import_react = __toESM(require_react(), 1);

// node_modules/@headlessui/react/dist/utils/env.js
var i = Object.defineProperty;
var d = (t19, e5, n8) => e5 in t19 ? i(t19, e5, { enumerable: true, configurable: true, writable: true, value: n8 }) : t19[e5] = n8;
var r = (t19, e5, n8) => (d(t19, typeof e5 != "symbol" ? e5 + "" : e5, n8), n8);
var o = class {
  constructor() {
    r(this, "current", this.detect());
    r(this, "handoffState", "pending");
    r(this, "currentId", 0);
  }
  set(e5) {
    this.current !== e5 && (this.handoffState = "pending", this.currentId = 0, this.current = e5);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window == "undefined" || typeof document == "undefined" ? "server" : "client";
  }
  handoff() {
    this.handoffState === "pending" && (this.handoffState = "complete");
  }
  get isHandoffComplete() {
    return this.handoffState === "complete";
  }
};
var s = new o();

// node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js
var l = (e5, f15) => {
  s.isServer ? (0, import_react.useEffect)(e5, f15) : (0, import_react.useLayoutEffect)(e5, f15);
};

// node_modules/@headlessui/react/dist/hooks/use-latest-value.js
var import_react2 = __toESM(require_react(), 1);
function s2(e5) {
  let r10 = (0, import_react2.useRef)(e5);
  return l(() => {
    r10.current = e5;
  }, [e5]), r10;
}

// node_modules/@headlessui/react/dist/hooks/use-computed.js
function i2(e5, o14) {
  let [u14, t19] = (0, import_react3.useState)(e5), r10 = s2(e5);
  return l(() => t19(r10.current), [r10, t19, ...o14]), u14;
}

// node_modules/@headlessui/react/dist/hooks/use-controllable.js
var import_react5 = __toESM(require_react(), 1);

// node_modules/@headlessui/react/dist/hooks/use-event.js
var import_react4 = __toESM(require_react(), 1);
var o2 = function(t19) {
  let e5 = s2(t19);
  return import_react4.default.useCallback((...r10) => e5.current(...r10), [e5]);
};

// node_modules/@headlessui/react/dist/hooks/use-controllable.js
function T(l14, r10, c14) {
  let [i9, s18] = (0, import_react5.useState)(c14), e5 = l14 !== void 0, t19 = (0, import_react5.useRef)(e5), u14 = (0, import_react5.useRef)(false), d17 = (0, import_react5.useRef)(false);
  return e5 && !t19.current && !u14.current ? (u14.current = true, t19.current = e5, console.error("A component is changing from uncontrolled to controlled. This may be caused by the value changing from undefined to a defined value, which should not happen.")) : !e5 && t19.current && !d17.current && (d17.current = true, t19.current = e5, console.error("A component is changing from controlled to uncontrolled. This may be caused by the value changing from a defined value to undefined, which should not happen.")), [e5 ? l14 : i9, o2((n8) => (e5 || s18(n8), r10 == null ? void 0 : r10(n8)))];
}

// node_modules/@headlessui/react/dist/hooks/use-disposables.js
var import_react6 = __toESM(require_react(), 1);

// node_modules/@headlessui/react/dist/utils/micro-task.js
function t3(e5) {
  typeof queueMicrotask == "function" ? queueMicrotask(e5) : Promise.resolve().then(e5).catch((o14) => setTimeout(() => {
    throw o14;
  }));
}

// node_modules/@headlessui/react/dist/utils/disposables.js
function o4() {
  let n8 = [], r10 = { addEventListener(e5, t19, s18, a11) {
    return e5.addEventListener(t19, s18, a11), r10.add(() => e5.removeEventListener(t19, s18, a11));
  }, requestAnimationFrame(...e5) {
    let t19 = requestAnimationFrame(...e5);
    return r10.add(() => cancelAnimationFrame(t19));
  }, nextFrame(...e5) {
    return r10.requestAnimationFrame(() => r10.requestAnimationFrame(...e5));
  }, setTimeout(...e5) {
    let t19 = setTimeout(...e5);
    return r10.add(() => clearTimeout(t19));
  }, microTask(...e5) {
    let t19 = { current: true };
    return t3(() => {
      t19.current && e5[0]();
    }), r10.add(() => {
      t19.current = false;
    });
  }, style(e5, t19, s18) {
    let a11 = e5.style.getPropertyValue(t19);
    return Object.assign(e5.style, { [t19]: s18 }), this.add(() => {
      Object.assign(e5.style, { [t19]: a11 });
    });
  }, group(e5) {
    let t19 = o4();
    return e5(t19), this.add(() => t19.dispose());
  }, add(e5) {
    return n8.push(e5), () => {
      let t19 = n8.indexOf(e5);
      if (t19 >= 0)
        for (let s18 of n8.splice(t19, 1))
          s18();
    };
  }, dispose() {
    for (let e5 of n8.splice(0))
      e5();
  } };
  return r10;
}

// node_modules/@headlessui/react/dist/hooks/use-disposables.js
function p() {
  let [e5] = (0, import_react6.useState)(o4);
  return (0, import_react6.useEffect)(() => () => e5.dispose(), [e5]), e5;
}

// node_modules/@headlessui/react/dist/hooks/use-id.js
var import_react7 = __toESM(require_react(), 1);

// node_modules/@headlessui/react/dist/hooks/use-server-handoff-complete.js
var t4 = __toESM(require_react(), 1);
function s5() {
  let r10 = typeof document == "undefined";
  return "useSyncExternalStore" in t4 ? ((o14) => o14.useSyncExternalStore)(t4)(() => () => {
  }, () => false, () => !r10) : false;
}
function l2() {
  let r10 = s5(), [e5, n8] = t4.useState(s.isHandoffComplete);
  return e5 && s.isHandoffComplete === false && n8(false), t4.useEffect(() => {
    e5 !== true && n8(true);
  }, [e5]), t4.useEffect(() => s.handoff(), []), r10 ? false : e5;
}

// node_modules/@headlessui/react/dist/hooks/use-id.js
var o6;
var I = (o6 = import_react7.default.useId) != null ? o6 : function() {
  let n8 = l2(), [e5, u14] = import_react7.default.useState(n8 ? () => s.nextId() : null);
  return l(() => {
    e5 === null && u14(s.nextId());
  }, [e5]), e5 != null ? "" + e5 : void 0;
};

// node_modules/@headlessui/react/dist/hooks/use-outside-click.js
var import_react10 = __toESM(require_react(), 1);

// node_modules/@headlessui/react/dist/utils/match.js
function u(r10, n8, ...a11) {
  if (r10 in n8) {
    let e5 = n8[r10];
    return typeof e5 == "function" ? e5(...a11) : e5;
  }
  let t19 = new Error(`Tried to handle "${r10}" but there is no handler defined. Only defined handlers are: ${Object.keys(n8).map((e5) => `"${e5}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(t19, u), t19;
}

// node_modules/@headlessui/react/dist/utils/owner.js
function o7(r10) {
  return s.isServer ? null : r10 instanceof Node ? r10.ownerDocument : r10 != null && r10.hasOwnProperty("current") && r10.current instanceof Node ? r10.current.ownerDocument : document;
}

// node_modules/@headlessui/react/dist/utils/focus-management.js
var c2 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((e5) => `${e5}:not([tabindex='-1'])`).join(",");
var M = ((n8) => (n8[n8.First = 1] = "First", n8[n8.Previous = 2] = "Previous", n8[n8.Next = 4] = "Next", n8[n8.Last = 8] = "Last", n8[n8.WrapAround = 16] = "WrapAround", n8[n8.NoScroll = 32] = "NoScroll", n8))(M || {});
var N = ((o14) => (o14[o14.Error = 0] = "Error", o14[o14.Overflow = 1] = "Overflow", o14[o14.Success = 2] = "Success", o14[o14.Underflow = 3] = "Underflow", o14))(N || {});
var F = ((t19) => (t19[t19.Previous = -1] = "Previous", t19[t19.Next = 1] = "Next", t19))(F || {});
function f2(e5 = document.body) {
  return e5 == null ? [] : Array.from(e5.querySelectorAll(c2)).sort((r10, t19) => Math.sign((r10.tabIndex || Number.MAX_SAFE_INTEGER) - (t19.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var T2 = ((t19) => (t19[t19.Strict = 0] = "Strict", t19[t19.Loose = 1] = "Loose", t19))(T2 || {});
function h(e5, r10 = 0) {
  var t19;
  return e5 === ((t19 = o7(e5)) == null ? void 0 : t19.body) ? false : u(r10, { [0]() {
    return e5.matches(c2);
  }, [1]() {
    let l14 = e5;
    for (; l14 !== null; ) {
      if (l14.matches(c2))
        return true;
      l14 = l14.parentElement;
    }
    return false;
  } });
}
function D(e5) {
  let r10 = o7(e5);
  o4().nextFrame(() => {
    r10 && !h(r10.activeElement, 0) && y(e5);
  });
}
var w = ((t19) => (t19[t19.Keyboard = 0] = "Keyboard", t19[t19.Mouse = 1] = "Mouse", t19))(w || {});
typeof window != "undefined" && typeof document != "undefined" && (document.addEventListener("keydown", (e5) => {
  e5.metaKey || e5.altKey || e5.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, true), document.addEventListener("click", (e5) => {
  e5.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : e5.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, true));
function y(e5) {
  e5 == null || e5.focus({ preventScroll: true });
}
var S = ["textarea", "input"].join(",");
function H(e5) {
  var r10, t19;
  return (t19 = (r10 = e5 == null ? void 0 : e5.matches) == null ? void 0 : r10.call(e5, S)) != null ? t19 : false;
}
function I2(e5, r10 = (t19) => t19) {
  return e5.slice().sort((t19, l14) => {
    let o14 = r10(t19), i9 = r10(l14);
    if (o14 === null || i9 === null)
      return 0;
    let n8 = o14.compareDocumentPosition(i9);
    return n8 & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : n8 & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function _(e5, r10) {
  return O(f2(), r10, { relativeTo: e5 });
}
function O(e5, r10, { sorted: t19 = true, relativeTo: l14 = null, skipElements: o14 = [] } = {}) {
  let i9 = Array.isArray(e5) ? e5.length > 0 ? e5[0].ownerDocument : document : e5.ownerDocument, n8 = Array.isArray(e5) ? t19 ? I2(e5) : e5 : f2(e5);
  o14.length > 0 && n8.length > 1 && (n8 = n8.filter((s18) => !o14.includes(s18))), l14 = l14 != null ? l14 : i9.activeElement;
  let E9 = (() => {
    if (r10 & 5)
      return 1;
    if (r10 & 10)
      return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), x5 = (() => {
    if (r10 & 1)
      return 0;
    if (r10 & 2)
      return Math.max(0, n8.indexOf(l14)) - 1;
    if (r10 & 4)
      return Math.max(0, n8.indexOf(l14)) + 1;
    if (r10 & 8)
      return n8.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), p8 = r10 & 32 ? { preventScroll: true } : {}, d17 = 0, a11 = n8.length, u14;
  do {
    if (d17 >= a11 || d17 + a11 <= 0)
      return 0;
    let s18 = x5 + d17;
    if (r10 & 16)
      s18 = (s18 + a11) % a11;
    else {
      if (s18 < 0)
        return 3;
      if (s18 >= a11)
        return 1;
    }
    u14 = n8[s18], u14 == null || u14.focus(p8), d17 += E9;
  } while (u14 !== i9.activeElement);
  return r10 & 6 && H(u14) && u14.select(), 2;
}

// node_modules/@headlessui/react/dist/utils/platform.js
function t6() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function i3() {
  return /Android/gi.test(window.navigator.userAgent);
}
function n() {
  return t6() || i3();
}

// node_modules/@headlessui/react/dist/hooks/use-document-event.js
var import_react8 = __toESM(require_react(), 1);
function d2(e5, r10, n8) {
  let o14 = s2(r10);
  (0, import_react8.useEffect)(() => {
    function t19(u14) {
      o14.current(u14);
    }
    return document.addEventListener(e5, t19, n8), () => document.removeEventListener(e5, t19, n8);
  }, [e5, n8]);
}

// node_modules/@headlessui/react/dist/hooks/use-window-event.js
var import_react9 = __toESM(require_react(), 1);
function s6(e5, r10, n8) {
  let o14 = s2(r10);
  (0, import_react9.useEffect)(() => {
    function t19(i9) {
      o14.current(i9);
    }
    return window.addEventListener(e5, t19, n8), () => window.removeEventListener(e5, t19, n8);
  }, [e5, n8]);
}

// node_modules/@headlessui/react/dist/hooks/use-outside-click.js
function y2(s18, m13, a11 = true) {
  let i9 = (0, import_react10.useRef)(false);
  (0, import_react10.useEffect)(() => {
    requestAnimationFrame(() => {
      i9.current = a11;
    });
  }, [a11]);
  function c14(e5, r10) {
    if (!i9.current || e5.defaultPrevented)
      return;
    let t19 = r10(e5);
    if (t19 === null || !t19.getRootNode().contains(t19) || !t19.isConnected)
      return;
    let E9 = function u14(n8) {
      return typeof n8 == "function" ? u14(n8()) : Array.isArray(n8) || n8 instanceof Set ? n8 : [n8];
    }(s18);
    for (let u14 of E9) {
      if (u14 === null)
        continue;
      let n8 = u14 instanceof HTMLElement ? u14 : u14.current;
      if (n8 != null && n8.contains(t19) || e5.composed && e5.composedPath().includes(n8))
        return;
    }
    return !h(t19, T2.Loose) && t19.tabIndex !== -1 && e5.preventDefault(), m13(e5, t19);
  }
  let o14 = (0, import_react10.useRef)(null);
  d2("pointerdown", (e5) => {
    var r10, t19;
    i9.current && (o14.current = ((t19 = (r10 = e5.composedPath) == null ? void 0 : r10.call(e5)) == null ? void 0 : t19[0]) || e5.target);
  }, true), d2("mousedown", (e5) => {
    var r10, t19;
    i9.current && (o14.current = ((t19 = (r10 = e5.composedPath) == null ? void 0 : r10.call(e5)) == null ? void 0 : t19[0]) || e5.target);
  }, true), d2("click", (e5) => {
    n() || o14.current && (c14(e5, () => o14.current), o14.current = null);
  }, true), d2("touchend", (e5) => c14(e5, () => e5.target instanceof HTMLElement ? e5.target : null), true), s6("blur", (e5) => c14(e5, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), true);
}

// node_modules/@headlessui/react/dist/hooks/use-owner.js
var import_react11 = __toESM(require_react(), 1);
function n2(...e5) {
  return (0, import_react11.useMemo)(() => o7(...e5), [...e5]);
}

// node_modules/@headlessui/react/dist/hooks/use-resolve-button-type.js
var import_react12 = __toESM(require_react(), 1);
function i4(t19) {
  var n8;
  if (t19.type)
    return t19.type;
  let e5 = (n8 = t19.as) != null ? n8 : "button";
  if (typeof e5 == "string" && e5.toLowerCase() === "button")
    return "button";
}
function T3(t19, e5) {
  let [n8, u14] = (0, import_react12.useState)(() => i4(t19));
  return l(() => {
    u14(i4(t19));
  }, [t19.type, t19.as]), l(() => {
    n8 || e5.current && e5.current instanceof HTMLButtonElement && !e5.current.hasAttribute("type") && u14("button");
  }, [n8, e5]), n8;
}

// node_modules/@headlessui/react/dist/hooks/use-sync-refs.js
var import_react13 = __toESM(require_react(), 1);
var u2 = Symbol();
function T4(t19, n8 = true) {
  return Object.assign(t19, { [u2]: n8 });
}
function y3(...t19) {
  let n8 = (0, import_react13.useRef)(t19);
  (0, import_react13.useEffect)(() => {
    n8.current = t19;
  }, [t19]);
  let c14 = o2((e5) => {
    for (let o14 of n8.current)
      o14 != null && (typeof o14 == "function" ? o14(e5) : o14.current = e5);
  });
  return t19.every((e5) => e5 == null || (e5 == null ? void 0 : e5[u2])) ? void 0 : c14;
}

// node_modules/@headlessui/react/dist/hooks/use-tracked-pointer.js
var import_react14 = __toESM(require_react(), 1);
function t8(e5) {
  return [e5.screenX, e5.screenY];
}
function u3() {
  let e5 = (0, import_react14.useRef)([-1, -1]);
  return { wasMoved(r10) {
    let n8 = t8(r10);
    return e5.current[0] === n8[0] && e5.current[1] === n8[1] ? false : (e5.current = n8, true);
  }, update(r10) {
    e5.current = t8(r10);
  } };
}

// node_modules/@headlessui/react/dist/hooks/use-tree-walker.js
var import_react15 = __toESM(require_react(), 1);
function F2({ container: e5, accept: t19, walk: r10, enabled: c14 = true }) {
  let o14 = (0, import_react15.useRef)(t19), l14 = (0, import_react15.useRef)(r10);
  (0, import_react15.useEffect)(() => {
    o14.current = t19, l14.current = r10;
  }, [t19, r10]), l(() => {
    if (!e5 || !c14)
      return;
    let n8 = o7(e5);
    if (!n8)
      return;
    let f15 = o14.current, p8 = l14.current, d17 = Object.assign((i9) => f15(i9), { acceptNode: f15 }), u14 = n8.createTreeWalker(e5, NodeFilter.SHOW_ELEMENT, d17, false);
    for (; u14.nextNode(); )
      p8(u14.currentNode);
  }, [e5, c14, o14, l14]);
}

// node_modules/@headlessui/react/dist/hooks/use-watch.js
var import_react16 = __toESM(require_react(), 1);
function m3(u14, t19) {
  let e5 = (0, import_react16.useRef)([]), r10 = o2(u14);
  (0, import_react16.useEffect)(() => {
    let o14 = [...e5.current];
    for (let [n8, a11] of t19.entries())
      if (e5.current[n8] !== a11) {
        let l14 = r10(t19, o14);
        return e5.current = t19, l14;
      }
  }, [r10, ...t19]);
}

// node_modules/@headlessui/react/dist/utils/render.js
var import_react17 = __toESM(require_react(), 1);

// node_modules/@headlessui/react/dist/utils/class-names.js
function t9(...r10) {
  return Array.from(new Set(r10.flatMap((n8) => typeof n8 == "string" ? n8.split(" ") : []))).filter(Boolean).join(" ");
}

// node_modules/@headlessui/react/dist/utils/render.js
var O2 = ((n8) => (n8[n8.None = 0] = "None", n8[n8.RenderStrategy = 1] = "RenderStrategy", n8[n8.Static = 2] = "Static", n8))(O2 || {});
var v = ((e5) => (e5[e5.Unmount = 0] = "Unmount", e5[e5.Hidden = 1] = "Hidden", e5))(v || {});
function C({ ourProps: r10, theirProps: t19, slot: e5, defaultTag: n8, features: o14, visible: a11 = true, name: f15, mergeRefs: l14 }) {
  l14 = l14 != null ? l14 : k;
  let s18 = R(t19, r10);
  if (a11)
    return m4(s18, e5, n8, f15, l14);
  let y8 = o14 != null ? o14 : 0;
  if (y8 & 2) {
    let { static: u14 = false, ...d17 } = s18;
    if (u14)
      return m4(d17, e5, n8, f15, l14);
  }
  if (y8 & 1) {
    let { unmount: u14 = true, ...d17 } = s18;
    return u(u14 ? 0 : 1, { [0]() {
      return null;
    }, [1]() {
      return m4({ ...d17, hidden: true, style: { display: "none" } }, e5, n8, f15, l14);
    } });
  }
  return m4(s18, e5, n8, f15, l14);
}
function m4(r10, t19 = {}, e5, n8, o14) {
  let { as: a11 = e5, children: f15, refName: l14 = "ref", ...s18 } = F3(r10, ["unmount", "static"]), y8 = r10.ref !== void 0 ? { [l14]: r10.ref } : {}, u14 = typeof f15 == "function" ? f15(t19) : f15;
  "className" in s18 && s18.className && typeof s18.className == "function" && (s18.className = s18.className(t19));
  let d17 = {};
  if (t19) {
    let i9 = false, c14 = [];
    for (let [T8, p8] of Object.entries(t19))
      typeof p8 == "boolean" && (i9 = true), p8 === true && c14.push(T8);
    i9 && (d17["data-headlessui-state"] = c14.join(" "));
  }
  if (a11 === import_react17.Fragment && Object.keys(x(s18)).length > 0) {
    if (!(0, import_react17.isValidElement)(u14) || Array.isArray(u14) && u14.length > 1)
      throw new Error(['Passing props on "Fragment"!', "", `The current component <${n8} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(s18).map((p8) => `  - ${p8}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((p8) => `  - ${p8}`).join(`
`)].join(`
`));
    let i9 = u14.props, c14 = typeof (i9 == null ? void 0 : i9.className) == "function" ? (...p8) => t9(i9 == null ? void 0 : i9.className(...p8), s18.className) : t9(i9 == null ? void 0 : i9.className, s18.className), T8 = c14 ? { className: c14 } : {};
    return (0, import_react17.cloneElement)(u14, Object.assign({}, R(u14.props, x(F3(s18, ["ref"]))), d17, y8, { ref: o14(u14.ref, y8.ref) }, T8));
  }
  return (0, import_react17.createElement)(a11, Object.assign({}, F3(s18, ["ref"]), a11 !== import_react17.Fragment && y8, a11 !== import_react17.Fragment && d17), u14);
}
function I3() {
  let r10 = (0, import_react17.useRef)([]), t19 = (0, import_react17.useCallback)((e5) => {
    for (let n8 of r10.current)
      n8 != null && (typeof n8 == "function" ? n8(e5) : n8.current = e5);
  }, []);
  return (...e5) => {
    if (!e5.every((n8) => n8 == null))
      return r10.current = e5, t19;
  };
}
function k(...r10) {
  return r10.every((t19) => t19 == null) ? void 0 : (t19) => {
    for (let e5 of r10)
      e5 != null && (typeof e5 == "function" ? e5(t19) : e5.current = t19);
  };
}
function R(...r10) {
  var n8;
  if (r10.length === 0)
    return {};
  if (r10.length === 1)
    return r10[0];
  let t19 = {}, e5 = {};
  for (let o14 of r10)
    for (let a11 in o14)
      a11.startsWith("on") && typeof o14[a11] == "function" ? ((n8 = e5[a11]) != null || (e5[a11] = []), e5[a11].push(o14[a11])) : t19[a11] = o14[a11];
  if (t19.disabled || t19["aria-disabled"])
    return Object.assign(t19, Object.fromEntries(Object.keys(e5).map((o14) => [o14, void 0])));
  for (let o14 in e5)
    Object.assign(t19, { [o14](a11, ...f15) {
      let l14 = e5[o14];
      for (let s18 of l14) {
        if ((a11 instanceof Event || (a11 == null ? void 0 : a11.nativeEvent) instanceof Event) && a11.defaultPrevented)
          return;
        s18(a11, ...f15);
      }
    } });
  return t19;
}
function U(r10) {
  var t19;
  return Object.assign((0, import_react17.forwardRef)(r10), { displayName: (t19 = r10.displayName) != null ? t19 : r10.name });
}
function x(r10) {
  let t19 = Object.assign({}, r10);
  for (let e5 in t19)
    t19[e5] === void 0 && delete t19[e5];
  return t19;
}
function F3(r10, t19 = []) {
  let e5 = Object.assign({}, r10);
  for (let n8 of t19)
    n8 in e5 && delete e5[n8];
  return e5;
}

// node_modules/@headlessui/react/dist/internal/hidden.js
var p2 = "div";
var s8 = ((e5) => (e5[e5.None = 1] = "None", e5[e5.Focusable = 2] = "Focusable", e5[e5.Hidden = 4] = "Hidden", e5))(s8 || {});
function l4(d17, o14) {
  var n8;
  let { features: t19 = 1, ...e5 } = d17, r10 = { ref: o14, "aria-hidden": (t19 & 2) === 2 ? true : (n8 = e5["aria-hidden"]) != null ? n8 : void 0, hidden: (t19 & 4) === 4 ? true : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(t19 & 4) === 4 && (t19 & 2) !== 2 && { display: "none" } } };
  return C({ ourProps: r10, theirProps: e5, slot: {}, defaultTag: p2, name: "Hidden" });
}
var u4 = U(l4);

// node_modules/@headlessui/react/dist/internal/open-closed.js
var import_react18 = __toESM(require_react(), 1);
var n3 = (0, import_react18.createContext)(null);
n3.displayName = "OpenClosedContext";
var d5 = ((e5) => (e5[e5.Open = 1] = "Open", e5[e5.Closed = 2] = "Closed", e5[e5.Closing = 4] = "Closing", e5[e5.Opening = 8] = "Opening", e5))(d5 || {});
function u5() {
  return (0, import_react18.useContext)(n3);
}
function s9({ value: o14, children: r10 }) {
  return import_react18.default.createElement(n3.Provider, { value: o14 }, r10);
}

// node_modules/@headlessui/react/dist/utils/document-ready.js
function t11(n8) {
  function e5() {
    document.readyState !== "loading" && (n8(), document.removeEventListener("DOMContentLoaded", e5));
  }
  typeof window != "undefined" && typeof document != "undefined" && (document.addEventListener("DOMContentLoaded", e5), e5());
}

// node_modules/@headlessui/react/dist/utils/active-element-history.js
var t12 = [];
t11(() => {
  function e5(n8) {
    n8.target instanceof HTMLElement && n8.target !== document.body && t12[0] !== n8.target && (t12.unshift(n8.target), t12 = t12.filter((r10) => r10 != null && r10.isConnected), t12.splice(10));
  }
  window.addEventListener("click", e5, { capture: true }), window.addEventListener("mousedown", e5, { capture: true }), window.addEventListener("focus", e5, { capture: true }), document.body.addEventListener("click", e5, { capture: true }), document.body.addEventListener("mousedown", e5, { capture: true }), document.body.addEventListener("focus", e5, { capture: true });
});

// node_modules/@headlessui/react/dist/utils/bugs.js
function r2(n8) {
  let e5 = n8.parentElement, l14 = null;
  for (; e5 && !(e5 instanceof HTMLFieldSetElement); )
    e5 instanceof HTMLLegendElement && (l14 = e5), e5 = e5.parentElement;
  let t19 = (e5 == null ? void 0 : e5.getAttribute("disabled")) === "";
  return t19 && i6(l14) ? false : t19;
}
function i6(n8) {
  if (!n8)
    return false;
  let e5 = n8.previousElementSibling;
  for (; e5 !== null; ) {
    if (e5 instanceof HTMLLegendElement)
      return false;
    e5 = e5.previousElementSibling;
  }
  return true;
}

// node_modules/@headlessui/react/dist/utils/calculate-active-index.js
function u6(l14) {
  throw new Error("Unexpected object: " + l14);
}
var c3 = ((i9) => (i9[i9.First = 0] = "First", i9[i9.Previous = 1] = "Previous", i9[i9.Next = 2] = "Next", i9[i9.Last = 3] = "Last", i9[i9.Specific = 4] = "Specific", i9[i9.Nothing = 5] = "Nothing", i9))(c3 || {});
function f5(l14, n8) {
  let t19 = n8.resolveItems();
  if (t19.length <= 0)
    return null;
  let r10 = n8.resolveActiveIndex(), s18 = r10 != null ? r10 : -1;
  switch (l14.focus) {
    case 0: {
      for (let e5 = 0; e5 < t19.length; ++e5)
        if (!n8.resolveDisabled(t19[e5], e5, t19))
          return e5;
      return r10;
    }
    case 1: {
      for (let e5 = s18 - 1; e5 >= 0; --e5)
        if (!n8.resolveDisabled(t19[e5], e5, t19))
          return e5;
      return r10;
    }
    case 2: {
      for (let e5 = s18 + 1; e5 < t19.length; ++e5)
        if (!n8.resolveDisabled(t19[e5], e5, t19))
          return e5;
      return r10;
    }
    case 3: {
      for (let e5 = t19.length - 1; e5 >= 0; --e5)
        if (!n8.resolveDisabled(t19[e5], e5, t19))
          return e5;
      return r10;
    }
    case 4: {
      for (let e5 = 0; e5 < t19.length; ++e5)
        if (n8.resolveId(t19[e5], e5, t19) === l14.id)
          return e5;
      return r10;
    }
    case 5:
      return null;
    default:
      u6(l14);
  }
}

// node_modules/@headlessui/react/dist/utils/form.js
function e(i9 = {}, s18 = null, t19 = []) {
  for (let [r10, n8] of Object.entries(i9))
    o10(t19, f6(s18, r10), n8);
  return t19;
}
function f6(i9, s18) {
  return i9 ? i9 + "[" + s18 + "]" : s18;
}
function o10(i9, s18, t19) {
  if (Array.isArray(t19))
    for (let [r10, n8] of t19.entries())
      o10(i9, f6(s18, r10.toString()), n8);
  else
    t19 instanceof Date ? i9.push([s18, t19.toISOString()]) : typeof t19 == "boolean" ? i9.push([s18, t19 ? "1" : "0"]) : typeof t19 == "string" ? i9.push([s18, t19]) : typeof t19 == "number" ? i9.push([s18, `${t19}`]) : t19 == null ? i9.push([s18, ""]) : e(t19, s18, i9);
}
function p4(i9) {
  var t19, r10;
  let s18 = (t19 = i9 == null ? void 0 : i9.form) != null ? t19 : i9.closest("form");
  if (s18) {
    for (let n8 of s18.elements)
      if (n8 !== i9 && (n8.tagName === "INPUT" && n8.type === "submit" || n8.tagName === "BUTTON" && n8.type === "submit" || n8.nodeName === "INPUT" && n8.type === "image")) {
        n8.click();
        return;
      }
    (r10 = s18.requestSubmit) == null || r10.call(s18);
  }
}

// node_modules/@headlessui/react/dist/components/keyboard.js
var o11 = ((r10) => (r10.Space = " ", r10.Enter = "Enter", r10.Escape = "Escape", r10.Backspace = "Backspace", r10.Delete = "Delete", r10.ArrowLeft = "ArrowLeft", r10.ArrowUp = "ArrowUp", r10.ArrowRight = "ArrowRight", r10.ArrowDown = "ArrowDown", r10.Home = "Home", r10.End = "End", r10.PageUp = "PageUp", r10.PageDown = "PageDown", r10.Tab = "Tab", r10))(o11 || {});

// node_modules/@headlessui/react/dist/components/combobox/combobox.js
var $e = ((o14) => (o14[o14.Open = 0] = "Open", o14[o14.Closed = 1] = "Closed", o14))($e || {});
var qe = ((o14) => (o14[o14.Single = 0] = "Single", o14[o14.Multi = 1] = "Multi", o14))(qe || {});
var ze = ((a11) => (a11[a11.Pointer = 0] = "Pointer", a11[a11.Focus = 1] = "Focus", a11[a11.Other = 2] = "Other", a11))(ze || {});
var Ye = ((e5) => (e5[e5.OpenCombobox = 0] = "OpenCombobox", e5[e5.CloseCombobox = 1] = "CloseCombobox", e5[e5.GoToOption = 2] = "GoToOption", e5[e5.RegisterOption = 3] = "RegisterOption", e5[e5.UnregisterOption = 4] = "UnregisterOption", e5[e5.RegisterLabel = 5] = "RegisterLabel", e5[e5.SetActivationTrigger = 6] = "SetActivationTrigger", e5[e5.UpdateVirtualOptions = 7] = "UpdateVirtualOptions", e5))(Ye || {});
function de(t19, r10 = (o14) => o14) {
  let o14 = t19.activeOptionIndex !== null ? t19.options[t19.activeOptionIndex] : null, a11 = r10(t19.options.slice()), i9 = a11.length > 0 && a11[0].dataRef.current.order !== null ? a11.sort((p8, c14) => p8.dataRef.current.order - c14.dataRef.current.order) : I2(a11, (p8) => p8.dataRef.current.domRef.current), u14 = o14 ? i9.indexOf(o14) : null;
  return u14 === -1 && (u14 = null), { options: i9, activeOptionIndex: u14 };
}
var Qe = { [1](t19) {
  var r10;
  return (r10 = t19.dataRef.current) != null && r10.disabled || t19.comboboxState === 1 ? t19 : { ...t19, activeOptionIndex: null, comboboxState: 1 };
}, [0](t19) {
  var r10, o14;
  if ((r10 = t19.dataRef.current) != null && r10.disabled || t19.comboboxState === 0)
    return t19;
  if ((o14 = t19.dataRef.current) != null && o14.value) {
    let a11 = t19.dataRef.current.calculateIndex(t19.dataRef.current.value);
    if (a11 !== -1)
      return { ...t19, activeOptionIndex: a11, comboboxState: 0 };
  }
  return { ...t19, comboboxState: 0 };
}, [2](t19, r10) {
  var u14, p8, c14, e5, l14;
  if ((u14 = t19.dataRef.current) != null && u14.disabled || (p8 = t19.dataRef.current) != null && p8.optionsRef.current && !((c14 = t19.dataRef.current) != null && c14.optionsPropsRef.current.static) && t19.comboboxState === 1)
    return t19;
  if (t19.virtual) {
    let T8 = r10.focus === c3.Specific ? r10.idx : f5(r10, { resolveItems: () => t19.virtual.options, resolveActiveIndex: () => {
      var f15, v7;
      return (v7 = (f15 = t19.activeOptionIndex) != null ? f15 : t19.virtual.options.findIndex((S11) => !t19.virtual.disabled(S11))) != null ? v7 : null;
    }, resolveDisabled: t19.virtual.disabled, resolveId() {
      throw new Error("Function not implemented.");
    } }), g6 = (e5 = r10.trigger) != null ? e5 : 2;
    return t19.activeOptionIndex === T8 && t19.activationTrigger === g6 ? t19 : { ...t19, activeOptionIndex: T8, activationTrigger: g6 };
  }
  let o14 = de(t19);
  if (o14.activeOptionIndex === null) {
    let T8 = o14.options.findIndex((g6) => !g6.dataRef.current.disabled);
    T8 !== -1 && (o14.activeOptionIndex = T8);
  }
  let a11 = r10.focus === c3.Specific ? r10.idx : f5(r10, { resolveItems: () => o14.options, resolveActiveIndex: () => o14.activeOptionIndex, resolveId: (T8) => T8.id, resolveDisabled: (T8) => T8.dataRef.current.disabled }), i9 = (l14 = r10.trigger) != null ? l14 : 2;
  return t19.activeOptionIndex === a11 && t19.activationTrigger === i9 ? t19 : { ...t19, ...o14, activeOptionIndex: a11, activationTrigger: i9 };
}, [3]: (t19, r10) => {
  var u14, p8, c14;
  if ((u14 = t19.dataRef.current) != null && u14.virtual)
    return { ...t19, options: [...t19.options, r10.payload] };
  let o14 = r10.payload, a11 = de(t19, (e5) => (e5.push(o14), e5));
  t19.activeOptionIndex === null && (p8 = t19.dataRef.current) != null && p8.isSelected(r10.payload.dataRef.current.value) && (a11.activeOptionIndex = a11.options.indexOf(o14));
  let i9 = { ...t19, ...a11, activationTrigger: 2 };
  return (c14 = t19.dataRef.current) != null && c14.__demoMode && t19.dataRef.current.value === void 0 && (i9.activeOptionIndex = 0), i9;
}, [4]: (t19, r10) => {
  var a11;
  if ((a11 = t19.dataRef.current) != null && a11.virtual)
    return { ...t19, options: t19.options.filter((i9) => i9.id !== r10.id) };
  let o14 = de(t19, (i9) => {
    let u14 = i9.findIndex((p8) => p8.id === r10.id);
    return u14 !== -1 && i9.splice(u14, 1), i9;
  });
  return { ...t19, ...o14, activationTrigger: 2 };
}, [5]: (t19, r10) => t19.labelId === r10.id ? t19 : { ...t19, labelId: r10.id }, [6]: (t19, r10) => t19.activationTrigger === r10.trigger ? t19 : { ...t19, activationTrigger: r10.trigger }, [7]: (t19, r10) => {
  var a11;
  if (((a11 = t19.virtual) == null ? void 0 : a11.options) === r10.options)
    return t19;
  let o14 = t19.activeOptionIndex;
  if (t19.activeOptionIndex !== null) {
    let i9 = r10.options.indexOf(t19.virtual.options[t19.activeOptionIndex]);
    i9 !== -1 ? o14 = i9 : o14 = null;
  }
  return { ...t19, activeOptionIndex: o14, virtual: Object.assign({}, t19.virtual, { options: r10.options }) };
} };
var be = (0, import_react19.createContext)(null);
be.displayName = "ComboboxActionsContext";
function ee(t19) {
  let r10 = (0, import_react19.useContext)(be);
  if (r10 === null) {
    let o14 = new Error(`<${t19} /> is missing a parent <Combobox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(o14, ee), o14;
  }
  return r10;
}
var Ce = (0, import_react19.createContext)(null);
function Ze(t19) {
  var c14;
  let r10 = j2("VirtualProvider"), [o14, a11] = (0, import_react19.useMemo)(() => {
    let e5 = r10.optionsRef.current;
    if (!e5)
      return [0, 0];
    let l14 = window.getComputedStyle(e5);
    return [parseFloat(l14.paddingBlockStart || l14.paddingTop), parseFloat(l14.paddingBlockEnd || l14.paddingBottom)];
  }, [r10.optionsRef.current]), i9 = useVirtualizer({ scrollPaddingStart: o14, scrollPaddingEnd: a11, count: r10.virtual.options.length, estimateSize() {
    return 40;
  }, getScrollElement() {
    var e5;
    return (e5 = r10.optionsRef.current) != null ? e5 : null;
  }, overscan: 12 }), [u14, p8] = (0, import_react19.useState)(0);
  return l(() => {
    p8((e5) => e5 + 1);
  }, [(c14 = r10.virtual) == null ? void 0 : c14.options]), import_react19.default.createElement(Ce.Provider, { value: i9 }, import_react19.default.createElement("div", { style: { position: "relative", width: "100%", height: `${i9.getTotalSize()}px` }, ref: (e5) => {
    if (e5) {
      if (typeof process != "undefined" && process.env.JEST_WORKER_ID !== void 0 || r10.activationTrigger === 0)
        return;
      r10.activeOptionIndex !== null && r10.virtual.options.length > r10.activeOptionIndex && i9.scrollToIndex(r10.activeOptionIndex);
    }
  } }, i9.getVirtualItems().map((e5) => {
    var l14;
    return import_react19.default.createElement(import_react19.Fragment, { key: e5.key }, import_react19.default.cloneElement((l14 = t19.children) == null ? void 0 : l14.call(t19, { option: r10.virtual.options[e5.index], open: r10.comboboxState === 0 }), { key: `${u14}-${e5.key}`, "data-index": e5.index, "aria-setsize": r10.virtual.options.length, "aria-posinset": e5.index + 1, style: { position: "absolute", top: 0, left: 0, transform: `translateY(${e5.start}px)`, overflowAnchor: "none" } }));
  })));
}
var ce = (0, import_react19.createContext)(null);
ce.displayName = "ComboboxDataContext";
function j2(t19) {
  let r10 = (0, import_react19.useContext)(ce);
  if (r10 === null) {
    let o14 = new Error(`<${t19} /> is missing a parent <Combobox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(o14, j2), o14;
  }
  return r10;
}
function et(t19, r10) {
  return u(r10.type, Qe, t19, r10);
}
var tt = import_react19.Fragment;
function ot(t19, r10) {
  var fe4;
  let { value: o14, defaultValue: a11, onChange: i9, form: u14, name: p8, by: c14 = null, disabled: e5 = false, __demoMode: l14 = false, nullable: T8 = false, multiple: g6 = false, immediate: f15 = false, virtual: v7 = null, ...S11 } = t19, R5 = false, s18 = null, [I12 = g6 ? [] : void 0, V6] = T(o14, i9, a11), [_5, E9] = (0, import_react19.useReducer)(et, { dataRef: (0, import_react19.createRef)(), comboboxState: l14 ? 0 : 1, options: [], virtual: s18 ? { options: s18.options, disabled: (fe4 = s18.disabled) != null ? fe4 : () => false } : null, activeOptionIndex: null, activationTrigger: 2, labelId: null }), k4 = (0, import_react19.useRef)(false), J7 = (0, import_react19.useRef)({ static: false, hold: false }), K5 = (0, import_react19.useRef)(null), z5 = (0, import_react19.useRef)(null), te5 = (0, import_react19.useRef)(null), X6 = (0, import_react19.useRef)(null), x5 = o2(typeof c14 == "string" ? (d17, b8) => {
    let P6 = c14;
    return (d17 == null ? void 0 : d17[P6]) === (b8 == null ? void 0 : b8[P6]);
  } : c14 != null ? c14 : (d17, b8) => d17 === b8), O5 = o2((d17) => s18 ? c14 === null ? s18.options.indexOf(d17) : s18.options.findIndex((b8) => x5(b8, d17)) : _5.options.findIndex((b8) => x5(b8.dataRef.current.value, d17))), L3 = (0, import_react19.useCallback)((d17) => u(n8.mode, { [1]: () => I12.some((b8) => x5(b8, d17)), [0]: () => x5(I12, d17) }), [I12]), oe5 = o2((d17) => _5.activeOptionIndex === O5(d17)), n8 = (0, import_react19.useMemo)(() => ({ ..._5, immediate: R5, optionsPropsRef: J7, labelRef: K5, inputRef: z5, buttonRef: te5, optionsRef: X6, value: I12, defaultValue: a11, disabled: e5, mode: g6 ? 1 : 0, virtual: _5.virtual, get activeOptionIndex() {
    if (k4.current && _5.activeOptionIndex === null && (s18 ? s18.options.length > 0 : _5.options.length > 0)) {
      if (s18) {
        let b8 = s18.options.findIndex((P6) => {
          var G5, Y4;
          return !((Y4 = (G5 = s18 == null ? void 0 : s18.disabled) == null ? void 0 : G5.call(s18, P6)) != null && Y4);
        });
        if (b8 !== -1)
          return b8;
      }
      let d17 = _5.options.findIndex((b8) => !b8.dataRef.current.disabled);
      if (d17 !== -1)
        return d17;
    }
    return _5.activeOptionIndex;
  }, calculateIndex: O5, compare: x5, isSelected: L3, isActive: oe5, nullable: T8, __demoMode: l14 }), [I12, a11, e5, g6, T8, l14, _5, s18]);
  l(() => {
    s18 && E9({ type: 7, options: s18.options });
  }, [s18, s18 == null ? void 0 : s18.options]), l(() => {
    _5.dataRef.current = n8;
  }, [n8]), y2([n8.buttonRef, n8.inputRef, n8.optionsRef], () => le3.closeCombobox(), n8.comboboxState === 0);
  let F11 = (0, import_react19.useMemo)(() => {
    var d17, b8, P6;
    return { open: n8.comboboxState === 0, disabled: e5, activeIndex: n8.activeOptionIndex, activeOption: n8.activeOptionIndex === null ? null : n8.virtual ? n8.virtual.options[(d17 = n8.activeOptionIndex) != null ? d17 : 0] : (P6 = (b8 = n8.options[n8.activeOptionIndex]) == null ? void 0 : b8.dataRef.current.value) != null ? P6 : null, value: I12 };
  }, [n8, e5, I12]), A4 = o2(() => {
    if (n8.activeOptionIndex !== null) {
      if (n8.virtual)
        ae3(n8.virtual.options[n8.activeOptionIndex]);
      else {
        let { dataRef: d17 } = n8.options[n8.activeOptionIndex];
        ae3(d17.current.value);
      }
      le3.goToOption(c3.Specific, n8.activeOptionIndex);
    }
  }), h10 = o2(() => {
    E9({ type: 0 }), k4.current = true;
  }), C8 = o2(() => {
    E9({ type: 1 }), k4.current = false;
  }), D8 = o2((d17, b8, P6) => (k4.current = false, d17 === c3.Specific ? E9({ type: 2, focus: c3.Specific, idx: b8, trigger: P6 }) : E9({ type: 2, focus: d17, trigger: P6 }))), N8 = o2((d17, b8) => (E9({ type: 3, payload: { id: d17, dataRef: b8 } }), () => {
    n8.isActive(b8.current.value) && (k4.current = true), E9({ type: 4, id: d17 });
  })), ye6 = o2((d17) => (E9({ type: 5, id: d17 }), () => E9({ type: 5, id: null }))), ae3 = o2((d17) => u(n8.mode, { [0]() {
    return V6 == null ? void 0 : V6(d17);
  }, [1]() {
    let b8 = n8.value.slice(), P6 = b8.findIndex((G5) => x5(G5, d17));
    return P6 === -1 ? b8.push(d17) : b8.splice(P6, 1), V6 == null ? void 0 : V6(b8);
  } })), Re4 = o2((d17) => {
    E9({ type: 6, trigger: d17 });
  }), le3 = (0, import_react19.useMemo)(() => ({ onChange: ae3, registerOption: N8, registerLabel: ye6, goToOption: D8, closeCombobox: C8, openCombobox: h10, setActivationTrigger: Re4, selectActiveOption: A4 }), []), Ae5 = r10 === null ? {} : { ref: r10 }, ne5 = (0, import_react19.useRef)(null), Se5 = p();
  return (0, import_react19.useEffect)(() => {
    ne5.current && a11 !== void 0 && Se5.addEventListener(ne5.current, "reset", () => {
      V6 == null || V6(a11);
    });
  }, [ne5, V6]), import_react19.default.createElement(be.Provider, { value: le3 }, import_react19.default.createElement(ce.Provider, { value: n8 }, import_react19.default.createElement(s9, { value: u(n8.comboboxState, { [0]: d5.Open, [1]: d5.Closed }) }, p8 != null && I12 != null && e({ [p8]: I12 }).map(([d17, b8], P6) => import_react19.default.createElement(u4, { features: s8.Hidden, ref: P6 === 0 ? (G5) => {
    var Y4;
    ne5.current = (Y4 = G5 == null ? void 0 : G5.closest("form")) != null ? Y4 : null;
  } : void 0, ...x({ key: d17, as: "input", type: "hidden", hidden: true, readOnly: true, form: u14, disabled: e5, name: d17, value: b8 }) })), C({ ourProps: Ae5, theirProps: S11, slot: F11, defaultTag: tt, name: "Combobox" }))));
}
var nt = "input";
function rt(t19, r10) {
  var X6, x5, O5, L3, oe5;
  let o14 = I(), { id: a11 = `headlessui-combobox-input-${o14}`, onChange: i9, displayValue: u14, type: p8 = "text", ...c14 } = t19, e5 = j2("Combobox.Input"), l14 = ee("Combobox.Input"), T8 = y3(e5.inputRef, r10), g6 = n2(e5.inputRef), f15 = (0, import_react19.useRef)(false), v7 = p(), S11 = o2(() => {
    l14.onChange(null), e5.optionsRef.current && (e5.optionsRef.current.scrollTop = 0), l14.goToOption(c3.Nothing);
  }), R5 = function() {
    var n8;
    return typeof u14 == "function" && e5.value !== void 0 ? (n8 = u14(e5.value)) != null ? n8 : "" : typeof e5.value == "string" ? e5.value : "";
  }();
  m3(([n8, F11], [A4, h10]) => {
    if (f15.current)
      return;
    let C8 = e5.inputRef.current;
    C8 && ((h10 === 0 && F11 === 1 || n8 !== A4) && (C8.value = n8), requestAnimationFrame(() => {
      if (f15.current || !C8 || (g6 == null ? void 0 : g6.activeElement) !== C8)
        return;
      let { selectionStart: D8, selectionEnd: N8 } = C8;
      Math.abs((N8 != null ? N8 : 0) - (D8 != null ? D8 : 0)) === 0 && D8 === 0 && C8.setSelectionRange(C8.value.length, C8.value.length);
    }));
  }, [R5, e5.comboboxState, g6]), m3(([n8], [F11]) => {
    if (n8 === 0 && F11 === 1) {
      if (f15.current)
        return;
      let A4 = e5.inputRef.current;
      if (!A4)
        return;
      let h10 = A4.value, { selectionStart: C8, selectionEnd: D8, selectionDirection: N8 } = A4;
      A4.value = "", A4.value = h10, N8 !== null ? A4.setSelectionRange(C8, D8, N8) : A4.setSelectionRange(C8, D8);
    }
  }, [e5.comboboxState]);
  let s18 = (0, import_react19.useRef)(false), I12 = o2(() => {
    s18.current = true;
  }), V6 = o2(() => {
    v7.nextFrame(() => {
      s18.current = false;
    });
  }), _5 = o2((n8) => {
    switch (f15.current = true, n8.key) {
      case o11.Enter:
        if (f15.current = false, e5.comboboxState !== 0 || s18.current)
          return;
        if (n8.preventDefault(), n8.stopPropagation(), e5.activeOptionIndex === null) {
          l14.closeCombobox();
          return;
        }
        l14.selectActiveOption(), e5.mode === 0 && l14.closeCombobox();
        break;
      case o11.ArrowDown:
        return f15.current = false, n8.preventDefault(), n8.stopPropagation(), u(e5.comboboxState, { [0]: () => l14.goToOption(c3.Next), [1]: () => l14.openCombobox() });
      case o11.ArrowUp:
        return f15.current = false, n8.preventDefault(), n8.stopPropagation(), u(e5.comboboxState, { [0]: () => l14.goToOption(c3.Previous), [1]: () => {
          l14.openCombobox(), v7.nextFrame(() => {
            e5.value || l14.goToOption(c3.Last);
          });
        } });
      case o11.Home:
        if (n8.shiftKey)
          break;
        return f15.current = false, n8.preventDefault(), n8.stopPropagation(), l14.goToOption(c3.First);
      case o11.PageUp:
        return f15.current = false, n8.preventDefault(), n8.stopPropagation(), l14.goToOption(c3.First);
      case o11.End:
        if (n8.shiftKey)
          break;
        return f15.current = false, n8.preventDefault(), n8.stopPropagation(), l14.goToOption(c3.Last);
      case o11.PageDown:
        return f15.current = false, n8.preventDefault(), n8.stopPropagation(), l14.goToOption(c3.Last);
      case o11.Escape:
        return f15.current = false, e5.comboboxState !== 0 ? void 0 : (n8.preventDefault(), e5.optionsRef.current && !e5.optionsPropsRef.current.static && n8.stopPropagation(), e5.nullable && e5.mode === 0 && e5.value === null && S11(), l14.closeCombobox());
      case o11.Tab:
        if (f15.current = false, e5.comboboxState !== 0)
          return;
        e5.mode === 0 && e5.activationTrigger !== 1 && l14.selectActiveOption(), l14.closeCombobox();
        break;
    }
  }), E9 = o2((n8) => {
    i9 == null || i9(n8), e5.nullable && e5.mode === 0 && n8.target.value === "" && S11(), l14.openCombobox();
  }), k4 = o2((n8) => {
    var A4, h10, C8;
    let F11 = (A4 = n8.relatedTarget) != null ? A4 : t12.find((D8) => D8 !== n8.currentTarget);
    if (f15.current = false, !((h10 = e5.optionsRef.current) != null && h10.contains(F11)) && !((C8 = e5.buttonRef.current) != null && C8.contains(F11)) && e5.comboboxState === 0)
      return n8.preventDefault(), e5.mode === 0 && (e5.nullable && e5.value === null ? S11() : e5.activationTrigger !== 1 && l14.selectActiveOption()), l14.closeCombobox();
  }), J7 = o2((n8) => {
    var A4, h10, C8;
    let F11 = (A4 = n8.relatedTarget) != null ? A4 : t12.find((D8) => D8 !== n8.currentTarget);
    (h10 = e5.buttonRef.current) != null && h10.contains(F11) || (C8 = e5.optionsRef.current) != null && C8.contains(F11) || e5.disabled || e5.immediate && e5.comboboxState !== 0 && (l14.openCombobox(), v7.nextFrame(() => {
      l14.setActivationTrigger(1);
    }));
  }), K5 = i2(() => {
    if (e5.labelId)
      return [e5.labelId].join(" ");
  }, [e5.labelId]), z5 = (0, import_react19.useMemo)(() => ({ open: e5.comboboxState === 0, disabled: e5.disabled }), [e5]), te5 = { ref: T8, id: a11, role: "combobox", type: p8, "aria-controls": (X6 = e5.optionsRef.current) == null ? void 0 : X6.id, "aria-expanded": e5.comboboxState === 0, "aria-activedescendant": e5.activeOptionIndex === null ? void 0 : e5.virtual ? (x5 = e5.options.find((n8) => {
    var F11;
    return !((F11 = e5.virtual) != null && F11.disabled(n8.dataRef.current.value)) && e5.compare(n8.dataRef.current.value, e5.virtual.options[e5.activeOptionIndex]);
  })) == null ? void 0 : x5.id : (O5 = e5.options[e5.activeOptionIndex]) == null ? void 0 : O5.id, "aria-labelledby": K5, "aria-autocomplete": "list", defaultValue: (oe5 = (L3 = t19.defaultValue) != null ? L3 : e5.defaultValue !== void 0 ? u14 == null ? void 0 : u14(e5.defaultValue) : null) != null ? oe5 : e5.defaultValue, disabled: e5.disabled, onCompositionStart: I12, onCompositionEnd: V6, onKeyDown: _5, onChange: E9, onFocus: J7, onBlur: k4 };
  return C({ ourProps: te5, theirProps: c14, slot: z5, defaultTag: nt, name: "Combobox.Input" });
}
var at = "button";
function lt(t19, r10) {
  var S11;
  let o14 = j2("Combobox.Button"), a11 = ee("Combobox.Button"), i9 = y3(o14.buttonRef, r10), u14 = I(), { id: p8 = `headlessui-combobox-button-${u14}`, ...c14 } = t19, e5 = p(), l14 = o2((R5) => {
    switch (R5.key) {
      case o11.ArrowDown:
        return R5.preventDefault(), R5.stopPropagation(), o14.comboboxState === 1 && a11.openCombobox(), e5.nextFrame(() => {
          var s18;
          return (s18 = o14.inputRef.current) == null ? void 0 : s18.focus({ preventScroll: true });
        });
      case o11.ArrowUp:
        return R5.preventDefault(), R5.stopPropagation(), o14.comboboxState === 1 && (a11.openCombobox(), e5.nextFrame(() => {
          o14.value || a11.goToOption(c3.Last);
        })), e5.nextFrame(() => {
          var s18;
          return (s18 = o14.inputRef.current) == null ? void 0 : s18.focus({ preventScroll: true });
        });
      case o11.Escape:
        return o14.comboboxState !== 0 ? void 0 : (R5.preventDefault(), o14.optionsRef.current && !o14.optionsPropsRef.current.static && R5.stopPropagation(), a11.closeCombobox(), e5.nextFrame(() => {
          var s18;
          return (s18 = o14.inputRef.current) == null ? void 0 : s18.focus({ preventScroll: true });
        }));
      default:
        return;
    }
  }), T8 = o2((R5) => {
    if (r2(R5.currentTarget))
      return R5.preventDefault();
    o14.comboboxState === 0 ? a11.closeCombobox() : (R5.preventDefault(), a11.openCombobox()), e5.nextFrame(() => {
      var s18;
      return (s18 = o14.inputRef.current) == null ? void 0 : s18.focus({ preventScroll: true });
    });
  }), g6 = i2(() => {
    if (o14.labelId)
      return [o14.labelId, p8].join(" ");
  }, [o14.labelId, p8]), f15 = (0, import_react19.useMemo)(() => ({ open: o14.comboboxState === 0, disabled: o14.disabled, value: o14.value }), [o14]), v7 = { ref: i9, id: p8, type: T3(t19, o14.buttonRef), tabIndex: -1, "aria-haspopup": "listbox", "aria-controls": (S11 = o14.optionsRef.current) == null ? void 0 : S11.id, "aria-expanded": o14.comboboxState === 0, "aria-labelledby": g6, disabled: o14.disabled, onClick: T8, onKeyDown: l14 };
  return C({ ourProps: v7, theirProps: c14, slot: f15, defaultTag: at, name: "Combobox.Button" });
}
var it = "label";
function ut(t19, r10) {
  let o14 = I(), { id: a11 = `headlessui-combobox-label-${o14}`, ...i9 } = t19, u14 = j2("Combobox.Label"), p8 = ee("Combobox.Label"), c14 = y3(u14.labelRef, r10);
  l(() => p8.registerLabel(a11), [a11]);
  let e5 = o2(() => {
    var g6;
    return (g6 = u14.inputRef.current) == null ? void 0 : g6.focus({ preventScroll: true });
  }), l14 = (0, import_react19.useMemo)(() => ({ open: u14.comboboxState === 0, disabled: u14.disabled }), [u14]);
  return C({ ourProps: { ref: c14, id: a11, onClick: e5 }, theirProps: i9, slot: l14, defaultTag: it, name: "Combobox.Label" });
}
var pt = "ul";
var st = O2.RenderStrategy | O2.Static;
function dt(t19, r10) {
  let o14 = I(), { id: a11 = `headlessui-combobox-options-${o14}`, hold: i9 = false, ...u14 } = t19, p8 = j2("Combobox.Options"), c14 = y3(p8.optionsRef, r10), e5 = u5(), l14 = (() => e5 !== null ? (e5 & d5.Open) === d5.Open : p8.comboboxState === 0)();
  l(() => {
    var v7;
    p8.optionsPropsRef.current.static = (v7 = t19.static) != null ? v7 : false;
  }, [p8.optionsPropsRef, t19.static]), l(() => {
    p8.optionsPropsRef.current.hold = i9;
  }, [p8.optionsPropsRef, i9]), F2({ container: p8.optionsRef.current, enabled: p8.comboboxState === 0, accept(v7) {
    return v7.getAttribute("role") === "option" ? NodeFilter.FILTER_REJECT : v7.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(v7) {
    v7.setAttribute("role", "none");
  } });
  let T8 = i2(() => {
    var v7, S11;
    return (S11 = p8.labelId) != null ? S11 : (v7 = p8.buttonRef.current) == null ? void 0 : v7.id;
  }, [p8.labelId, p8.buttonRef.current]), g6 = (0, import_react19.useMemo)(() => ({ open: p8.comboboxState === 0, option: void 0 }), [p8]), f15 = { "aria-labelledby": T8, role: "listbox", "aria-multiselectable": p8.mode === 1 ? true : void 0, id: a11, ref: c14 };
  return p8.virtual && p8.comboboxState === 0 && Object.assign(u14, { children: import_react19.default.createElement(Ze, null, u14.children) }), C({ ourProps: f15, theirProps: u14, slot: g6, defaultTag: pt, features: st, visible: l14, name: "Combobox.Options" });
}
var bt = "li";
function ct(t19, r10) {
  var X6;
  let o14 = I(), { id: a11 = `headlessui-combobox-option-${o14}`, disabled: i9 = false, value: u14, order: p8 = null, ...c14 } = t19, e5 = j2("Combobox.Option"), l14 = ee("Combobox.Option"), T8 = e5.virtual ? e5.activeOptionIndex === e5.calculateIndex(u14) : e5.activeOptionIndex === null ? false : ((X6 = e5.options[e5.activeOptionIndex]) == null ? void 0 : X6.id) === a11, g6 = e5.isSelected(u14), f15 = (0, import_react19.useRef)(null), v7 = s2({ disabled: i9, value: u14, domRef: f15, order: p8 }), S11 = (0, import_react19.useContext)(Ce), R5 = y3(r10, f15, S11 ? S11.measureElement : null), s18 = o2(() => l14.onChange(u14));
  l(() => l14.registerOption(a11, v7), [v7, a11]);
  let I12 = (0, import_react19.useRef)(!(e5.virtual || e5.__demoMode));
  l(() => {
    if (!e5.virtual || !e5.__demoMode)
      return;
    let x5 = o4();
    return x5.requestAnimationFrame(() => {
      I12.current = true;
    }), x5.dispose;
  }, [e5.virtual, e5.__demoMode]), l(() => {
    if (!I12.current || e5.comboboxState !== 0 || !T8 || e5.activationTrigger === 0)
      return;
    let x5 = o4();
    return x5.requestAnimationFrame(() => {
      var O5, L3;
      (L3 = (O5 = f15.current) == null ? void 0 : O5.scrollIntoView) == null || L3.call(O5, { block: "nearest" });
    }), x5.dispose;
  }, [f15, T8, e5.comboboxState, e5.activationTrigger, e5.activeOptionIndex]);
  let V6 = o2((x5) => {
    var O5;
    if (i9 || (O5 = e5.virtual) != null && O5.disabled(u14))
      return x5.preventDefault();
    s18(), n() || requestAnimationFrame(() => {
      var L3;
      return (L3 = e5.inputRef.current) == null ? void 0 : L3.focus({ preventScroll: true });
    }), e5.mode === 0 && requestAnimationFrame(() => l14.closeCombobox());
  }), _5 = o2(() => {
    var O5;
    if (i9 || (O5 = e5.virtual) != null && O5.disabled(u14))
      return l14.goToOption(c3.Nothing);
    let x5 = e5.calculateIndex(u14);
    l14.goToOption(c3.Specific, x5);
  }), E9 = u3(), k4 = o2((x5) => E9.update(x5)), J7 = o2((x5) => {
    var L3;
    if (!E9.wasMoved(x5) || i9 || (L3 = e5.virtual) != null && L3.disabled(u14) || T8)
      return;
    let O5 = e5.calculateIndex(u14);
    l14.goToOption(c3.Specific, O5, 0);
  }), K5 = o2((x5) => {
    var O5;
    E9.wasMoved(x5) && (i9 || (O5 = e5.virtual) != null && O5.disabled(u14) || T8 && (e5.optionsPropsRef.current.hold || l14.goToOption(c3.Nothing)));
  }), z5 = (0, import_react19.useMemo)(() => ({ active: T8, selected: g6, disabled: i9 }), [T8, g6, i9]);
  return C({ ourProps: { id: a11, ref: R5, role: "option", tabIndex: i9 === true ? void 0 : -1, "aria-disabled": i9 === true ? true : void 0, "aria-selected": g6, disabled: void 0, onClick: V6, onFocus: _5, onPointerEnter: k4, onMouseEnter: k4, onPointerMove: J7, onMouseMove: J7, onPointerLeave: K5, onMouseLeave: K5 }, theirProps: c14, slot: z5, defaultTag: bt, name: "Combobox.Option" });
}
var ft = U(ot);
var mt = U(lt);
var Tt = U(rt);
var xt = U(ut);
var gt = U(dt);
var vt = U(ct);
var qt = Object.assign(ft, { Input: Tt, Button: mt, Label: xt, Options: gt, Option: vt });

// node_modules/@headlessui/react/dist/components/dialog/dialog.js
var import_react30 = __toESM(require_react(), 1);

// node_modules/@headlessui/react/dist/components/focus-trap/focus-trap.js
var import_react24 = __toESM(require_react(), 1);

// node_modules/@headlessui/react/dist/hooks/use-event-listener.js
var import_react20 = __toESM(require_react(), 1);
function E3(n8, e5, a11, t19) {
  let i9 = s2(a11);
  (0, import_react20.useEffect)(() => {
    n8 = n8 != null ? n8 : window;
    function r10(o14) {
      i9.current(o14);
    }
    return n8.addEventListener(e5, r10, t19), () => n8.removeEventListener(e5, r10, t19);
  }, [n8, e5, t19]);
}

// node_modules/@headlessui/react/dist/hooks/use-is-mounted.js
var import_react21 = __toESM(require_react(), 1);
function f7() {
  let e5 = (0, import_react21.useRef)(false);
  return l(() => (e5.current = true, () => {
    e5.current = false;
  }), []), e5;
}

// node_modules/@headlessui/react/dist/hooks/use-on-unmount.js
var import_react22 = __toESM(require_react(), 1);
function c4(t19) {
  let r10 = o2(t19), e5 = (0, import_react22.useRef)(false);
  (0, import_react22.useEffect)(() => (e5.current = false, () => {
    e5.current = true, t3(() => {
      e5.current && r10();
    });
  }), [r10]);
}

// node_modules/@headlessui/react/dist/hooks/use-tab-direction.js
var import_react23 = __toESM(require_react(), 1);
var s10 = ((r10) => (r10[r10.Forwards = 0] = "Forwards", r10[r10.Backwards = 1] = "Backwards", r10))(s10 || {});
function n5() {
  let e5 = (0, import_react23.useRef)(0);
  return s6("keydown", (o14) => {
    o14.key === "Tab" && (e5.current = o14.shiftKey ? 1 : 0);
  }, true), e5;
}

// node_modules/@headlessui/react/dist/components/focus-trap/focus-trap.js
function P2(t19) {
  if (!t19)
    return /* @__PURE__ */ new Set();
  if (typeof t19 == "function")
    return new Set(t19());
  let n8 = /* @__PURE__ */ new Set();
  for (let e5 of t19.current)
    e5.current instanceof HTMLElement && n8.add(e5.current);
  return n8;
}
var X = "div";
var _2 = ((r10) => (r10[r10.None = 1] = "None", r10[r10.InitialFocus = 2] = "InitialFocus", r10[r10.TabLock = 4] = "TabLock", r10[r10.FocusLock = 8] = "FocusLock", r10[r10.RestoreFocus = 16] = "RestoreFocus", r10[r10.All = 30] = "All", r10))(_2 || {});
function z(t19, n8) {
  let e5 = (0, import_react24.useRef)(null), o14 = y3(e5, n8), { initialFocus: l14, containers: c14, features: r10 = 30, ...s18 } = t19;
  l2() || (r10 = 1);
  let i9 = n2(e5);
  Y({ ownerDocument: i9 }, Boolean(r10 & 16));
  let u14 = Z({ ownerDocument: i9, container: e5, initialFocus: l14 }, Boolean(r10 & 2));
  $({ ownerDocument: i9, container: e5, containers: c14, previousActiveElement: u14 }, Boolean(r10 & 8));
  let y8 = n5(), R5 = o2((a11) => {
    let m13 = e5.current;
    if (!m13)
      return;
    ((B5) => B5())(() => {
      u(y8.current, { [s10.Forwards]: () => {
        O(m13, M.First, { skipElements: [a11.relatedTarget] });
      }, [s10.Backwards]: () => {
        O(m13, M.Last, { skipElements: [a11.relatedTarget] });
      } });
    });
  }), h10 = p(), H7 = (0, import_react24.useRef)(false), j6 = { ref: o14, onKeyDown(a11) {
    a11.key == "Tab" && (H7.current = true, h10.requestAnimationFrame(() => {
      H7.current = false;
    }));
  }, onBlur(a11) {
    let m13 = P2(c14);
    e5.current instanceof HTMLElement && m13.add(e5.current);
    let T8 = a11.relatedTarget;
    T8 instanceof HTMLElement && T8.dataset.headlessuiFocusGuard !== "true" && (S3(m13, T8) || (H7.current ? O(e5.current, u(y8.current, { [s10.Forwards]: () => M.Next, [s10.Backwards]: () => M.Previous }) | M.WrapAround, { relativeTo: a11.target }) : a11.target instanceof HTMLElement && y(a11.target)));
  } };
  return import_react24.default.createElement(import_react24.default.Fragment, null, Boolean(r10 & 4) && import_react24.default.createElement(u4, { as: "button", type: "button", "data-headlessui-focus-guard": true, onFocus: R5, features: s8.Focusable }), C({ ourProps: j6, theirProps: s18, defaultTag: X, name: "FocusTrap" }), Boolean(r10 & 4) && import_react24.default.createElement(u4, { as: "button", type: "button", "data-headlessui-focus-guard": true, onFocus: R5, features: s8.Focusable }));
}
var D2 = U(z);
var de2 = Object.assign(D2, { features: _2 });
function Q(t19 = true) {
  let n8 = (0, import_react24.useRef)(t12.slice());
  return m3(([e5], [o14]) => {
    o14 === true && e5 === false && t3(() => {
      n8.current.splice(0);
    }), o14 === false && e5 === true && (n8.current = t12.slice());
  }, [t19, t12, n8]), o2(() => {
    var e5;
    return (e5 = n8.current.find((o14) => o14 != null && o14.isConnected)) != null ? e5 : null;
  });
}
function Y({ ownerDocument: t19 }, n8) {
  let e5 = Q(n8);
  m3(() => {
    n8 || (t19 == null ? void 0 : t19.activeElement) === (t19 == null ? void 0 : t19.body) && y(e5());
  }, [n8]), c4(() => {
    n8 && y(e5());
  });
}
function Z({ ownerDocument: t19, container: n8, initialFocus: e5 }, o14) {
  let l14 = (0, import_react24.useRef)(null), c14 = f7();
  return m3(() => {
    if (!o14)
      return;
    let r10 = n8.current;
    r10 && t3(() => {
      if (!c14.current)
        return;
      let s18 = t19 == null ? void 0 : t19.activeElement;
      if (e5 != null && e5.current) {
        if ((e5 == null ? void 0 : e5.current) === s18) {
          l14.current = s18;
          return;
        }
      } else if (r10.contains(s18)) {
        l14.current = s18;
        return;
      }
      e5 != null && e5.current ? y(e5.current) : O(r10, M.First) === N.Error && console.warn("There are no focusable elements inside the <FocusTrap />"), l14.current = t19 == null ? void 0 : t19.activeElement;
    });
  }, [o14]), l14;
}
function $({ ownerDocument: t19, container: n8, containers: e5, previousActiveElement: o14 }, l14) {
  let c14 = f7();
  E3(t19 == null ? void 0 : t19.defaultView, "focus", (r10) => {
    if (!l14 || !c14.current)
      return;
    let s18 = P2(e5);
    n8.current instanceof HTMLElement && s18.add(n8.current);
    let i9 = o14.current;
    if (!i9)
      return;
    let u14 = r10.target;
    u14 && u14 instanceof HTMLElement ? S3(s18, u14) ? (o14.current = u14, y(u14)) : (r10.preventDefault(), r10.stopPropagation(), y(i9)) : y(o14.current);
  }, true);
}
function S3(t19, n8) {
  for (let e5 of t19)
    if (e5.contains(n8))
      return true;
  return false;
}

// node_modules/@headlessui/react/dist/components/portal/portal.js
var import_react26 = __toESM(require_react(), 1);
var import_react_dom2 = __toESM(require_react_dom(), 1);

// node_modules/@headlessui/react/dist/internal/portal-force-root.js
var import_react25 = __toESM(require_react(), 1);
var e2 = (0, import_react25.createContext)(false);
function a2() {
  return (0, import_react25.useContext)(e2);
}
function l6(o14) {
  return import_react25.default.createElement(e2.Provider, { value: o14.force }, o14.children);
}

// node_modules/@headlessui/react/dist/components/portal/portal.js
function F4(p8) {
  let n8 = a2(), l14 = (0, import_react26.useContext)(_3), e5 = n2(p8), [a11, o14] = (0, import_react26.useState)(() => {
    if (!n8 && l14 !== null || s.isServer)
      return null;
    let t19 = e5 == null ? void 0 : e5.getElementById("headlessui-portal-root");
    if (t19)
      return t19;
    if (e5 === null)
      return null;
    let r10 = e5.createElement("div");
    return r10.setAttribute("id", "headlessui-portal-root"), e5.body.appendChild(r10);
  });
  return (0, import_react26.useEffect)(() => {
    a11 !== null && (e5 != null && e5.body.contains(a11) || e5 == null || e5.body.appendChild(a11));
  }, [a11, e5]), (0, import_react26.useEffect)(() => {
    n8 || l14 !== null && o14(l14.current);
  }, [l14, o14, n8]), a11;
}
var U3 = import_react26.Fragment;
function N3(p8, n8) {
  let l14 = p8, e5 = (0, import_react26.useRef)(null), a11 = y3(T4((u14) => {
    e5.current = u14;
  }), n8), o14 = n2(e5), t19 = F4(e5), [r10] = (0, import_react26.useState)(() => {
    var u14;
    return s.isServer ? null : (u14 = o14 == null ? void 0 : o14.createElement("div")) != null ? u14 : null;
  }), i9 = (0, import_react26.useContext)(f8), v7 = l2();
  return l(() => {
    !t19 || !r10 || t19.contains(r10) || (r10.setAttribute("data-headlessui-portal", ""), t19.appendChild(r10));
  }, [t19, r10]), l(() => {
    if (r10 && i9)
      return i9.register(r10);
  }, [i9, r10]), c4(() => {
    var u14;
    !t19 || !r10 || (r10 instanceof Node && t19.contains(r10) && t19.removeChild(r10), t19.childNodes.length <= 0 && ((u14 = t19.parentElement) == null || u14.removeChild(t19)));
  }), v7 ? !t19 || !r10 ? null : (0, import_react_dom2.createPortal)(C({ ourProps: { ref: a11 }, theirProps: l14, defaultTag: U3, name: "Portal" }), r10) : null;
}
var S4 = import_react26.Fragment;
var _3 = (0, import_react26.createContext)(null);
function j3(p8, n8) {
  let { target: l14, ...e5 } = p8, o14 = { ref: y3(n8) };
  return import_react26.default.createElement(_3.Provider, { value: l14 }, C({ ourProps: o14, theirProps: e5, defaultTag: S4, name: "Popover.Group" }));
}
var f8 = (0, import_react26.createContext)(null);
function ee2() {
  let p8 = (0, import_react26.useContext)(f8), n8 = (0, import_react26.useRef)([]), l14 = o2((o14) => (n8.current.push(o14), p8 && p8.register(o14), () => e5(o14))), e5 = o2((o14) => {
    let t19 = n8.current.indexOf(o14);
    t19 !== -1 && n8.current.splice(t19, 1), p8 && p8.unregister(o14);
  }), a11 = (0, import_react26.useMemo)(() => ({ register: l14, unregister: e5, portals: n8 }), [l14, e5, n8]);
  return [n8, (0, import_react26.useMemo)(() => function({ children: t19 }) {
    return import_react26.default.createElement(f8.Provider, { value: a11 }, t19);
  }, [a11])];
}
var D3 = U(N3);
var I4 = U(j3);
var te = Object.assign(D3, { Group: I4 });

// node_modules/@headlessui/react/dist/use-sync-external-store-shim/index.js
var e3 = __toESM(require_react(), 1);

// node_modules/@headlessui/react/dist/use-sync-external-store-shim/useSyncExternalStoreShimClient.js
var l7 = __toESM(require_react(), 1);
function i7(e5, t19) {
  return e5 === t19 && (e5 !== 0 || 1 / e5 === 1 / t19) || e5 !== e5 && t19 !== t19;
}
var d9 = typeof Object.is == "function" ? Object.is : i7;
var { useState: u8, useEffect: h3, useLayoutEffect: f9, useDebugValue: p5 } = l7;
function y4(e5, t19, c14) {
  const a11 = t19(), [{ inst: n8 }, o14] = u8({ inst: { value: a11, getSnapshot: t19 } });
  return f9(() => {
    n8.value = a11, n8.getSnapshot = t19, r5(n8) && o14({ inst: n8 });
  }, [e5, a11, t19]), h3(() => (r5(n8) && o14({ inst: n8 }), e5(() => {
    r5(n8) && o14({ inst: n8 });
  })), [e5]), p5(a11), a11;
}
function r5(e5) {
  const t19 = e5.getSnapshot, c14 = e5.value;
  try {
    const a11 = t19();
    return !d9(c14, a11);
  } catch {
    return true;
  }
}

// node_modules/@headlessui/react/dist/use-sync-external-store-shim/useSyncExternalStoreShimServer.js
function t15(r10, e5, n8) {
  return e5();
}

// node_modules/@headlessui/react/dist/use-sync-external-store-shim/index.js
var r6 = typeof window != "undefined" && typeof window.document != "undefined" && typeof window.document.createElement != "undefined";
var s12 = !r6;
var c6 = s12 ? t15 : y4;
var a3 = "useSyncExternalStore" in e3 ? ((n8) => n8.useSyncExternalStore)(e3) : c6;

// node_modules/@headlessui/react/dist/hooks/use-store.js
function S5(t19) {
  return a3(t19.subscribe, t19.getSnapshot, t19.getSnapshot);
}

// node_modules/@headlessui/react/dist/utils/store.js
function a4(o14, r10) {
  let t19 = o14(), n8 = /* @__PURE__ */ new Set();
  return { getSnapshot() {
    return t19;
  }, subscribe(e5) {
    return n8.add(e5), () => n8.delete(e5);
  }, dispatch(e5, ...s18) {
    let i9 = r10[e5].call(t19, ...s18);
    i9 && (t19 = i9, n8.forEach((c14) => c14()));
  } };
}

// node_modules/@headlessui/react/dist/hooks/document-overflow/adjust-scrollbar-padding.js
function c7() {
  let o14;
  return { before({ doc: e5 }) {
    var l14;
    let n8 = e5.documentElement;
    o14 = ((l14 = e5.defaultView) != null ? l14 : window).innerWidth - n8.clientWidth;
  }, after({ doc: e5, d: n8 }) {
    let t19 = e5.documentElement, l14 = t19.clientWidth - t19.offsetWidth, r10 = o14 - l14;
    n8.style(t19, "paddingRight", `${r10}px`);
  } };
}

// node_modules/@headlessui/react/dist/hooks/document-overflow/handle-ios-locking.js
function d10() {
  return t6() ? { before({ doc: r10, d: l14, meta: c14 }) {
    function o14(a11) {
      return c14.containers.flatMap((n8) => n8()).some((n8) => n8.contains(a11));
    }
    l14.microTask(() => {
      var s18;
      if (window.getComputedStyle(r10.documentElement).scrollBehavior !== "auto") {
        let t19 = o4();
        t19.style(r10.documentElement, "scrollBehavior", "auto"), l14.add(() => l14.microTask(() => t19.dispose()));
      }
      let a11 = (s18 = window.scrollY) != null ? s18 : window.pageYOffset, n8 = null;
      l14.addEventListener(r10, "click", (t19) => {
        if (t19.target instanceof HTMLElement)
          try {
            let e5 = t19.target.closest("a");
            if (!e5)
              return;
            let { hash: f15 } = new URL(e5.href), i9 = r10.querySelector(f15);
            i9 && !o14(i9) && (n8 = i9);
          } catch {
          }
      }, true), l14.addEventListener(r10, "touchstart", (t19) => {
        if (t19.target instanceof HTMLElement)
          if (o14(t19.target)) {
            let e5 = t19.target;
            for (; e5.parentElement && o14(e5.parentElement); )
              e5 = e5.parentElement;
            l14.style(e5, "overscrollBehavior", "contain");
          } else
            l14.style(t19.target, "touchAction", "none");
      }), l14.addEventListener(r10, "touchmove", (t19) => {
        if (t19.target instanceof HTMLElement)
          if (o14(t19.target)) {
            let e5 = t19.target;
            for (; e5.parentElement && e5.dataset.headlessuiPortal !== "" && !(e5.scrollHeight > e5.clientHeight || e5.scrollWidth > e5.clientWidth); )
              e5 = e5.parentElement;
            e5.dataset.headlessuiPortal === "" && t19.preventDefault();
          } else
            t19.preventDefault();
      }, { passive: false }), l14.add(() => {
        var e5;
        let t19 = (e5 = window.scrollY) != null ? e5 : window.pageYOffset;
        a11 !== t19 && window.scrollTo(0, a11), n8 && n8.isConnected && (n8.scrollIntoView({ block: "nearest" }), n8 = null);
      });
    });
  } } : {};
}

// node_modules/@headlessui/react/dist/hooks/document-overflow/prevent-scroll.js
function l8() {
  return { before({ doc: e5, d: o14 }) {
    o14.style(e5.documentElement, "overflow", "hidden");
  } };
}

// node_modules/@headlessui/react/dist/hooks/document-overflow/overflow-store.js
function m6(e5) {
  let n8 = {};
  for (let t19 of e5)
    Object.assign(n8, t19(n8));
  return n8;
}
var a5 = a4(() => /* @__PURE__ */ new Map(), { PUSH(e5, n8) {
  var o14;
  let t19 = (o14 = this.get(e5)) != null ? o14 : { doc: e5, count: 0, d: o4(), meta: /* @__PURE__ */ new Set() };
  return t19.count++, t19.meta.add(n8), this.set(e5, t19), this;
}, POP(e5, n8) {
  let t19 = this.get(e5);
  return t19 && (t19.count--, t19.meta.delete(n8)), this;
}, SCROLL_PREVENT({ doc: e5, d: n8, meta: t19 }) {
  let o14 = { doc: e5, d: n8, meta: m6(t19) }, c14 = [d10(), c7(), l8()];
  c14.forEach(({ before: r10 }) => r10 == null ? void 0 : r10(o14)), c14.forEach(({ after: r10 }) => r10 == null ? void 0 : r10(o14));
}, SCROLL_ALLOW({ d: e5 }) {
  e5.dispose();
}, TEARDOWN({ doc: e5 }) {
  this.delete(e5);
} });
a5.subscribe(() => {
  let e5 = a5.getSnapshot(), n8 = /* @__PURE__ */ new Map();
  for (let [t19] of e5)
    n8.set(t19, t19.documentElement.style.overflow);
  for (let t19 of e5.values()) {
    let o14 = n8.get(t19.doc) === "hidden", c14 = t19.count !== 0;
    (c14 && !o14 || !c14 && o14) && a5.dispatch(t19.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", t19), t19.count === 0 && a5.dispatch("TEARDOWN", t19);
  }
});

// node_modules/@headlessui/react/dist/hooks/document-overflow/use-document-overflow.js
function p6(e5, r10, n8) {
  let f15 = S5(a5), o14 = e5 ? f15.get(e5) : void 0, i9 = o14 ? o14.count > 0 : false;
  return l(() => {
    if (!(!e5 || !r10))
      return a5.dispatch("PUSH", e5, n8), () => a5.dispatch("POP", e5, n8);
  }, [r10, e5]), i9;
}

// node_modules/@headlessui/react/dist/hooks/use-inert.js
var u9 = /* @__PURE__ */ new Map();
var t16 = /* @__PURE__ */ new Map();
function b(r10, l14 = true) {
  l(() => {
    var o14;
    if (!l14)
      return;
    let e5 = typeof r10 == "function" ? r10() : r10.current;
    if (!e5)
      return;
    function a11() {
      var d17;
      if (!e5)
        return;
      let i9 = (d17 = t16.get(e5)) != null ? d17 : 1;
      if (i9 === 1 ? t16.delete(e5) : t16.set(e5, i9 - 1), i9 !== 1)
        return;
      let n8 = u9.get(e5);
      n8 && (n8["aria-hidden"] === null ? e5.removeAttribute("aria-hidden") : e5.setAttribute("aria-hidden", n8["aria-hidden"]), e5.inert = n8.inert, u9.delete(e5));
    }
    let f15 = (o14 = t16.get(e5)) != null ? o14 : 0;
    return t16.set(e5, f15 + 1), f15 !== 0 || (u9.set(e5, { "aria-hidden": e5.getAttribute("aria-hidden"), inert: e5.inert }), e5.setAttribute("aria-hidden", "true"), e5.inert = true), a11;
  }, [r10, l14]);
}

// node_modules/@headlessui/react/dist/hooks/use-root-containers.js
var import_react27 = __toESM(require_react(), 1);
function N4({ defaultContainers: o14 = [], portals: r10, mainTreeNodeRef: u14 } = {}) {
  var f15;
  let t19 = (0, import_react27.useRef)((f15 = u14 == null ? void 0 : u14.current) != null ? f15 : null), l14 = n2(t19), c14 = o2(() => {
    var i9, s18, a11;
    let n8 = [];
    for (let e5 of o14)
      e5 !== null && (e5 instanceof HTMLElement ? n8.push(e5) : "current" in e5 && e5.current instanceof HTMLElement && n8.push(e5.current));
    if (r10 != null && r10.current)
      for (let e5 of r10.current)
        n8.push(e5);
    for (let e5 of (i9 = l14 == null ? void 0 : l14.querySelectorAll("html > *, body > *")) != null ? i9 : [])
      e5 !== document.body && e5 !== document.head && e5 instanceof HTMLElement && e5.id !== "headlessui-portal-root" && (e5.contains(t19.current) || e5.contains((a11 = (s18 = t19.current) == null ? void 0 : s18.getRootNode()) == null ? void 0 : a11.host) || n8.some((L3) => e5.contains(L3)) || n8.push(e5));
    return n8;
  });
  return { resolveContainers: c14, contains: o2((n8) => c14().some((i9) => i9.contains(n8))), mainTreeNodeRef: t19, MainTreeNode: (0, import_react27.useMemo)(() => function() {
    return u14 != null ? null : import_react27.default.createElement(u4, { features: s8.Hidden, ref: t19 });
  }, [t19, u14]) };
}
function y5() {
  let o14 = (0, import_react27.useRef)(null);
  return { mainTreeNodeRef: o14, MainTreeNode: (0, import_react27.useMemo)(() => function() {
    return import_react27.default.createElement(u4, { features: s8.Hidden, ref: o14 });
  }, [o14]) };
}

// node_modules/@headlessui/react/dist/internal/stack-context.js
var import_react28 = __toESM(require_react(), 1);
var a6 = (0, import_react28.createContext)(() => {
});
a6.displayName = "StackContext";
var s13 = ((e5) => (e5[e5.Add = 0] = "Add", e5[e5.Remove = 1] = "Remove", e5))(s13 || {});
function x2() {
  return (0, import_react28.useContext)(a6);
}
function b2({ children: i9, onUpdate: r10, type: e5, element: n8, enabled: u14 }) {
  let l14 = x2(), o14 = o2((...t19) => {
    r10 == null || r10(...t19), l14(...t19);
  });
  return l(() => {
    let t19 = u14 === void 0 || u14 === true;
    return t19 && o14(0, e5, n8), () => {
      t19 && o14(1, e5, n8);
    };
  }, [o14, e5, n8, u14]), import_react28.default.createElement(a6.Provider, { value: o14 }, i9);
}

// node_modules/@headlessui/react/dist/components/description/description.js
var import_react29 = __toESM(require_react(), 1);
var d13 = (0, import_react29.createContext)(null);
function f10() {
  let r10 = (0, import_react29.useContext)(d13);
  if (r10 === null) {
    let t19 = new Error("You used a <Description /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(t19, f10), t19;
  }
  return r10;
}
function w3() {
  let [r10, t19] = (0, import_react29.useState)([]);
  return [r10.length > 0 ? r10.join(" ") : void 0, (0, import_react29.useMemo)(() => function(e5) {
    let i9 = o2((s18) => (t19((o14) => [...o14, s18]), () => t19((o14) => {
      let p8 = o14.slice(), c14 = p8.indexOf(s18);
      return c14 !== -1 && p8.splice(c14, 1), p8;
    }))), n8 = (0, import_react29.useMemo)(() => ({ register: i9, slot: e5.slot, name: e5.name, props: e5.props }), [i9, e5.slot, e5.name, e5.props]);
    return import_react29.default.createElement(d13.Provider, { value: n8 }, e5.children);
  }, [t19])];
}
var I5 = "p";
function S6(r10, t19) {
  let a11 = I(), { id: e5 = `headlessui-description-${a11}`, ...i9 } = r10, n8 = f10(), s18 = y3(t19);
  l(() => n8.register(e5), [e5, n8.register]);
  let o14 = { ref: s18, ...n8.props, id: e5 };
  return C({ ourProps: o14, theirProps: i9, slot: n8.slot || {}, defaultTag: I5, name: n8.name || "Description" });
}
var h4 = U(S6);
var G = Object.assign(h4, {});

// node_modules/@headlessui/react/dist/components/dialog/dialog.js
var Me = ((r10) => (r10[r10.Open = 0] = "Open", r10[r10.Closed = 1] = "Closed", r10))(Me || {});
var we = ((e5) => (e5[e5.SetTitleId = 0] = "SetTitleId", e5))(we || {});
var He = { [0](o14, e5) {
  return o14.titleId === e5.id ? o14 : { ...o14, titleId: e5.id };
} };
var I6 = (0, import_react30.createContext)(null);
I6.displayName = "DialogContext";
function b3(o14) {
  let e5 = (0, import_react30.useContext)(I6);
  if (e5 === null) {
    let r10 = new Error(`<${o14} /> is missing a parent <Dialog /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r10, b3), r10;
  }
  return e5;
}
function Be(o14, e5, r10 = () => [document.body]) {
  p6(o14, e5, (i9) => {
    var n8;
    return { containers: [...(n8 = i9.containers) != null ? n8 : [], r10] };
  });
}
function Ge(o14, e5) {
  return u(e5.type, He, o14, e5);
}
var Ne = "div";
var Ue = O2.RenderStrategy | O2.Static;
function We(o14, e5) {
  let r10 = I(), { id: i9 = `headlessui-dialog-${r10}`, open: n8, onClose: l14, initialFocus: s18, role: a11 = "dialog", __demoMode: T8 = false, ...m13 } = o14, [M8, f15] = (0, import_react30.useState)(0), U8 = (0, import_react30.useRef)(false);
  a11 = function() {
    return a11 === "dialog" || a11 === "alertdialog" ? a11 : (U8.current || (U8.current = true, console.warn(`Invalid role [${a11}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`)), "dialog");
  }();
  let E9 = u5();
  n8 === void 0 && E9 !== null && (n8 = (E9 & d5.Open) === d5.Open);
  let D8 = (0, import_react30.useRef)(null), ee8 = y3(D8, e5), g6 = n2(D8), W2 = o14.hasOwnProperty("open") || E9 !== null, $7 = o14.hasOwnProperty("onClose");
  if (!W2 && !$7)
    throw new Error("You have to provide an `open` and an `onClose` prop to the `Dialog` component.");
  if (!W2)
    throw new Error("You provided an `onClose` prop to the `Dialog`, but forgot an `open` prop.");
  if (!$7)
    throw new Error("You provided an `open` prop to the `Dialog`, but forgot an `onClose` prop.");
  if (typeof n8 != "boolean")
    throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${n8}`);
  if (typeof l14 != "function")
    throw new Error(`You provided an \`onClose\` prop to the \`Dialog\`, but the value is not a function. Received: ${l14}`);
  let p8 = n8 ? 0 : 1, [h10, te5] = (0, import_react30.useReducer)(Ge, { titleId: null, descriptionId: null, panelRef: (0, import_react30.createRef)() }), P6 = o2(() => l14(false)), Y4 = o2((t19) => te5({ type: 0, id: t19 })), S11 = l2() ? T8 ? false : p8 === 0 : false, x5 = M8 > 1, j6 = (0, import_react30.useContext)(I6) !== null, [oe5, re6] = ee2(), ne5 = { get current() {
    var t19;
    return (t19 = h10.panelRef.current) != null ? t19 : D8.current;
  } }, { resolveContainers: w7, mainTreeNodeRef: L3, MainTreeNode: le3 } = N4({ portals: oe5, defaultContainers: [ne5] }), ae3 = x5 ? "parent" : "leaf", J7 = E9 !== null ? (E9 & d5.Closing) === d5.Closing : false, ie5 = (() => j6 || J7 ? false : S11)(), se4 = (0, import_react30.useCallback)(() => {
    var t19, c14;
    return (c14 = Array.from((t19 = g6 == null ? void 0 : g6.querySelectorAll("body > *")) != null ? t19 : []).find((d17) => d17.id === "headlessui-portal-root" ? false : d17.contains(L3.current) && d17 instanceof HTMLElement)) != null ? c14 : null;
  }, [L3]);
  b(se4, ie5);
  let pe2 = (() => x5 ? true : S11)(), de6 = (0, import_react30.useCallback)(() => {
    var t19, c14;
    return (c14 = Array.from((t19 = g6 == null ? void 0 : g6.querySelectorAll("[data-headlessui-portal]")) != null ? t19 : []).find((d17) => d17.contains(L3.current) && d17 instanceof HTMLElement)) != null ? c14 : null;
  }, [L3]);
  b(de6, pe2);
  let ue7 = (() => !(!S11 || x5))();
  y2(w7, (t19) => {
    t19.preventDefault(), P6();
  }, ue7);
  let fe4 = (() => !(x5 || p8 !== 0))();
  E3(g6 == null ? void 0 : g6.defaultView, "keydown", (t19) => {
    fe4 && (t19.defaultPrevented || t19.key === o11.Escape && (t19.preventDefault(), t19.stopPropagation(), P6()));
  });
  let ge5 = (() => !(J7 || p8 !== 0 || j6))();
  Be(g6, ge5, w7), (0, import_react30.useEffect)(() => {
    if (p8 !== 0 || !D8.current)
      return;
    let t19 = new ResizeObserver((c14) => {
      for (let d17 of c14) {
        let F11 = d17.target.getBoundingClientRect();
        F11.x === 0 && F11.y === 0 && F11.width === 0 && F11.height === 0 && P6();
      }
    });
    return t19.observe(D8.current), () => t19.disconnect();
  }, [p8, D8, P6]);
  let [Te3, ce4] = w3(), De4 = (0, import_react30.useMemo)(() => [{ dialogState: p8, close: P6, setTitleId: Y4 }, h10], [p8, h10, P6, Y4]), X6 = (0, import_react30.useMemo)(() => ({ open: p8 === 0 }), [p8]), me4 = { ref: ee8, id: i9, role: a11, "aria-modal": p8 === 0 ? true : void 0, "aria-labelledby": h10.titleId, "aria-describedby": Te3 };
  return import_react30.default.createElement(b2, { type: "Dialog", enabled: p8 === 0, element: D8, onUpdate: o2((t19, c14) => {
    c14 === "Dialog" && u(t19, { [s13.Add]: () => f15((d17) => d17 + 1), [s13.Remove]: () => f15((d17) => d17 - 1) });
  }) }, import_react30.default.createElement(l6, { force: true }, import_react30.default.createElement(te, null, import_react30.default.createElement(I6.Provider, { value: De4 }, import_react30.default.createElement(te.Group, { target: D8 }, import_react30.default.createElement(l6, { force: false }, import_react30.default.createElement(ce4, { slot: X6, name: "Dialog.Description" }, import_react30.default.createElement(de2, { initialFocus: s18, containers: w7, features: S11 ? u(ae3, { parent: de2.features.RestoreFocus, leaf: de2.features.All & ~de2.features.FocusLock }) : de2.features.None }, import_react30.default.createElement(re6, null, C({ ourProps: me4, theirProps: m13, slot: X6, defaultTag: Ne, features: Ue, visible: p8 === 0, name: "Dialog" }))))))))), import_react30.default.createElement(le3, null));
}
var $e2 = "div";
function Ye2(o14, e5) {
  let r10 = I(), { id: i9 = `headlessui-dialog-overlay-${r10}`, ...n8 } = o14, [{ dialogState: l14, close: s18 }] = b3("Dialog.Overlay"), a11 = y3(e5), T8 = o2((f15) => {
    if (f15.target === f15.currentTarget) {
      if (r2(f15.currentTarget))
        return f15.preventDefault();
      f15.preventDefault(), f15.stopPropagation(), s18();
    }
  }), m13 = (0, import_react30.useMemo)(() => ({ open: l14 === 0 }), [l14]);
  return C({ ourProps: { ref: a11, id: i9, "aria-hidden": true, onClick: T8 }, theirProps: n8, slot: m13, defaultTag: $e2, name: "Dialog.Overlay" });
}
var je = "div";
function Je(o14, e5) {
  let r10 = I(), { id: i9 = `headlessui-dialog-backdrop-${r10}`, ...n8 } = o14, [{ dialogState: l14 }, s18] = b3("Dialog.Backdrop"), a11 = y3(e5);
  (0, import_react30.useEffect)(() => {
    if (s18.panelRef.current === null)
      throw new Error("A <Dialog.Backdrop /> component is being used, but a <Dialog.Panel /> component is missing.");
  }, [s18.panelRef]);
  let T8 = (0, import_react30.useMemo)(() => ({ open: l14 === 0 }), [l14]);
  return import_react30.default.createElement(l6, { force: true }, import_react30.default.createElement(te, null, C({ ourProps: { ref: a11, id: i9, "aria-hidden": true }, theirProps: n8, slot: T8, defaultTag: je, name: "Dialog.Backdrop" })));
}
var Xe = "div";
function Ke(o14, e5) {
  let r10 = I(), { id: i9 = `headlessui-dialog-panel-${r10}`, ...n8 } = o14, [{ dialogState: l14 }, s18] = b3("Dialog.Panel"), a11 = y3(e5, s18.panelRef), T8 = (0, import_react30.useMemo)(() => ({ open: l14 === 0 }), [l14]), m13 = o2((f15) => {
    f15.stopPropagation();
  });
  return C({ ourProps: { ref: a11, id: i9, onClick: m13 }, theirProps: n8, slot: T8, defaultTag: Xe, name: "Dialog.Panel" });
}
var Ve2 = "h2";
function qe2(o14, e5) {
  let r10 = I(), { id: i9 = `headlessui-dialog-title-${r10}`, ...n8 } = o14, [{ dialogState: l14, setTitleId: s18 }] = b3("Dialog.Title"), a11 = y3(e5);
  (0, import_react30.useEffect)(() => (s18(i9), () => s18(null)), [i9, s18]);
  let T8 = (0, import_react30.useMemo)(() => ({ open: l14 === 0 }), [l14]);
  return C({ ourProps: { ref: a11, id: i9 }, theirProps: n8, slot: T8, defaultTag: Ve2, name: "Dialog.Title" });
}
var ze2 = U(We);
var Qe2 = U(Je);
var Ze2 = U(Ke);
var et2 = U(Ye2);
var tt2 = U(qe2);
var _t = Object.assign(ze2, { Backdrop: Qe2, Panel: Ze2, Overlay: et2, Title: tt2, Description: G });

// node_modules/@headlessui/react/dist/components/disclosure/disclosure.js
var import_react32 = __toESM(require_react(), 1);

// node_modules/@headlessui/react/dist/utils/start-transition.js
var import_react31 = __toESM(require_react(), 1);
var t17;
var a7 = (t17 = import_react31.default.startTransition) != null ? t17 : function(i9) {
  i9();
};

// node_modules/@headlessui/react/dist/components/disclosure/disclosure.js
var Q2 = ((o14) => (o14[o14.Open = 0] = "Open", o14[o14.Closed = 1] = "Closed", o14))(Q2 || {});
var V2 = ((t19) => (t19[t19.ToggleDisclosure = 0] = "ToggleDisclosure", t19[t19.CloseDisclosure = 1] = "CloseDisclosure", t19[t19.SetButtonId = 2] = "SetButtonId", t19[t19.SetPanelId = 3] = "SetPanelId", t19[t19.LinkPanel = 4] = "LinkPanel", t19[t19.UnlinkPanel = 5] = "UnlinkPanel", t19))(V2 || {});
var Y2 = { [0]: (e5) => ({ ...e5, disclosureState: u(e5.disclosureState, { [0]: 1, [1]: 0 }) }), [1]: (e5) => e5.disclosureState === 1 ? e5 : { ...e5, disclosureState: 1 }, [4](e5) {
  return e5.linkedPanel === true ? e5 : { ...e5, linkedPanel: true };
}, [5](e5) {
  return e5.linkedPanel === false ? e5 : { ...e5, linkedPanel: false };
}, [2](e5, n8) {
  return e5.buttonId === n8.buttonId ? e5 : { ...e5, buttonId: n8.buttonId };
}, [3](e5, n8) {
  return e5.panelId === n8.panelId ? e5 : { ...e5, panelId: n8.panelId };
} };
var M3 = (0, import_react32.createContext)(null);
M3.displayName = "DisclosureContext";
function _4(e5) {
  let n8 = (0, import_react32.useContext)(M3);
  if (n8 === null) {
    let o14 = new Error(`<${e5} /> is missing a parent <Disclosure /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(o14, _4), o14;
  }
  return n8;
}
var v2 = (0, import_react32.createContext)(null);
v2.displayName = "DisclosureAPIContext";
function K2(e5) {
  let n8 = (0, import_react32.useContext)(v2);
  if (n8 === null) {
    let o14 = new Error(`<${e5} /> is missing a parent <Disclosure /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(o14, K2), o14;
  }
  return n8;
}
var F5 = (0, import_react32.createContext)(null);
F5.displayName = "DisclosurePanelContext";
function Z2() {
  return (0, import_react32.useContext)(F5);
}
function ee3(e5, n8) {
  return u(n8.type, Y2, e5, n8);
}
var te2 = import_react32.Fragment;
function ne(e5, n8) {
  let { defaultOpen: o14 = false, ...i9 } = e5, f15 = (0, import_react32.useRef)(null), l14 = y3(n8, T4((u14) => {
    f15.current = u14;
  }, e5.as === void 0 || e5.as === import_react32.Fragment)), t19 = (0, import_react32.useRef)(null), d17 = (0, import_react32.useRef)(null), s18 = (0, import_react32.useReducer)(ee3, { disclosureState: o14 ? 0 : 1, linkedPanel: false, buttonRef: d17, panelRef: t19, buttonId: null, panelId: null }), [{ disclosureState: c14, buttonId: a11 }, D8] = s18, p8 = o2((u14) => {
    D8({ type: 1 });
    let y8 = o7(f15);
    if (!y8 || !a11)
      return;
    let r10 = (() => u14 ? u14 instanceof HTMLElement ? u14 : u14.current instanceof HTMLElement ? u14.current : y8.getElementById(a11) : y8.getElementById(a11))();
    r10 == null || r10.focus();
  }), P6 = (0, import_react32.useMemo)(() => ({ close: p8 }), [p8]), T8 = (0, import_react32.useMemo)(() => ({ open: c14 === 0, close: p8 }), [c14, p8]), C8 = { ref: l14 };
  return import_react32.default.createElement(M3.Provider, { value: s18 }, import_react32.default.createElement(v2.Provider, { value: P6 }, import_react32.default.createElement(s9, { value: u(c14, { [0]: d5.Open, [1]: d5.Closed }) }, C({ ourProps: C8, theirProps: i9, slot: T8, defaultTag: te2, name: "Disclosure" }))));
}
var le = "button";
function oe(e5, n8) {
  let o14 = I(), { id: i9 = `headlessui-disclosure-button-${o14}`, ...f15 } = e5, [l14, t19] = _4("Disclosure.Button"), d17 = Z2(), s18 = d17 === null ? false : d17 === l14.panelId, c14 = (0, import_react32.useRef)(null), a11 = y3(c14, n8, s18 ? null : l14.buttonRef), D8 = I3();
  (0, import_react32.useEffect)(() => {
    if (!s18)
      return t19({ type: 2, buttonId: i9 }), () => {
        t19({ type: 2, buttonId: null });
      };
  }, [i9, t19, s18]);
  let p8 = o2((r10) => {
    var m13;
    if (s18) {
      if (l14.disclosureState === 1)
        return;
      switch (r10.key) {
        case o11.Space:
        case o11.Enter:
          r10.preventDefault(), r10.stopPropagation(), t19({ type: 0 }), (m13 = l14.buttonRef.current) == null || m13.focus();
          break;
      }
    } else
      switch (r10.key) {
        case o11.Space:
        case o11.Enter:
          r10.preventDefault(), r10.stopPropagation(), t19({ type: 0 });
          break;
      }
  }), P6 = o2((r10) => {
    switch (r10.key) {
      case o11.Space:
        r10.preventDefault();
        break;
    }
  }), T8 = o2((r10) => {
    var m13;
    r2(r10.currentTarget) || e5.disabled || (s18 ? (t19({ type: 0 }), (m13 = l14.buttonRef.current) == null || m13.focus()) : t19({ type: 0 }));
  }), C8 = (0, import_react32.useMemo)(() => ({ open: l14.disclosureState === 0 }), [l14]), u14 = T3(e5, c14), y8 = s18 ? { ref: a11, type: u14, onKeyDown: p8, onClick: T8 } : { ref: a11, id: i9, type: u14, "aria-expanded": l14.disclosureState === 0, "aria-controls": l14.linkedPanel ? l14.panelId : void 0, onKeyDown: p8, onKeyUp: P6, onClick: T8 };
  return C({ mergeRefs: D8, ourProps: y8, theirProps: f15, slot: C8, defaultTag: le, name: "Disclosure.Button" });
}
var re = "div";
var se = O2.RenderStrategy | O2.Static;
function ue2(e5, n8) {
  let o14 = I(), { id: i9 = `headlessui-disclosure-panel-${o14}`, ...f15 } = e5, [l14, t19] = _4("Disclosure.Panel"), { close: d17 } = K2("Disclosure.Panel"), s18 = I3(), c14 = y3(n8, l14.panelRef, (T8) => {
    a7(() => t19({ type: T8 ? 4 : 5 }));
  });
  (0, import_react32.useEffect)(() => (t19({ type: 3, panelId: i9 }), () => {
    t19({ type: 3, panelId: null });
  }), [i9, t19]);
  let a11 = u5(), D8 = (() => a11 !== null ? (a11 & d5.Open) === d5.Open : l14.disclosureState === 0)(), p8 = (0, import_react32.useMemo)(() => ({ open: l14.disclosureState === 0, close: d17 }), [l14, d17]), P6 = { ref: c14, id: i9 };
  return import_react32.default.createElement(F5.Provider, { value: l14.panelId }, C({ mergeRefs: s18, ourProps: P6, theirProps: f15, slot: p8, defaultTag: re, features: se, visible: D8, name: "Disclosure.Panel" }));
}
var ie2 = U(ne);
var ae = U(oe);
var pe = U(ue2);
var Ae2 = Object.assign(ie2, { Button: ae, Panel: pe });

// node_modules/@headlessui/react/dist/components/listbox/listbox.js
var import_react34 = __toESM(require_react(), 1);

// node_modules/@headlessui/react/dist/hooks/use-text-value.js
var import_react33 = __toESM(require_react(), 1);

// node_modules/@headlessui/react/dist/utils/get-text-value.js
var a8 = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
function o12(e5) {
  var r10, i9;
  let n8 = (r10 = e5.innerText) != null ? r10 : "", t19 = e5.cloneNode(true);
  if (!(t19 instanceof HTMLElement))
    return n8;
  let u14 = false;
  for (let f15 of t19.querySelectorAll('[hidden],[aria-hidden],[role="img"]'))
    f15.remove(), u14 = true;
  let l14 = u14 ? (i9 = t19.innerText) != null ? i9 : "" : n8;
  return a8.test(l14) && (l14 = l14.replace(a8, "")), l14;
}
function g3(e5) {
  let n8 = e5.getAttribute("aria-label");
  if (typeof n8 == "string")
    return n8.trim();
  let t19 = e5.getAttribute("aria-labelledby");
  if (t19) {
    let u14 = t19.split(" ").map((l14) => {
      let r10 = document.getElementById(l14);
      if (r10) {
        let i9 = r10.getAttribute("aria-label");
        return typeof i9 == "string" ? i9.trim() : o12(r10).trim();
      }
      return null;
    }).filter(Boolean);
    if (u14.length > 0)
      return u14.join(", ");
  }
  return o12(e5).trim();
}

// node_modules/@headlessui/react/dist/hooks/use-text-value.js
function s14(c14) {
  let t19 = (0, import_react33.useRef)(""), r10 = (0, import_react33.useRef)("");
  return o2(() => {
    let e5 = c14.current;
    if (!e5)
      return "";
    let u14 = e5.innerText;
    if (t19.current === u14)
      return r10.current;
    let n8 = g3(e5).trim().toLowerCase();
    return t19.current = u14, r10.current = n8, n8;
  });
}

// node_modules/@headlessui/react/dist/components/listbox/listbox.js
var Be2 = ((n8) => (n8[n8.Open = 0] = "Open", n8[n8.Closed = 1] = "Closed", n8))(Be2 || {});
var He2 = ((n8) => (n8[n8.Single = 0] = "Single", n8[n8.Multi = 1] = "Multi", n8))(He2 || {});
var Ge2 = ((n8) => (n8[n8.Pointer = 0] = "Pointer", n8[n8.Other = 1] = "Other", n8))(Ge2 || {});
var Ne2 = ((i9) => (i9[i9.OpenListbox = 0] = "OpenListbox", i9[i9.CloseListbox = 1] = "CloseListbox", i9[i9.GoToOption = 2] = "GoToOption", i9[i9.Search = 3] = "Search", i9[i9.ClearSearch = 4] = "ClearSearch", i9[i9.RegisterOption = 5] = "RegisterOption", i9[i9.UnregisterOption = 6] = "UnregisterOption", i9[i9.RegisterLabel = 7] = "RegisterLabel", i9))(Ne2 || {});
function z2(e5, a11 = (n8) => n8) {
  let n8 = e5.activeOptionIndex !== null ? e5.options[e5.activeOptionIndex] : null, r10 = I2(a11(e5.options.slice()), (t19) => t19.dataRef.current.domRef.current), l14 = n8 ? r10.indexOf(n8) : null;
  return l14 === -1 && (l14 = null), { options: r10, activeOptionIndex: l14 };
}
var je2 = { [1](e5) {
  return e5.dataRef.current.disabled || e5.listboxState === 1 ? e5 : { ...e5, activeOptionIndex: null, listboxState: 1 };
}, [0](e5) {
  if (e5.dataRef.current.disabled || e5.listboxState === 0)
    return e5;
  let a11 = e5.activeOptionIndex, { isSelected: n8 } = e5.dataRef.current, r10 = e5.options.findIndex((l14) => n8(l14.dataRef.current.value));
  return r10 !== -1 && (a11 = r10), { ...e5, listboxState: 0, activeOptionIndex: a11 };
}, [2](e5, a11) {
  var l14;
  if (e5.dataRef.current.disabled || e5.listboxState === 1)
    return e5;
  let n8 = z2(e5), r10 = f5(a11, { resolveItems: () => n8.options, resolveActiveIndex: () => n8.activeOptionIndex, resolveId: (t19) => t19.id, resolveDisabled: (t19) => t19.dataRef.current.disabled });
  return { ...e5, ...n8, searchQuery: "", activeOptionIndex: r10, activationTrigger: (l14 = a11.trigger) != null ? l14 : 1 };
}, [3]: (e5, a11) => {
  if (e5.dataRef.current.disabled || e5.listboxState === 1)
    return e5;
  let r10 = e5.searchQuery !== "" ? 0 : 1, l14 = e5.searchQuery + a11.value.toLowerCase(), p8 = (e5.activeOptionIndex !== null ? e5.options.slice(e5.activeOptionIndex + r10).concat(e5.options.slice(0, e5.activeOptionIndex + r10)) : e5.options).find((i9) => {
    var b8;
    return !i9.dataRef.current.disabled && ((b8 = i9.dataRef.current.textValue) == null ? void 0 : b8.startsWith(l14));
  }), u14 = p8 ? e5.options.indexOf(p8) : -1;
  return u14 === -1 || u14 === e5.activeOptionIndex ? { ...e5, searchQuery: l14 } : { ...e5, searchQuery: l14, activeOptionIndex: u14, activationTrigger: 1 };
}, [4](e5) {
  return e5.dataRef.current.disabled || e5.listboxState === 1 || e5.searchQuery === "" ? e5 : { ...e5, searchQuery: "" };
}, [5]: (e5, a11) => {
  let n8 = { id: a11.id, dataRef: a11.dataRef }, r10 = z2(e5, (l14) => [...l14, n8]);
  return e5.activeOptionIndex === null && e5.dataRef.current.isSelected(a11.dataRef.current.value) && (r10.activeOptionIndex = r10.options.indexOf(n8)), { ...e5, ...r10 };
}, [6]: (e5, a11) => {
  let n8 = z2(e5, (r10) => {
    let l14 = r10.findIndex((t19) => t19.id === a11.id);
    return l14 !== -1 && r10.splice(l14, 1), r10;
  });
  return { ...e5, ...n8, activationTrigger: 1 };
}, [7]: (e5, a11) => ({ ...e5, labelId: a11.id }) };
var J = (0, import_react34.createContext)(null);
J.displayName = "ListboxActionsContext";
function k2(e5) {
  let a11 = (0, import_react34.useContext)(J);
  if (a11 === null) {
    let n8 = new Error(`<${e5} /> is missing a parent <Listbox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(n8, k2), n8;
  }
  return a11;
}
var q2 = (0, import_react34.createContext)(null);
q2.displayName = "ListboxDataContext";
function w4(e5) {
  let a11 = (0, import_react34.useContext)(q2);
  if (a11 === null) {
    let n8 = new Error(`<${e5} /> is missing a parent <Listbox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(n8, w4), n8;
  }
  return a11;
}
function Ve3(e5, a11) {
  return u(a11.type, je2, e5, a11);
}
var Ke2 = import_react34.Fragment;
function Qe3(e5, a11) {
  let { value: n8, defaultValue: r10, form: l14, name: t19, onChange: p8, by: u14 = (s18, c14) => s18 === c14, disabled: i9 = false, horizontal: b8 = false, multiple: R5 = false, ...m13 } = e5;
  const P6 = b8 ? "horizontal" : "vertical";
  let S11 = y3(a11), [g6 = R5 ? [] : void 0, x5] = T(n8, p8, r10), [T8, o14] = (0, import_react34.useReducer)(Ve3, { dataRef: (0, import_react34.createRef)(), listboxState: 1, options: [], searchQuery: "", labelId: null, activeOptionIndex: null, activationTrigger: 1 }), L3 = (0, import_react34.useRef)({ static: false, hold: false }), U8 = (0, import_react34.useRef)(null), B5 = (0, import_react34.useRef)(null), W2 = (0, import_react34.useRef)(null), I12 = o2(typeof u14 == "string" ? (s18, c14) => {
    let O5 = u14;
    return (s18 == null ? void 0 : s18[O5]) === (c14 == null ? void 0 : c14[O5]);
  } : u14), A4 = (0, import_react34.useCallback)((s18) => u(d17.mode, { [1]: () => g6.some((c14) => I12(c14, s18)), [0]: () => I12(g6, s18) }), [g6]), d17 = (0, import_react34.useMemo)(() => ({ ...T8, value: g6, disabled: i9, mode: R5 ? 1 : 0, orientation: P6, compare: I12, isSelected: A4, optionsPropsRef: L3, labelRef: U8, buttonRef: B5, optionsRef: W2 }), [g6, i9, R5, T8]);
  l(() => {
    T8.dataRef.current = d17;
  }, [d17]), y2([d17.buttonRef, d17.optionsRef], (s18, c14) => {
    var O5;
    o14({ type: 1 }), h(c14, T2.Loose) || (s18.preventDefault(), (O5 = d17.buttonRef.current) == null || O5.focus());
  }, d17.listboxState === 0);
  let H7 = (0, import_react34.useMemo)(() => ({ open: d17.listboxState === 0, disabled: i9, value: g6 }), [d17, i9, g6]), ie5 = o2((s18) => {
    let c14 = d17.options.find((O5) => O5.id === s18);
    c14 && X6(c14.dataRef.current.value);
  }), re6 = o2(() => {
    if (d17.activeOptionIndex !== null) {
      let { dataRef: s18, id: c14 } = d17.options[d17.activeOptionIndex];
      X6(s18.current.value), o14({ type: 2, focus: c3.Specific, id: c14 });
    }
  }), ae3 = o2(() => o14({ type: 0 })), le3 = o2(() => o14({ type: 1 })), se4 = o2((s18, c14, O5) => s18 === c3.Specific ? o14({ type: 2, focus: c3.Specific, id: c14, trigger: O5 }) : o14({ type: 2, focus: s18, trigger: O5 })), pe2 = o2((s18, c14) => (o14({ type: 5, id: s18, dataRef: c14 }), () => o14({ type: 6, id: s18 }))), ue7 = o2((s18) => (o14({ type: 7, id: s18 }), () => o14({ type: 7, id: null }))), X6 = o2((s18) => u(d17.mode, { [0]() {
    return x5 == null ? void 0 : x5(s18);
  }, [1]() {
    let c14 = d17.value.slice(), O5 = c14.findIndex((C8) => I12(C8, s18));
    return O5 === -1 ? c14.push(s18) : c14.splice(O5, 1), x5 == null ? void 0 : x5(c14);
  } })), de6 = o2((s18) => o14({ type: 3, value: s18 })), ce4 = o2(() => o14({ type: 4 })), fe4 = (0, import_react34.useMemo)(() => ({ onChange: X6, registerOption: pe2, registerLabel: ue7, goToOption: se4, closeListbox: le3, openListbox: ae3, selectActiveOption: re6, selectOption: ie5, search: de6, clearSearch: ce4 }), []), Te3 = { ref: S11 }, G5 = (0, import_react34.useRef)(null), be4 = p();
  return (0, import_react34.useEffect)(() => {
    G5.current && r10 !== void 0 && be4.addEventListener(G5.current, "reset", () => {
      x5 == null || x5(r10);
    });
  }, [G5, x5]), import_react34.default.createElement(J.Provider, { value: fe4 }, import_react34.default.createElement(q2.Provider, { value: d17 }, import_react34.default.createElement(s9, { value: u(d17.listboxState, { [0]: d5.Open, [1]: d5.Closed }) }, t19 != null && g6 != null && e({ [t19]: g6 }).map(([s18, c14], O5) => import_react34.default.createElement(u4, { features: s8.Hidden, ref: O5 === 0 ? (C8) => {
    var Y4;
    G5.current = (Y4 = C8 == null ? void 0 : C8.closest("form")) != null ? Y4 : null;
  } : void 0, ...x({ key: s18, as: "input", type: "hidden", hidden: true, readOnly: true, form: l14, disabled: i9, name: s18, value: c14 }) })), C({ ourProps: Te3, theirProps: m13, slot: H7, defaultTag: Ke2, name: "Listbox" }))));
}
var We2 = "button";
function Xe2(e5, a11) {
  var x5;
  let n8 = I(), { id: r10 = `headlessui-listbox-button-${n8}`, ...l14 } = e5, t19 = w4("Listbox.Button"), p8 = k2("Listbox.Button"), u14 = y3(t19.buttonRef, a11), i9 = p(), b8 = o2((T8) => {
    switch (T8.key) {
      case o11.Space:
      case o11.Enter:
      case o11.ArrowDown:
        T8.preventDefault(), p8.openListbox(), i9.nextFrame(() => {
          t19.value || p8.goToOption(c3.First);
        });
        break;
      case o11.ArrowUp:
        T8.preventDefault(), p8.openListbox(), i9.nextFrame(() => {
          t19.value || p8.goToOption(c3.Last);
        });
        break;
    }
  }), R5 = o2((T8) => {
    switch (T8.key) {
      case o11.Space:
        T8.preventDefault();
        break;
    }
  }), m13 = o2((T8) => {
    if (r2(T8.currentTarget))
      return T8.preventDefault();
    t19.listboxState === 0 ? (p8.closeListbox(), i9.nextFrame(() => {
      var o14;
      return (o14 = t19.buttonRef.current) == null ? void 0 : o14.focus({ preventScroll: true });
    })) : (T8.preventDefault(), p8.openListbox());
  }), P6 = i2(() => {
    if (t19.labelId)
      return [t19.labelId, r10].join(" ");
  }, [t19.labelId, r10]), S11 = (0, import_react34.useMemo)(() => ({ open: t19.listboxState === 0, disabled: t19.disabled, value: t19.value }), [t19]), g6 = { ref: u14, id: r10, type: T3(e5, t19.buttonRef), "aria-haspopup": "listbox", "aria-controls": (x5 = t19.optionsRef.current) == null ? void 0 : x5.id, "aria-expanded": t19.listboxState === 0, "aria-labelledby": P6, disabled: t19.disabled, onKeyDown: b8, onKeyUp: R5, onClick: m13 };
  return C({ ourProps: g6, theirProps: l14, slot: S11, defaultTag: We2, name: "Listbox.Button" });
}
var $e3 = "label";
function ze3(e5, a11) {
  let n8 = I(), { id: r10 = `headlessui-listbox-label-${n8}`, ...l14 } = e5, t19 = w4("Listbox.Label"), p8 = k2("Listbox.Label"), u14 = y3(t19.labelRef, a11);
  l(() => p8.registerLabel(r10), [r10]);
  let i9 = o2(() => {
    var m13;
    return (m13 = t19.buttonRef.current) == null ? void 0 : m13.focus({ preventScroll: true });
  }), b8 = (0, import_react34.useMemo)(() => ({ open: t19.listboxState === 0, disabled: t19.disabled }), [t19]);
  return C({ ourProps: { ref: u14, id: r10, onClick: i9 }, theirProps: l14, slot: b8, defaultTag: $e3, name: "Listbox.Label" });
}
var Je2 = "ul";
var qe3 = O2.RenderStrategy | O2.Static;
function Ye3(e5, a11) {
  var T8;
  let n8 = I(), { id: r10 = `headlessui-listbox-options-${n8}`, ...l14 } = e5, t19 = w4("Listbox.Options"), p8 = k2("Listbox.Options"), u14 = y3(t19.optionsRef, a11), i9 = p(), b8 = p(), R5 = u5(), m13 = (() => R5 !== null ? (R5 & d5.Open) === d5.Open : t19.listboxState === 0)();
  (0, import_react34.useEffect)(() => {
    var L3;
    let o14 = t19.optionsRef.current;
    o14 && t19.listboxState === 0 && o14 !== ((L3 = o7(o14)) == null ? void 0 : L3.activeElement) && o14.focus({ preventScroll: true });
  }, [t19.listboxState, t19.optionsRef]);
  let P6 = o2((o14) => {
    switch (b8.dispose(), o14.key) {
      case o11.Space:
        if (t19.searchQuery !== "")
          return o14.preventDefault(), o14.stopPropagation(), p8.search(o14.key);
      case o11.Enter:
        if (o14.preventDefault(), o14.stopPropagation(), t19.activeOptionIndex !== null) {
          let { dataRef: L3 } = t19.options[t19.activeOptionIndex];
          p8.onChange(L3.current.value);
        }
        t19.mode === 0 && (p8.closeListbox(), o4().nextFrame(() => {
          var L3;
          return (L3 = t19.buttonRef.current) == null ? void 0 : L3.focus({ preventScroll: true });
        }));
        break;
      case u(t19.orientation, { vertical: o11.ArrowDown, horizontal: o11.ArrowRight }):
        return o14.preventDefault(), o14.stopPropagation(), p8.goToOption(c3.Next);
      case u(t19.orientation, { vertical: o11.ArrowUp, horizontal: o11.ArrowLeft }):
        return o14.preventDefault(), o14.stopPropagation(), p8.goToOption(c3.Previous);
      case o11.Home:
      case o11.PageUp:
        return o14.preventDefault(), o14.stopPropagation(), p8.goToOption(c3.First);
      case o11.End:
      case o11.PageDown:
        return o14.preventDefault(), o14.stopPropagation(), p8.goToOption(c3.Last);
      case o11.Escape:
        return o14.preventDefault(), o14.stopPropagation(), p8.closeListbox(), i9.nextFrame(() => {
          var L3;
          return (L3 = t19.buttonRef.current) == null ? void 0 : L3.focus({ preventScroll: true });
        });
      case o11.Tab:
        o14.preventDefault(), o14.stopPropagation();
        break;
      default:
        o14.key.length === 1 && (p8.search(o14.key), b8.setTimeout(() => p8.clearSearch(), 350));
        break;
    }
  }), S11 = i2(() => {
    var o14;
    return (o14 = t19.buttonRef.current) == null ? void 0 : o14.id;
  }, [t19.buttonRef.current]), g6 = (0, import_react34.useMemo)(() => ({ open: t19.listboxState === 0 }), [t19]), x5 = { "aria-activedescendant": t19.activeOptionIndex === null || (T8 = t19.options[t19.activeOptionIndex]) == null ? void 0 : T8.id, "aria-multiselectable": t19.mode === 1 ? true : void 0, "aria-labelledby": S11, "aria-orientation": t19.orientation, id: r10, onKeyDown: P6, role: "listbox", tabIndex: 0, ref: u14 };
  return C({ ourProps: x5, theirProps: l14, slot: g6, defaultTag: Je2, features: qe3, visible: m13, name: "Listbox.Options" });
}
var Ze3 = "li";
function et3(e5, a11) {
  let n8 = I(), { id: r10 = `headlessui-listbox-option-${n8}`, disabled: l14 = false, value: t19, ...p8 } = e5, u14 = w4("Listbox.Option"), i9 = k2("Listbox.Option"), b8 = u14.activeOptionIndex !== null ? u14.options[u14.activeOptionIndex].id === r10 : false, R5 = u14.isSelected(t19), m13 = (0, import_react34.useRef)(null), P6 = s14(m13), S11 = s2({ disabled: l14, value: t19, domRef: m13, get textValue() {
    return P6();
  } }), g6 = y3(a11, m13);
  l(() => {
    if (u14.listboxState !== 0 || !b8 || u14.activationTrigger === 0)
      return;
    let A4 = o4();
    return A4.requestAnimationFrame(() => {
      var d17, H7;
      (H7 = (d17 = m13.current) == null ? void 0 : d17.scrollIntoView) == null || H7.call(d17, { block: "nearest" });
    }), A4.dispose;
  }, [m13, b8, u14.listboxState, u14.activationTrigger, u14.activeOptionIndex]), l(() => i9.registerOption(r10, S11), [S11, r10]);
  let x5 = o2((A4) => {
    if (l14)
      return A4.preventDefault();
    i9.onChange(t19), u14.mode === 0 && (i9.closeListbox(), o4().nextFrame(() => {
      var d17;
      return (d17 = u14.buttonRef.current) == null ? void 0 : d17.focus({ preventScroll: true });
    }));
  }), T8 = o2(() => {
    if (l14)
      return i9.goToOption(c3.Nothing);
    i9.goToOption(c3.Specific, r10);
  }), o14 = u3(), L3 = o2((A4) => o14.update(A4)), U8 = o2((A4) => {
    o14.wasMoved(A4) && (l14 || b8 || i9.goToOption(c3.Specific, r10, 0));
  }), B5 = o2((A4) => {
    o14.wasMoved(A4) && (l14 || b8 && i9.goToOption(c3.Nothing));
  }), W2 = (0, import_react34.useMemo)(() => ({ active: b8, selected: R5, disabled: l14 }), [b8, R5, l14]);
  return C({ ourProps: { id: r10, ref: g6, role: "option", tabIndex: l14 === true ? void 0 : -1, "aria-disabled": l14 === true ? true : void 0, "aria-selected": R5, disabled: void 0, onClick: x5, onFocus: T8, onPointerEnter: L3, onMouseEnter: L3, onPointerMove: U8, onMouseMove: U8, onPointerLeave: B5, onMouseLeave: B5 }, theirProps: p8, slot: W2, defaultTag: Ze3, name: "Listbox.Option" });
}
var tt3 = U(Qe3);
var ot2 = U(Xe2);
var nt2 = U(ze3);
var it2 = U(Ye3);
var rt2 = U(et3);
var It = Object.assign(tt3, { Button: ot2, Label: nt2, Options: it2, Option: rt2 });

// node_modules/@headlessui/react/dist/components/menu/menu.js
var import_react35 = __toESM(require_react(), 1);
var me2 = ((r10) => (r10[r10.Open = 0] = "Open", r10[r10.Closed = 1] = "Closed", r10))(me2 || {});
var de3 = ((r10) => (r10[r10.Pointer = 0] = "Pointer", r10[r10.Other = 1] = "Other", r10))(de3 || {});
var fe = ((a11) => (a11[a11.OpenMenu = 0] = "OpenMenu", a11[a11.CloseMenu = 1] = "CloseMenu", a11[a11.GoToItem = 2] = "GoToItem", a11[a11.Search = 3] = "Search", a11[a11.ClearSearch = 4] = "ClearSearch", a11[a11.RegisterItem = 5] = "RegisterItem", a11[a11.UnregisterItem = 6] = "UnregisterItem", a11))(fe || {});
function w5(e5, u14 = (r10) => r10) {
  let r10 = e5.activeItemIndex !== null ? e5.items[e5.activeItemIndex] : null, s18 = I2(u14(e5.items.slice()), (t19) => t19.dataRef.current.domRef.current), i9 = r10 ? s18.indexOf(r10) : null;
  return i9 === -1 && (i9 = null), { items: s18, activeItemIndex: i9 };
}
var Te = { [1](e5) {
  return e5.menuState === 1 ? e5 : { ...e5, activeItemIndex: null, menuState: 1 };
}, [0](e5) {
  return e5.menuState === 0 ? e5 : { ...e5, __demoMode: false, menuState: 0 };
}, [2]: (e5, u14) => {
  var i9;
  let r10 = w5(e5), s18 = f5(u14, { resolveItems: () => r10.items, resolveActiveIndex: () => r10.activeItemIndex, resolveId: (t19) => t19.id, resolveDisabled: (t19) => t19.dataRef.current.disabled });
  return { ...e5, ...r10, searchQuery: "", activeItemIndex: s18, activationTrigger: (i9 = u14.trigger) != null ? i9 : 1 };
}, [3]: (e5, u14) => {
  let s18 = e5.searchQuery !== "" ? 0 : 1, i9 = e5.searchQuery + u14.value.toLowerCase(), o14 = (e5.activeItemIndex !== null ? e5.items.slice(e5.activeItemIndex + s18).concat(e5.items.slice(0, e5.activeItemIndex + s18)) : e5.items).find((l14) => {
    var m13;
    return ((m13 = l14.dataRef.current.textValue) == null ? void 0 : m13.startsWith(i9)) && !l14.dataRef.current.disabled;
  }), a11 = o14 ? e5.items.indexOf(o14) : -1;
  return a11 === -1 || a11 === e5.activeItemIndex ? { ...e5, searchQuery: i9 } : { ...e5, searchQuery: i9, activeItemIndex: a11, activationTrigger: 1 };
}, [4](e5) {
  return e5.searchQuery === "" ? e5 : { ...e5, searchQuery: "", searchActiveItemIndex: null };
}, [5]: (e5, u14) => {
  let r10 = w5(e5, (s18) => [...s18, { id: u14.id, dataRef: u14.dataRef }]);
  return { ...e5, ...r10 };
}, [6]: (e5, u14) => {
  let r10 = w5(e5, (s18) => {
    let i9 = s18.findIndex((t19) => t19.id === u14.id);
    return i9 !== -1 && s18.splice(i9, 1), s18;
  });
  return { ...e5, ...r10, activationTrigger: 1 };
} };
var U4 = (0, import_react35.createContext)(null);
U4.displayName = "MenuContext";
function C3(e5) {
  let u14 = (0, import_react35.useContext)(U4);
  if (u14 === null) {
    let r10 = new Error(`<${e5} /> is missing a parent <Menu /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r10, C3), r10;
  }
  return u14;
}
function ye3(e5, u14) {
  return u(u14.type, Te, e5, u14);
}
var Ie2 = import_react35.Fragment;
function Me2(e5, u14) {
  let { __demoMode: r10 = false, ...s18 } = e5, i9 = (0, import_react35.useReducer)(ye3, { __demoMode: r10, menuState: r10 ? 0 : 1, buttonRef: (0, import_react35.createRef)(), itemsRef: (0, import_react35.createRef)(), items: [], searchQuery: "", activeItemIndex: null, activationTrigger: 1 }), [{ menuState: t19, itemsRef: o14, buttonRef: a11 }, l14] = i9, m13 = y3(u14);
  y2([a11, o14], (g6, R5) => {
    var p8;
    l14({ type: 1 }), h(R5, T2.Loose) || (g6.preventDefault(), (p8 = a11.current) == null || p8.focus());
  }, t19 === 0);
  let I12 = o2(() => {
    l14({ type: 1 });
  }), A4 = (0, import_react35.useMemo)(() => ({ open: t19 === 0, close: I12 }), [t19, I12]), f15 = { ref: m13 };
  return import_react35.default.createElement(U4.Provider, { value: i9 }, import_react35.default.createElement(s9, { value: u(t19, { [0]: d5.Open, [1]: d5.Closed }) }, C({ ourProps: f15, theirProps: s18, slot: A4, defaultTag: Ie2, name: "Menu" })));
}
var ge2 = "button";
function Re(e5, u14) {
  var R5;
  let r10 = I(), { id: s18 = `headlessui-menu-button-${r10}`, ...i9 } = e5, [t19, o14] = C3("Menu.Button"), a11 = y3(t19.buttonRef, u14), l14 = p(), m13 = o2((p8) => {
    switch (p8.key) {
      case o11.Space:
      case o11.Enter:
      case o11.ArrowDown:
        p8.preventDefault(), p8.stopPropagation(), o14({ type: 0 }), l14.nextFrame(() => o14({ type: 2, focus: c3.First }));
        break;
      case o11.ArrowUp:
        p8.preventDefault(), p8.stopPropagation(), o14({ type: 0 }), l14.nextFrame(() => o14({ type: 2, focus: c3.Last }));
        break;
    }
  }), I12 = o2((p8) => {
    switch (p8.key) {
      case o11.Space:
        p8.preventDefault();
        break;
    }
  }), A4 = o2((p8) => {
    if (r2(p8.currentTarget))
      return p8.preventDefault();
    e5.disabled || (t19.menuState === 0 ? (o14({ type: 1 }), l14.nextFrame(() => {
      var M8;
      return (M8 = t19.buttonRef.current) == null ? void 0 : M8.focus({ preventScroll: true });
    })) : (p8.preventDefault(), o14({ type: 0 })));
  }), f15 = (0, import_react35.useMemo)(() => ({ open: t19.menuState === 0 }), [t19]), g6 = { ref: a11, id: s18, type: T3(e5, t19.buttonRef), "aria-haspopup": "menu", "aria-controls": (R5 = t19.itemsRef.current) == null ? void 0 : R5.id, "aria-expanded": t19.menuState === 0, onKeyDown: m13, onKeyUp: I12, onClick: A4 };
  return C({ ourProps: g6, theirProps: i9, slot: f15, defaultTag: ge2, name: "Menu.Button" });
}
var Ae3 = "div";
var be2 = O2.RenderStrategy | O2.Static;
function Ee2(e5, u14) {
  var M8, b8;
  let r10 = I(), { id: s18 = `headlessui-menu-items-${r10}`, ...i9 } = e5, [t19, o14] = C3("Menu.Items"), a11 = y3(t19.itemsRef, u14), l14 = n2(t19.itemsRef), m13 = p(), I12 = u5(), A4 = (() => I12 !== null ? (I12 & d5.Open) === d5.Open : t19.menuState === 0)();
  (0, import_react35.useEffect)(() => {
    let n8 = t19.itemsRef.current;
    n8 && t19.menuState === 0 && n8 !== (l14 == null ? void 0 : l14.activeElement) && n8.focus({ preventScroll: true });
  }, [t19.menuState, t19.itemsRef, l14]), F2({ container: t19.itemsRef.current, enabled: t19.menuState === 0, accept(n8) {
    return n8.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : n8.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(n8) {
    n8.setAttribute("role", "none");
  } });
  let f15 = o2((n8) => {
    var E9, x5;
    switch (m13.dispose(), n8.key) {
      case o11.Space:
        if (t19.searchQuery !== "")
          return n8.preventDefault(), n8.stopPropagation(), o14({ type: 3, value: n8.key });
      case o11.Enter:
        if (n8.preventDefault(), n8.stopPropagation(), o14({ type: 1 }), t19.activeItemIndex !== null) {
          let { dataRef: S11 } = t19.items[t19.activeItemIndex];
          (x5 = (E9 = S11.current) == null ? void 0 : E9.domRef.current) == null || x5.click();
        }
        D(t19.buttonRef.current);
        break;
      case o11.ArrowDown:
        return n8.preventDefault(), n8.stopPropagation(), o14({ type: 2, focus: c3.Next });
      case o11.ArrowUp:
        return n8.preventDefault(), n8.stopPropagation(), o14({ type: 2, focus: c3.Previous });
      case o11.Home:
      case o11.PageUp:
        return n8.preventDefault(), n8.stopPropagation(), o14({ type: 2, focus: c3.First });
      case o11.End:
      case o11.PageDown:
        return n8.preventDefault(), n8.stopPropagation(), o14({ type: 2, focus: c3.Last });
      case o11.Escape:
        n8.preventDefault(), n8.stopPropagation(), o14({ type: 1 }), o4().nextFrame(() => {
          var S11;
          return (S11 = t19.buttonRef.current) == null ? void 0 : S11.focus({ preventScroll: true });
        });
        break;
      case o11.Tab:
        n8.preventDefault(), n8.stopPropagation(), o14({ type: 1 }), o4().nextFrame(() => {
          _(t19.buttonRef.current, n8.shiftKey ? M.Previous : M.Next);
        });
        break;
      default:
        n8.key.length === 1 && (o14({ type: 3, value: n8.key }), m13.setTimeout(() => o14({ type: 4 }), 350));
        break;
    }
  }), g6 = o2((n8) => {
    switch (n8.key) {
      case o11.Space:
        n8.preventDefault();
        break;
    }
  }), R5 = (0, import_react35.useMemo)(() => ({ open: t19.menuState === 0 }), [t19]), p8 = { "aria-activedescendant": t19.activeItemIndex === null || (M8 = t19.items[t19.activeItemIndex]) == null ? void 0 : M8.id, "aria-labelledby": (b8 = t19.buttonRef.current) == null ? void 0 : b8.id, id: s18, onKeyDown: f15, onKeyUp: g6, role: "menu", tabIndex: 0, ref: a11 };
  return C({ ourProps: p8, theirProps: i9, slot: R5, defaultTag: Ae3, features: be2, visible: A4, name: "Menu.Items" });
}
var Se = import_react35.Fragment;
function xe2(e5, u14) {
  let r10 = I(), { id: s18 = `headlessui-menu-item-${r10}`, disabled: i9 = false, ...t19 } = e5, [o14, a11] = C3("Menu.Item"), l14 = o14.activeItemIndex !== null ? o14.items[o14.activeItemIndex].id === s18 : false, m13 = (0, import_react35.useRef)(null), I12 = y3(u14, m13);
  l(() => {
    if (o14.__demoMode || o14.menuState !== 0 || !l14 || o14.activationTrigger === 0)
      return;
    let T8 = o4();
    return T8.requestAnimationFrame(() => {
      var P6, B5;
      (B5 = (P6 = m13.current) == null ? void 0 : P6.scrollIntoView) == null || B5.call(P6, { block: "nearest" });
    }), T8.dispose;
  }, [o14.__demoMode, m13, l14, o14.menuState, o14.activationTrigger, o14.activeItemIndex]);
  let A4 = s14(m13), f15 = (0, import_react35.useRef)({ disabled: i9, domRef: m13, get textValue() {
    return A4();
  } });
  l(() => {
    f15.current.disabled = i9;
  }, [f15, i9]), l(() => (a11({ type: 5, id: s18, dataRef: f15 }), () => a11({ type: 6, id: s18 })), [f15, s18]);
  let g6 = o2(() => {
    a11({ type: 1 });
  }), R5 = o2((T8) => {
    if (i9)
      return T8.preventDefault();
    a11({ type: 1 }), D(o14.buttonRef.current);
  }), p8 = o2(() => {
    if (i9)
      return a11({ type: 2, focus: c3.Nothing });
    a11({ type: 2, focus: c3.Specific, id: s18 });
  }), M8 = u3(), b8 = o2((T8) => M8.update(T8)), n8 = o2((T8) => {
    M8.wasMoved(T8) && (i9 || l14 || a11({ type: 2, focus: c3.Specific, id: s18, trigger: 0 }));
  }), E9 = o2((T8) => {
    M8.wasMoved(T8) && (i9 || l14 && a11({ type: 2, focus: c3.Nothing }));
  }), x5 = (0, import_react35.useMemo)(() => ({ active: l14, disabled: i9, close: g6 }), [l14, i9, g6]);
  return C({ ourProps: { id: s18, ref: I12, role: "menuitem", tabIndex: i9 === true ? void 0 : -1, "aria-disabled": i9 === true ? true : void 0, disabled: void 0, onClick: R5, onFocus: p8, onPointerEnter: b8, onMouseEnter: b8, onPointerMove: n8, onMouseMove: n8, onPointerLeave: E9, onMouseLeave: E9 }, theirProps: t19, slot: x5, defaultTag: Se, name: "Menu.Item" });
}
var Pe3 = U(Me2);
var ve = U(Re);
var he = U(Ee2);
var De = U(xe2);
var qe4 = Object.assign(Pe3, { Button: ve, Items: he, Item: De });

// node_modules/@headlessui/react/dist/components/popover/popover.js
var import_react36 = __toESM(require_react(), 1);
var he2 = ((u14) => (u14[u14.Open = 0] = "Open", u14[u14.Closed = 1] = "Closed", u14))(he2 || {});
var He3 = ((e5) => (e5[e5.TogglePopover = 0] = "TogglePopover", e5[e5.ClosePopover = 1] = "ClosePopover", e5[e5.SetButton = 2] = "SetButton", e5[e5.SetButtonId = 3] = "SetButtonId", e5[e5.SetPanel = 4] = "SetPanel", e5[e5.SetPanelId = 5] = "SetPanelId", e5))(He3 || {});
var Ge3 = { [0]: (t19) => {
  let o14 = { ...t19, popoverState: u(t19.popoverState, { [0]: 1, [1]: 0 }) };
  return o14.popoverState === 0 && (o14.__demoMode = false), o14;
}, [1](t19) {
  return t19.popoverState === 1 ? t19 : { ...t19, popoverState: 1 };
}, [2](t19, o14) {
  return t19.button === o14.button ? t19 : { ...t19, button: o14.button };
}, [3](t19, o14) {
  return t19.buttonId === o14.buttonId ? t19 : { ...t19, buttonId: o14.buttonId };
}, [4](t19, o14) {
  return t19.panel === o14.panel ? t19 : { ...t19, panel: o14.panel };
}, [5](t19, o14) {
  return t19.panelId === o14.panelId ? t19 : { ...t19, panelId: o14.panelId };
} };
var ue3 = (0, import_react36.createContext)(null);
ue3.displayName = "PopoverContext";
function oe2(t19) {
  let o14 = (0, import_react36.useContext)(ue3);
  if (o14 === null) {
    let u14 = new Error(`<${t19} /> is missing a parent <Popover /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(u14, oe2), u14;
  }
  return o14;
}
var ie3 = (0, import_react36.createContext)(null);
ie3.displayName = "PopoverAPIContext";
function fe2(t19) {
  let o14 = (0, import_react36.useContext)(ie3);
  if (o14 === null) {
    let u14 = new Error(`<${t19} /> is missing a parent <Popover /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(u14, fe2), u14;
  }
  return o14;
}
var Pe4 = (0, import_react36.createContext)(null);
Pe4.displayName = "PopoverGroupContext";
function Ee3() {
  return (0, import_react36.useContext)(Pe4);
}
var re2 = (0, import_react36.createContext)(null);
re2.displayName = "PopoverPanelContext";
function Ne3() {
  return (0, import_react36.useContext)(re2);
}
function ke(t19, o14) {
  return u(o14.type, Ge3, t19, o14);
}
var we2 = "div";
function Ue2(t19, o14) {
  var B5;
  let { __demoMode: u14 = false, ...M8 } = t19, x5 = (0, import_react36.useRef)(null), n8 = y3(o14, T4((l14) => {
    x5.current = l14;
  })), e5 = (0, import_react36.useRef)([]), c14 = (0, import_react36.useReducer)(ke, { __demoMode: u14, popoverState: u14 ? 0 : 1, buttons: e5, button: null, buttonId: null, panel: null, panelId: null, beforePanelSentinel: (0, import_react36.createRef)(), afterPanelSentinel: (0, import_react36.createRef)() }), [{ popoverState: f15, button: s18, buttonId: I12, panel: a11, panelId: v7, beforePanelSentinel: y8, afterPanelSentinel: A4 }, P6] = c14, p8 = n2((B5 = x5.current) != null ? B5 : s18), E9 = (0, import_react36.useMemo)(() => {
    if (!s18 || !a11)
      return false;
    for (let W2 of document.querySelectorAll("body > *"))
      if (Number(W2 == null ? void 0 : W2.contains(s18)) ^ Number(W2 == null ? void 0 : W2.contains(a11)))
        return true;
    let l14 = f2(), S11 = l14.indexOf(s18), q7 = (S11 + l14.length - 1) % l14.length, U8 = (S11 + 1) % l14.length, z5 = l14[q7], be4 = l14[U8];
    return !a11.contains(z5) && !a11.contains(be4);
  }, [s18, a11]), F11 = s2(I12), D8 = s2(v7), _5 = (0, import_react36.useMemo)(() => ({ buttonId: F11, panelId: D8, close: () => P6({ type: 1 }) }), [F11, D8, P6]), O5 = Ee3(), L3 = O5 == null ? void 0 : O5.registerPopover, $7 = o2(() => {
    var l14;
    return (l14 = O5 == null ? void 0 : O5.isFocusWithinPopoverGroup()) != null ? l14 : (p8 == null ? void 0 : p8.activeElement) && ((s18 == null ? void 0 : s18.contains(p8.activeElement)) || (a11 == null ? void 0 : a11.contains(p8.activeElement)));
  });
  (0, import_react36.useEffect)(() => L3 == null ? void 0 : L3(_5), [L3, _5]);
  let [i9, b8] = ee2(), T8 = N4({ mainTreeNodeRef: O5 == null ? void 0 : O5.mainTreeNodeRef, portals: i9, defaultContainers: [s18, a11] });
  E3(p8 == null ? void 0 : p8.defaultView, "focus", (l14) => {
    var S11, q7, U8, z5;
    l14.target !== window && l14.target instanceof HTMLElement && f15 === 0 && ($7() || s18 && a11 && (T8.contains(l14.target) || (q7 = (S11 = y8.current) == null ? void 0 : S11.contains) != null && q7.call(S11, l14.target) || (z5 = (U8 = A4.current) == null ? void 0 : U8.contains) != null && z5.call(U8, l14.target) || P6({ type: 1 })));
  }, true), y2(T8.resolveContainers, (l14, S11) => {
    P6({ type: 1 }), h(S11, T2.Loose) || (l14.preventDefault(), s18 == null || s18.focus());
  }, f15 === 0);
  let d17 = o2((l14) => {
    P6({ type: 1 });
    let S11 = (() => l14 ? l14 instanceof HTMLElement ? l14 : "current" in l14 && l14.current instanceof HTMLElement ? l14.current : s18 : s18)();
    S11 == null || S11.focus();
  }), r10 = (0, import_react36.useMemo)(() => ({ close: d17, isPortalled: E9 }), [d17, E9]), m13 = (0, import_react36.useMemo)(() => ({ open: f15 === 0, close: d17 }), [f15, d17]), g6 = { ref: n8 };
  return import_react36.default.createElement(re2.Provider, { value: null }, import_react36.default.createElement(ue3.Provider, { value: c14 }, import_react36.default.createElement(ie3.Provider, { value: r10 }, import_react36.default.createElement(s9, { value: u(f15, { [0]: d5.Open, [1]: d5.Closed }) }, import_react36.default.createElement(b8, null, C({ ourProps: g6, theirProps: M8, slot: m13, defaultTag: we2, name: "Popover" }), import_react36.default.createElement(T8.MainTreeNode, null))))));
}
var We3 = "button";
function Ke3(t19, o14) {
  let u14 = I(), { id: M8 = `headlessui-popover-button-${u14}`, ...x5 } = t19, [n8, e5] = oe2("Popover.Button"), { isPortalled: c14 } = fe2("Popover.Button"), f15 = (0, import_react36.useRef)(null), s18 = `headlessui-focus-sentinel-${I()}`, I12 = Ee3(), a11 = I12 == null ? void 0 : I12.closeOthers, y8 = Ne3() !== null;
  (0, import_react36.useEffect)(() => {
    if (!y8)
      return e5({ type: 3, buttonId: M8 }), () => {
        e5({ type: 3, buttonId: null });
      };
  }, [y8, M8, e5]);
  let [A4] = (0, import_react36.useState)(() => Symbol()), P6 = y3(f15, o14, y8 ? null : (r10) => {
    if (r10)
      n8.buttons.current.push(A4);
    else {
      let m13 = n8.buttons.current.indexOf(A4);
      m13 !== -1 && n8.buttons.current.splice(m13, 1);
    }
    n8.buttons.current.length > 1 && console.warn("You are already using a <Popover.Button /> but only 1 <Popover.Button /> is supported."), r10 && e5({ type: 2, button: r10 });
  }), p8 = y3(f15, o14), E9 = n2(f15), F11 = o2((r10) => {
    var m13, g6, B5;
    if (y8) {
      if (n8.popoverState === 1)
        return;
      switch (r10.key) {
        case o11.Space:
        case o11.Enter:
          r10.preventDefault(), (g6 = (m13 = r10.target).click) == null || g6.call(m13), e5({ type: 1 }), (B5 = n8.button) == null || B5.focus();
          break;
      }
    } else
      switch (r10.key) {
        case o11.Space:
        case o11.Enter:
          r10.preventDefault(), r10.stopPropagation(), n8.popoverState === 1 && (a11 == null || a11(n8.buttonId)), e5({ type: 0 });
          break;
        case o11.Escape:
          if (n8.popoverState !== 0)
            return a11 == null ? void 0 : a11(n8.buttonId);
          if (!f15.current || E9 != null && E9.activeElement && !f15.current.contains(E9.activeElement))
            return;
          r10.preventDefault(), r10.stopPropagation(), e5({ type: 1 });
          break;
      }
  }), D8 = o2((r10) => {
    y8 || r10.key === o11.Space && r10.preventDefault();
  }), _5 = o2((r10) => {
    var m13, g6;
    r2(r10.currentTarget) || t19.disabled || (y8 ? (e5({ type: 1 }), (m13 = n8.button) == null || m13.focus()) : (r10.preventDefault(), r10.stopPropagation(), n8.popoverState === 1 && (a11 == null || a11(n8.buttonId)), e5({ type: 0 }), (g6 = n8.button) == null || g6.focus()));
  }), O5 = o2((r10) => {
    r10.preventDefault(), r10.stopPropagation();
  }), L3 = n8.popoverState === 0, $7 = (0, import_react36.useMemo)(() => ({ open: L3 }), [L3]), i9 = T3(t19, f15), b8 = y8 ? { ref: p8, type: i9, onKeyDown: F11, onClick: _5 } : { ref: P6, id: n8.buttonId, type: i9, "aria-expanded": n8.popoverState === 0, "aria-controls": n8.panel ? n8.panelId : void 0, onKeyDown: F11, onKeyUp: D8, onClick: _5, onMouseDown: O5 }, T8 = n5(), d17 = o2(() => {
    let r10 = n8.panel;
    if (!r10)
      return;
    function m13() {
      u(T8.current, { [s10.Forwards]: () => O(r10, M.First), [s10.Backwards]: () => O(r10, M.Last) }) === N.Error && O(f2().filter((B5) => B5.dataset.headlessuiFocusGuard !== "true"), u(T8.current, { [s10.Forwards]: M.Next, [s10.Backwards]: M.Previous }), { relativeTo: n8.button });
    }
    m13();
  });
  return import_react36.default.createElement(import_react36.default.Fragment, null, C({ ourProps: b8, theirProps: x5, slot: $7, defaultTag: We3, name: "Popover.Button" }), L3 && !y8 && c14 && import_react36.default.createElement(u4, { id: s18, features: s8.Focusable, "data-headlessui-focus-guard": true, as: "button", type: "button", onFocus: d17 }));
}
var je3 = "div";
var Ve4 = O2.RenderStrategy | O2.Static;
function $e4(t19, o14) {
  let u14 = I(), { id: M8 = `headlessui-popover-overlay-${u14}`, ...x5 } = t19, [{ popoverState: n8 }, e5] = oe2("Popover.Overlay"), c14 = y3(o14), f15 = u5(), s18 = (() => f15 !== null ? (f15 & d5.Open) === d5.Open : n8 === 0)(), I12 = o2((y8) => {
    if (r2(y8.currentTarget))
      return y8.preventDefault();
    e5({ type: 1 });
  }), a11 = (0, import_react36.useMemo)(() => ({ open: n8 === 0 }), [n8]);
  return C({ ourProps: { ref: c14, id: M8, "aria-hidden": true, onClick: I12 }, theirProps: x5, slot: a11, defaultTag: je3, features: Ve4, visible: s18, name: "Popover.Overlay" });
}
var Je3 = "div";
var Xe3 = O2.RenderStrategy | O2.Static;
function Ye4(t19, o14) {
  let u14 = I(), { id: M8 = `headlessui-popover-panel-${u14}`, focus: x5 = false, ...n8 } = t19, [e5, c14] = oe2("Popover.Panel"), { close: f15, isPortalled: s18 } = fe2("Popover.Panel"), I12 = `headlessui-focus-sentinel-before-${I()}`, a11 = `headlessui-focus-sentinel-after-${I()}`, v7 = (0, import_react36.useRef)(null), y8 = y3(v7, o14, (i9) => {
    c14({ type: 4, panel: i9 });
  }), A4 = n2(v7), P6 = I3();
  l(() => (c14({ type: 5, panelId: M8 }), () => {
    c14({ type: 5, panelId: null });
  }), [M8, c14]);
  let p8 = u5(), E9 = (() => p8 !== null ? (p8 & d5.Open) === d5.Open : e5.popoverState === 0)(), F11 = o2((i9) => {
    var b8;
    switch (i9.key) {
      case o11.Escape:
        if (e5.popoverState !== 0 || !v7.current || A4 != null && A4.activeElement && !v7.current.contains(A4.activeElement))
          return;
        i9.preventDefault(), i9.stopPropagation(), c14({ type: 1 }), (b8 = e5.button) == null || b8.focus();
        break;
    }
  });
  (0, import_react36.useEffect)(() => {
    var i9;
    t19.static || e5.popoverState === 1 && ((i9 = t19.unmount) == null || i9) && c14({ type: 4, panel: null });
  }, [e5.popoverState, t19.unmount, t19.static, c14]), (0, import_react36.useEffect)(() => {
    if (e5.__demoMode || !x5 || e5.popoverState !== 0 || !v7.current)
      return;
    let i9 = A4 == null ? void 0 : A4.activeElement;
    v7.current.contains(i9) || O(v7.current, M.First);
  }, [e5.__demoMode, x5, v7, e5.popoverState]);
  let D8 = (0, import_react36.useMemo)(() => ({ open: e5.popoverState === 0, close: f15 }), [e5, f15]), _5 = { ref: y8, id: M8, onKeyDown: F11, onBlur: x5 && e5.popoverState === 0 ? (i9) => {
    var T8, d17, r10, m13, g6;
    let b8 = i9.relatedTarget;
    b8 && v7.current && ((T8 = v7.current) != null && T8.contains(b8) || (c14({ type: 1 }), ((r10 = (d17 = e5.beforePanelSentinel.current) == null ? void 0 : d17.contains) != null && r10.call(d17, b8) || (g6 = (m13 = e5.afterPanelSentinel.current) == null ? void 0 : m13.contains) != null && g6.call(m13, b8)) && b8.focus({ preventScroll: true })));
  } : void 0, tabIndex: -1 }, O5 = n5(), L3 = o2(() => {
    let i9 = v7.current;
    if (!i9)
      return;
    function b8() {
      u(O5.current, { [s10.Forwards]: () => {
        var d17;
        O(i9, M.First) === N.Error && ((d17 = e5.afterPanelSentinel.current) == null || d17.focus());
      }, [s10.Backwards]: () => {
        var T8;
        (T8 = e5.button) == null || T8.focus({ preventScroll: true });
      } });
    }
    b8();
  }), $7 = o2(() => {
    let i9 = v7.current;
    if (!i9)
      return;
    function b8() {
      u(O5.current, { [s10.Forwards]: () => {
        var B5;
        if (!e5.button)
          return;
        let T8 = f2(), d17 = T8.indexOf(e5.button), r10 = T8.slice(0, d17 + 1), g6 = [...T8.slice(d17 + 1), ...r10];
        for (let l14 of g6.slice())
          if (l14.dataset.headlessuiFocusGuard === "true" || (B5 = e5.panel) != null && B5.contains(l14)) {
            let S11 = g6.indexOf(l14);
            S11 !== -1 && g6.splice(S11, 1);
          }
        O(g6, M.First, { sorted: false });
      }, [s10.Backwards]: () => {
        var d17;
        O(i9, M.Previous) === N.Error && ((d17 = e5.button) == null || d17.focus());
      } });
    }
    b8();
  });
  return import_react36.default.createElement(re2.Provider, { value: M8 }, E9 && s18 && import_react36.default.createElement(u4, { id: I12, ref: e5.beforePanelSentinel, features: s8.Focusable, "data-headlessui-focus-guard": true, as: "button", type: "button", onFocus: L3 }), C({ mergeRefs: P6, ourProps: _5, theirProps: n8, slot: D8, defaultTag: Je3, features: Xe3, visible: E9, name: "Popover.Panel" }), E9 && s18 && import_react36.default.createElement(u4, { id: a11, ref: e5.afterPanelSentinel, features: s8.Focusable, "data-headlessui-focus-guard": true, as: "button", type: "button", onFocus: $7 }));
}
var qe5 = "div";
function ze4(t19, o14) {
  let u14 = (0, import_react36.useRef)(null), M8 = y3(u14, o14), [x5, n8] = (0, import_react36.useState)([]), e5 = y5(), c14 = o2((P6) => {
    n8((p8) => {
      let E9 = p8.indexOf(P6);
      if (E9 !== -1) {
        let F11 = p8.slice();
        return F11.splice(E9, 1), F11;
      }
      return p8;
    });
  }), f15 = o2((P6) => (n8((p8) => [...p8, P6]), () => c14(P6))), s18 = o2(() => {
    var E9;
    let P6 = o7(u14);
    if (!P6)
      return false;
    let p8 = P6.activeElement;
    return (E9 = u14.current) != null && E9.contains(p8) ? true : x5.some((F11) => {
      var D8, _5;
      return ((D8 = P6.getElementById(F11.buttonId.current)) == null ? void 0 : D8.contains(p8)) || ((_5 = P6.getElementById(F11.panelId.current)) == null ? void 0 : _5.contains(p8));
    });
  }), I12 = o2((P6) => {
    for (let p8 of x5)
      p8.buttonId.current !== P6 && p8.close();
  }), a11 = (0, import_react36.useMemo)(() => ({ registerPopover: f15, unregisterPopover: c14, isFocusWithinPopoverGroup: s18, closeOthers: I12, mainTreeNodeRef: e5.mainTreeNodeRef }), [f15, c14, s18, I12, e5.mainTreeNodeRef]), v7 = (0, import_react36.useMemo)(() => ({}), []), y8 = t19, A4 = { ref: M8 };
  return import_react36.default.createElement(Pe4.Provider, { value: a11 }, C({ ourProps: A4, theirProps: y8, slot: v7, defaultTag: qe5, name: "Popover.Group" }), import_react36.default.createElement(e5.MainTreeNode, null));
}
var Qe4 = U(Ue2);
var Ze4 = U(Ke3);
var et4 = U($e4);
var tt4 = U(Ye4);
var ot3 = U(ze4);
var Ct = Object.assign(Qe4, { Button: Ze4, Overlay: et4, Panel: tt4, Group: ot3 });

// node_modules/@headlessui/react/dist/components/radio-group/radio-group.js
var import_react39 = __toESM(require_react(), 1);

// node_modules/@headlessui/react/dist/components/label/label.js
var import_react37 = __toESM(require_react(), 1);
var d14 = (0, import_react37.createContext)(null);
function u12() {
  let a11 = (0, import_react37.useContext)(d14);
  if (a11 === null) {
    let t19 = new Error("You used a <Label /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(t19, u12), t19;
  }
  return a11;
}
function F6() {
  let [a11, t19] = (0, import_react37.useState)([]);
  return [a11.length > 0 ? a11.join(" ") : void 0, (0, import_react37.useMemo)(() => function(e5) {
    let s18 = o2((r10) => (t19((l14) => [...l14, r10]), () => t19((l14) => {
      let n8 = l14.slice(), p8 = n8.indexOf(r10);
      return p8 !== -1 && n8.splice(p8, 1), n8;
    }))), o14 = (0, import_react37.useMemo)(() => ({ register: s18, slot: e5.slot, name: e5.name, props: e5.props }), [s18, e5.slot, e5.name, e5.props]);
    return import_react37.default.createElement(d14.Provider, { value: o14 }, e5.children);
  }, [t19])];
}
var A = "label";
function h8(a11, t19) {
  let i9 = I(), { id: e5 = `headlessui-label-${i9}`, passive: s18 = false, ...o14 } = a11, r10 = u12(), l14 = y3(t19);
  l(() => r10.register(e5), [e5, r10.register]);
  let n8 = { ref: l14, ...r10.props, id: e5 };
  return s18 && ("onClick" in n8 && (delete n8.htmlFor, delete n8.onClick), "onClick" in o14 && delete o14.onClick), C({ ourProps: n8, theirProps: o14, slot: r10.slot || {}, defaultTag: A, name: r10.name || "Label" });
}
var v4 = U(h8);
var B2 = Object.assign(v4, {});

// node_modules/@headlessui/react/dist/hooks/use-flags.js
var import_react38 = __toESM(require_react(), 1);
function c10(a11 = 0) {
  let [l14, r10] = (0, import_react38.useState)(a11), t19 = f7(), o14 = (0, import_react38.useCallback)((e5) => {
    t19.current && r10((u14) => u14 | e5);
  }, [l14, t19]), m13 = (0, import_react38.useCallback)((e5) => Boolean(l14 & e5), [l14]), s18 = (0, import_react38.useCallback)((e5) => {
    t19.current && r10((u14) => u14 & ~e5);
  }, [r10, t19]), g6 = (0, import_react38.useCallback)((e5) => {
    t19.current && r10((u14) => u14 ^ e5);
  }, [r10]);
  return { flags: l14, addFlag: o14, hasFlag: m13, removeFlag: s18, toggleFlag: g6 };
}

// node_modules/@headlessui/react/dist/components/radio-group/radio-group.js
var Ge4 = ((t19) => (t19[t19.RegisterOption = 0] = "RegisterOption", t19[t19.UnregisterOption = 1] = "UnregisterOption", t19))(Ge4 || {});
var Ce2 = { [0](o14, r10) {
  let t19 = [...o14.options, { id: r10.id, element: r10.element, propsRef: r10.propsRef }];
  return { ...o14, options: I2(t19, (p8) => p8.element.current) };
}, [1](o14, r10) {
  let t19 = o14.options.slice(), p8 = o14.options.findIndex((T8) => T8.id === r10.id);
  return p8 === -1 ? o14 : (t19.splice(p8, 1), { ...o14, options: t19 });
} };
var B3 = (0, import_react39.createContext)(null);
B3.displayName = "RadioGroupDataContext";
function oe3(o14) {
  let r10 = (0, import_react39.useContext)(B3);
  if (r10 === null) {
    let t19 = new Error(`<${o14} /> is missing a parent <RadioGroup /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(t19, oe3), t19;
  }
  return r10;
}
var $3 = (0, import_react39.createContext)(null);
$3.displayName = "RadioGroupActionsContext";
function ne2(o14) {
  let r10 = (0, import_react39.useContext)($3);
  if (r10 === null) {
    let t19 = new Error(`<${o14} /> is missing a parent <RadioGroup /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(t19, ne2), t19;
  }
  return r10;
}
function ke2(o14, r10) {
  return u(r10.type, Ce2, o14, r10);
}
var Le2 = "div";
function he3(o14, r10) {
  let t19 = I(), { id: p8 = `headlessui-radiogroup-${t19}`, value: T8, defaultValue: v7, form: M8, name: m13, onChange: H7, by: G5 = (e5, i9) => e5 === i9, disabled: P6 = false, ...N8 } = o14, y8 = o2(typeof G5 == "string" ? (e5, i9) => {
    let n8 = G5;
    return (e5 == null ? void 0 : e5[n8]) === (i9 == null ? void 0 : i9[n8]);
  } : G5), [A4, L3] = (0, import_react39.useReducer)(ke2, { options: [] }), a11 = A4.options, [h10, R5] = F6(), [C8, U8] = w3(), k4 = (0, import_react39.useRef)(null), W2 = y3(k4, r10), [l14, s18] = T(T8, H7, v7), b8 = (0, import_react39.useMemo)(() => a11.find((e5) => !e5.propsRef.current.disabled), [a11]), x5 = (0, import_react39.useMemo)(() => a11.some((e5) => y8(e5.propsRef.current.value, l14)), [a11, l14]), d17 = o2((e5) => {
    var n8;
    if (P6 || y8(e5, l14))
      return false;
    let i9 = (n8 = a11.find((f15) => y8(f15.propsRef.current.value, e5))) == null ? void 0 : n8.propsRef.current;
    return i9 != null && i9.disabled ? false : (s18 == null || s18(e5), true);
  });
  F2({ container: k4.current, accept(e5) {
    return e5.getAttribute("role") === "radio" ? NodeFilter.FILTER_REJECT : e5.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(e5) {
    e5.setAttribute("role", "none");
  } });
  let F11 = o2((e5) => {
    let i9 = k4.current;
    if (!i9)
      return;
    let n8 = o7(i9), f15 = a11.filter((u14) => u14.propsRef.current.disabled === false).map((u14) => u14.element.current);
    switch (e5.key) {
      case o11.Enter:
        p4(e5.currentTarget);
        break;
      case o11.ArrowLeft:
      case o11.ArrowUp:
        if (e5.preventDefault(), e5.stopPropagation(), O(f15, M.Previous | M.WrapAround) === N.Success) {
          let g6 = a11.find((K5) => K5.element.current === (n8 == null ? void 0 : n8.activeElement));
          g6 && d17(g6.propsRef.current.value);
        }
        break;
      case o11.ArrowRight:
      case o11.ArrowDown:
        if (e5.preventDefault(), e5.stopPropagation(), O(f15, M.Next | M.WrapAround) === N.Success) {
          let g6 = a11.find((K5) => K5.element.current === (n8 == null ? void 0 : n8.activeElement));
          g6 && d17(g6.propsRef.current.value);
        }
        break;
      case o11.Space:
        {
          e5.preventDefault(), e5.stopPropagation();
          let u14 = a11.find((g6) => g6.element.current === (n8 == null ? void 0 : n8.activeElement));
          u14 && d17(u14.propsRef.current.value);
        }
        break;
    }
  }), c14 = o2((e5) => (L3({ type: 0, ...e5 }), () => L3({ type: 1, id: e5.id }))), w7 = (0, import_react39.useMemo)(() => ({ value: l14, firstOption: b8, containsCheckedOption: x5, disabled: P6, compare: y8, ...A4 }), [l14, b8, x5, P6, y8, A4]), ie5 = (0, import_react39.useMemo)(() => ({ registerOption: c14, change: d17 }), [c14, d17]), ae3 = { ref: W2, id: p8, role: "radiogroup", "aria-labelledby": h10, "aria-describedby": C8, onKeyDown: F11 }, pe2 = (0, import_react39.useMemo)(() => ({ value: l14 }), [l14]), I12 = (0, import_react39.useRef)(null), le3 = p();
  return (0, import_react39.useEffect)(() => {
    I12.current && v7 !== void 0 && le3.addEventListener(I12.current, "reset", () => {
      d17(v7);
    });
  }, [I12, d17]), import_react39.default.createElement(U8, { name: "RadioGroup.Description" }, import_react39.default.createElement(R5, { name: "RadioGroup.Label" }, import_react39.default.createElement($3.Provider, { value: ie5 }, import_react39.default.createElement(B3.Provider, { value: w7 }, m13 != null && l14 != null && e({ [m13]: l14 }).map(([e5, i9], n8) => import_react39.default.createElement(u4, { features: s8.Hidden, ref: n8 === 0 ? (f15) => {
    var u14;
    I12.current = (u14 = f15 == null ? void 0 : f15.closest("form")) != null ? u14 : null;
  } : void 0, ...x({ key: e5, as: "input", type: "radio", checked: i9 != null, hidden: true, readOnly: true, form: M8, disabled: P6, name: e5, value: i9 }) })), C({ ourProps: ae3, theirProps: N8, slot: pe2, defaultTag: Le2, name: "RadioGroup" })))));
}
var xe3 = ((t19) => (t19[t19.Empty = 1] = "Empty", t19[t19.Active = 2] = "Active", t19))(xe3 || {});
var Fe2 = "div";
function we3(o14, r10) {
  var F11;
  let t19 = I(), { id: p8 = `headlessui-radiogroup-option-${t19}`, value: T8, disabled: v7 = false, ...M8 } = o14, m13 = (0, import_react39.useRef)(null), H7 = y3(m13, r10), [G5, P6] = F6(), [N8, y8] = w3(), { addFlag: A4, removeFlag: L3, hasFlag: a11 } = c10(1), h10 = s2({ value: T8, disabled: v7 }), R5 = oe3("RadioGroup.Option"), C8 = ne2("RadioGroup.Option");
  l(() => C8.registerOption({ id: p8, element: m13, propsRef: h10 }), [p8, C8, m13, h10]);
  let U8 = o2((c14) => {
    var w7;
    if (r2(c14.currentTarget))
      return c14.preventDefault();
    C8.change(T8) && (A4(2), (w7 = m13.current) == null || w7.focus());
  }), k4 = o2((c14) => {
    if (r2(c14.currentTarget))
      return c14.preventDefault();
    A4(2);
  }), W2 = o2(() => L3(2)), l14 = ((F11 = R5.firstOption) == null ? void 0 : F11.id) === p8, s18 = R5.disabled || v7, b8 = R5.compare(R5.value, T8), x5 = { ref: H7, id: p8, role: "radio", "aria-checked": b8 ? "true" : "false", "aria-labelledby": G5, "aria-describedby": N8, "aria-disabled": s18 ? true : void 0, tabIndex: (() => s18 ? -1 : b8 || !R5.containsCheckedOption && l14 ? 0 : -1)(), onClick: s18 ? void 0 : U8, onFocus: s18 ? void 0 : k4, onBlur: s18 ? void 0 : W2 }, d17 = (0, import_react39.useMemo)(() => ({ checked: b8, disabled: s18, active: a11(2) }), [b8, s18, a11]);
  return import_react39.default.createElement(y8, { name: "RadioGroup.Description" }, import_react39.default.createElement(P6, { name: "RadioGroup.Label" }, C({ ourProps: x5, theirProps: M8, slot: d17, defaultTag: Fe2, name: "RadioGroup.Option" })));
}
var Ie3 = U(he3);
var Se2 = U(we3);
var it3 = Object.assign(Ie3, { Option: Se2, Label: B2, Description: G });

// node_modules/@headlessui/react/dist/components/switch/switch.js
var import_react40 = __toESM(require_react(), 1);
var S8 = (0, import_react40.createContext)(null);
S8.displayName = "GroupContext";
var ee6 = import_react40.Fragment;
function te4(r10) {
  var u14;
  let [n8, p8] = (0, import_react40.useState)(null), [c14, T8] = F6(), [o14, b8] = w3(), a11 = (0, import_react40.useMemo)(() => ({ switch: n8, setSwitch: p8, labelledby: c14, describedby: o14 }), [n8, p8, c14, o14]), d17 = {}, y8 = r10;
  return import_react40.default.createElement(b8, { name: "Switch.Description" }, import_react40.default.createElement(T8, { name: "Switch.Label", props: { htmlFor: (u14 = a11.switch) == null ? void 0 : u14.id, onClick(m13) {
    n8 && (m13.currentTarget.tagName === "LABEL" && m13.preventDefault(), n8.click(), n8.focus({ preventScroll: true }));
  } } }, import_react40.default.createElement(S8.Provider, { value: a11 }, C({ ourProps: d17, theirProps: y8, defaultTag: ee6, name: "Switch.Group" }))));
}
var ne3 = "button";
function re3(r10, n8) {
  var E9;
  let p8 = I(), { id: c14 = `headlessui-switch-${p8}`, checked: T8, defaultChecked: o14 = false, onChange: b8, disabled: a11 = false, name: d17, value: y8, form: u14, ...m13 } = r10, t19 = (0, import_react40.useContext)(S8), f15 = (0, import_react40.useRef)(null), C8 = y3(f15, n8, t19 === null ? null : t19.setSwitch), [i9, s18] = T(T8, b8, o14), w7 = o2(() => s18 == null ? void 0 : s18(!i9)), L3 = o2((e5) => {
    if (r2(e5.currentTarget))
      return e5.preventDefault();
    e5.preventDefault(), w7();
  }), x5 = o2((e5) => {
    e5.key === o11.Space ? (e5.preventDefault(), w7()) : e5.key === o11.Enter && p4(e5.currentTarget);
  }), v7 = o2((e5) => e5.preventDefault()), G5 = (0, import_react40.useMemo)(() => ({ checked: i9 }), [i9]), R5 = { id: c14, ref: C8, role: "switch", type: T3(r10, f15), tabIndex: r10.tabIndex === -1 ? 0 : (E9 = r10.tabIndex) != null ? E9 : 0, "aria-checked": i9, "aria-labelledby": t19 == null ? void 0 : t19.labelledby, "aria-describedby": t19 == null ? void 0 : t19.describedby, disabled: a11, onClick: L3, onKeyUp: x5, onKeyPress: v7 }, k4 = p();
  return (0, import_react40.useEffect)(() => {
    var _5;
    let e5 = (_5 = f15.current) == null ? void 0 : _5.closest("form");
    e5 && o14 !== void 0 && k4.addEventListener(e5, "reset", () => {
      s18(o14);
    });
  }, [f15, s18]), import_react40.default.createElement(import_react40.default.Fragment, null, d17 != null && i9 && import_react40.default.createElement(u4, { features: s8.Hidden, ...x({ as: "input", type: "checkbox", hidden: true, readOnly: true, disabled: a11, form: u14, checked: i9, name: d17, value: y8 }) }), C({ ourProps: R5, theirProps: m13, slot: G5, defaultTag: ne3, name: "Switch" }));
}
var oe4 = U(re3);
var ie4 = te4;
var _e2 = Object.assign(oe4, { Group: ie4, Label: B2, Description: G });

// node_modules/@headlessui/react/dist/components/tabs/tabs.js
var import_react42 = __toESM(require_react(), 1);

// node_modules/@headlessui/react/dist/internal/focus-sentinel.js
var import_react41 = __toESM(require_react(), 1);
function b5({ onFocus: n8 }) {
  let [r10, o14] = (0, import_react41.useState)(true), u14 = f7();
  return r10 ? import_react41.default.createElement(u4, { as: "button", type: "button", features: s8.Focusable, onFocus: (a11) => {
    a11.preventDefault();
    let e5, i9 = 50;
    function t19() {
      if (i9-- <= 0) {
        e5 && cancelAnimationFrame(e5);
        return;
      }
      if (n8()) {
        if (cancelAnimationFrame(e5), !u14.current)
          return;
        o14(false);
        return;
      }
      e5 = requestAnimationFrame(t19);
    }
    e5 = requestAnimationFrame(t19);
  } }) : null;
}

// node_modules/@headlessui/react/dist/utils/stable-collection.js
var r8 = __toESM(require_react(), 1);
var s16 = r8.createContext(null);
function a9() {
  return { groups: /* @__PURE__ */ new Map(), get(n8, t19) {
    var c14;
    let e5 = this.groups.get(n8);
    e5 || (e5 = /* @__PURE__ */ new Map(), this.groups.set(n8, e5));
    let l14 = (c14 = e5.get(t19)) != null ? c14 : 0;
    e5.set(t19, l14 + 1);
    let o14 = Array.from(e5.keys()).indexOf(t19);
    function i9() {
      let u14 = e5.get(t19);
      u14 > 1 ? e5.set(t19, u14 - 1) : e5.delete(t19);
    }
    return [o14, i9];
  } };
}
function C5({ children: n8 }) {
  let t19 = r8.useRef(a9());
  return r8.createElement(s16.Provider, { value: t19 }, n8);
}
function d15(n8) {
  let t19 = r8.useContext(s16);
  if (!t19)
    throw new Error("You must wrap your component in a <StableCollection>");
  let e5 = f13(), [l14, o14] = t19.current.get(n8, e5);
  return r8.useEffect(() => o14, []), l14;
}
function f13() {
  var l14, o14, i9;
  let n8 = (i9 = (o14 = (l14 = r8.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) == null ? void 0 : l14.ReactCurrentOwner) == null ? void 0 : o14.current) != null ? i9 : null;
  if (!n8)
    return Symbol();
  let t19 = [], e5 = n8;
  for (; e5; )
    t19.push(e5.index), e5 = e5.return;
  return "$." + t19.join(".");
}

// node_modules/@headlessui/react/dist/components/tabs/tabs.js
var ue5 = ((t19) => (t19[t19.Forwards = 0] = "Forwards", t19[t19.Backwards = 1] = "Backwards", t19))(ue5 || {});
var Te2 = ((l14) => (l14[l14.Less = -1] = "Less", l14[l14.Equal = 0] = "Equal", l14[l14.Greater = 1] = "Greater", l14))(Te2 || {});
var de5 = ((a11) => (a11[a11.SetSelectedIndex = 0] = "SetSelectedIndex", a11[a11.RegisterTab = 1] = "RegisterTab", a11[a11.UnregisterTab = 2] = "UnregisterTab", a11[a11.RegisterPanel = 3] = "RegisterPanel", a11[a11.UnregisterPanel = 4] = "UnregisterPanel", a11))(de5 || {});
var ce3 = { [0](e5, n8) {
  var i9;
  let t19 = I2(e5.tabs, (c14) => c14.current), l14 = I2(e5.panels, (c14) => c14.current), o14 = t19.filter((c14) => {
    var p8;
    return !((p8 = c14.current) != null && p8.hasAttribute("disabled"));
  }), a11 = { ...e5, tabs: t19, panels: l14 };
  if (n8.index < 0 || n8.index > t19.length - 1) {
    let c14 = u(Math.sign(n8.index - e5.selectedIndex), { [-1]: () => 1, [0]: () => u(Math.sign(n8.index), { [-1]: () => 0, [0]: () => 0, [1]: () => 1 }), [1]: () => 0 });
    if (o14.length === 0)
      return a11;
    let p8 = u(c14, { [0]: () => t19.indexOf(o14[0]), [1]: () => t19.indexOf(o14[o14.length - 1]) });
    return { ...a11, selectedIndex: p8 === -1 ? e5.selectedIndex : p8 };
  }
  let T8 = t19.slice(0, n8.index), m13 = [...t19.slice(n8.index), ...T8].find((c14) => o14.includes(c14));
  if (!m13)
    return a11;
  let b8 = (i9 = t19.indexOf(m13)) != null ? i9 : e5.selectedIndex;
  return b8 === -1 && (b8 = e5.selectedIndex), { ...a11, selectedIndex: b8 };
}, [1](e5, n8) {
  if (e5.tabs.includes(n8.tab))
    return e5;
  let t19 = e5.tabs[e5.selectedIndex], l14 = I2([...e5.tabs, n8.tab], (a11) => a11.current), o14 = e5.selectedIndex;
  return e5.info.current.isControlled || (o14 = l14.indexOf(t19), o14 === -1 && (o14 = e5.selectedIndex)), { ...e5, tabs: l14, selectedIndex: o14 };
}, [2](e5, n8) {
  return { ...e5, tabs: e5.tabs.filter((t19) => t19 !== n8.tab) };
}, [3](e5, n8) {
  return e5.panels.includes(n8.panel) ? e5 : { ...e5, panels: I2([...e5.panels, n8.panel], (t19) => t19.current) };
}, [4](e5, n8) {
  return { ...e5, panels: e5.panels.filter((t19) => t19 !== n8.panel) };
} };
var X3 = (0, import_react42.createContext)(null);
X3.displayName = "TabsDataContext";
function F8(e5) {
  let n8 = (0, import_react42.useContext)(X3);
  if (n8 === null) {
    let t19 = new Error(`<${e5} /> is missing a parent <Tab.Group /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(t19, F8), t19;
  }
  return n8;
}
var $4 = (0, import_react42.createContext)(null);
$4.displayName = "TabsActionsContext";
function q4(e5) {
  let n8 = (0, import_react42.useContext)($4);
  if (n8 === null) {
    let t19 = new Error(`<${e5} /> is missing a parent <Tab.Group /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(t19, q4), t19;
  }
  return n8;
}
function fe3(e5, n8) {
  return u(n8.type, ce3, e5, n8);
}
var be3 = import_react42.Fragment;
function me3(e5, n8) {
  let { defaultIndex: t19 = 0, vertical: l14 = false, manual: o14 = false, onChange: a11, selectedIndex: T8 = null, ...R5 } = e5;
  const m13 = l14 ? "vertical" : "horizontal", b8 = o14 ? "manual" : "auto";
  let i9 = T8 !== null, c14 = s2({ isControlled: i9 }), p8 = y3(n8), [u14, f15] = (0, import_react42.useReducer)(fe3, { info: c14, selectedIndex: T8 != null ? T8 : t19, tabs: [], panels: [] }), P6 = (0, import_react42.useMemo)(() => ({ selectedIndex: u14.selectedIndex }), [u14.selectedIndex]), g6 = s2(a11 || (() => {
  })), E9 = s2(u14.tabs), L3 = (0, import_react42.useMemo)(() => ({ orientation: m13, activation: b8, ...u14 }), [m13, b8, u14]), A4 = o2((s18) => (f15({ type: 1, tab: s18 }), () => f15({ type: 2, tab: s18 }))), S11 = o2((s18) => (f15({ type: 3, panel: s18 }), () => f15({ type: 4, panel: s18 }))), k4 = o2((s18) => {
    h10.current !== s18 && g6.current(s18), i9 || f15({ type: 0, index: s18 });
  }), h10 = s2(i9 ? e5.selectedIndex : u14.selectedIndex), W2 = (0, import_react42.useMemo)(() => ({ registerTab: A4, registerPanel: S11, change: k4 }), []);
  l(() => {
    f15({ type: 0, index: T8 != null ? T8 : t19 });
  }, [T8]), l(() => {
    if (h10.current === void 0 || u14.tabs.length <= 0)
      return;
    let s18 = I2(u14.tabs, (d17) => d17.current);
    s18.some((d17, M8) => u14.tabs[M8] !== d17) && k4(s18.indexOf(u14.tabs[h10.current]));
  });
  let O5 = { ref: p8 };
  return import_react42.default.createElement(C5, null, import_react42.default.createElement($4.Provider, { value: W2 }, import_react42.default.createElement(X3.Provider, { value: L3 }, L3.tabs.length <= 0 && import_react42.default.createElement(b5, { onFocus: () => {
    var s18, r10;
    for (let d17 of E9.current)
      if (((s18 = d17.current) == null ? void 0 : s18.tabIndex) === 0)
        return (r10 = d17.current) == null || r10.focus(), true;
    return false;
  } }), C({ ourProps: O5, theirProps: R5, slot: P6, defaultTag: be3, name: "Tabs" }))));
}
var Pe5 = "div";
function ye4(e5, n8) {
  let { orientation: t19, selectedIndex: l14 } = F8("Tab.List"), o14 = y3(n8);
  return C({ ourProps: { ref: o14, role: "tablist", "aria-orientation": t19 }, theirProps: e5, slot: { selectedIndex: l14 }, defaultTag: Pe5, name: "Tabs.List" });
}
var xe4 = "button";
function ge4(e5, n8) {
  var O5, s18;
  let t19 = I(), { id: l14 = `headlessui-tabs-tab-${t19}`, ...o14 } = e5, { orientation: a11, activation: T8, selectedIndex: R5, tabs: m13, panels: b8 } = F8("Tab"), i9 = q4("Tab"), c14 = F8("Tab"), p8 = (0, import_react42.useRef)(null), u14 = y3(p8, n8);
  l(() => i9.registerTab(p8), [i9, p8]);
  let f15 = d15("tabs"), P6 = m13.indexOf(p8);
  P6 === -1 && (P6 = f15);
  let g6 = P6 === R5, E9 = o2((r10) => {
    var M8;
    let d17 = r10();
    if (d17 === N.Success && T8 === "auto") {
      let K5 = (M8 = o7(p8)) == null ? void 0 : M8.activeElement, z5 = c14.tabs.findIndex((te5) => te5.current === K5);
      z5 !== -1 && i9.change(z5);
    }
    return d17;
  }), L3 = o2((r10) => {
    let d17 = m13.map((K5) => K5.current).filter(Boolean);
    if (r10.key === o11.Space || r10.key === o11.Enter) {
      r10.preventDefault(), r10.stopPropagation(), i9.change(P6);
      return;
    }
    switch (r10.key) {
      case o11.Home:
      case o11.PageUp:
        return r10.preventDefault(), r10.stopPropagation(), E9(() => O(d17, M.First));
      case o11.End:
      case o11.PageDown:
        return r10.preventDefault(), r10.stopPropagation(), E9(() => O(d17, M.Last));
    }
    if (E9(() => u(a11, { vertical() {
      return r10.key === o11.ArrowUp ? O(d17, M.Previous | M.WrapAround) : r10.key === o11.ArrowDown ? O(d17, M.Next | M.WrapAround) : N.Error;
    }, horizontal() {
      return r10.key === o11.ArrowLeft ? O(d17, M.Previous | M.WrapAround) : r10.key === o11.ArrowRight ? O(d17, M.Next | M.WrapAround) : N.Error;
    } })) === N.Success)
      return r10.preventDefault();
  }), A4 = (0, import_react42.useRef)(false), S11 = o2(() => {
    var r10;
    A4.current || (A4.current = true, (r10 = p8.current) == null || r10.focus({ preventScroll: true }), i9.change(P6), t3(() => {
      A4.current = false;
    }));
  }), k4 = o2((r10) => {
    r10.preventDefault();
  }), h10 = (0, import_react42.useMemo)(() => {
    var r10;
    return { selected: g6, disabled: (r10 = e5.disabled) != null ? r10 : false };
  }, [g6, e5.disabled]), W2 = { ref: u14, onKeyDown: L3, onMouseDown: k4, onClick: S11, id: l14, role: "tab", type: T3(e5, p8), "aria-controls": (s18 = (O5 = b8[P6]) == null ? void 0 : O5.current) == null ? void 0 : s18.id, "aria-selected": g6, tabIndex: g6 ? 0 : -1 };
  return C({ ourProps: W2, theirProps: o14, slot: h10, defaultTag: xe4, name: "Tabs.Tab" });
}
var Ee4 = "div";
function Ae4(e5, n8) {
  let { selectedIndex: t19 } = F8("Tab.Panels"), l14 = y3(n8), o14 = (0, import_react42.useMemo)(() => ({ selectedIndex: t19 }), [t19]);
  return C({ ourProps: { ref: l14 }, theirProps: e5, slot: o14, defaultTag: Ee4, name: "Tabs.Panels" });
}
var Re2 = "div";
var Le3 = O2.RenderStrategy | O2.Static;
function _e3(e5, n8) {
  var E9, L3, A4, S11;
  let t19 = I(), { id: l14 = `headlessui-tabs-panel-${t19}`, tabIndex: o14 = 0, ...a11 } = e5, { selectedIndex: T8, tabs: R5, panels: m13 } = F8("Tab.Panel"), b8 = q4("Tab.Panel"), i9 = (0, import_react42.useRef)(null), c14 = y3(i9, n8);
  l(() => b8.registerPanel(i9), [b8, i9, l14]);
  let p8 = d15("panels"), u14 = m13.indexOf(i9);
  u14 === -1 && (u14 = p8);
  let f15 = u14 === T8, P6 = (0, import_react42.useMemo)(() => ({ selected: f15 }), [f15]), g6 = { ref: c14, id: l14, role: "tabpanel", "aria-labelledby": (L3 = (E9 = R5[u14]) == null ? void 0 : E9.current) == null ? void 0 : L3.id, tabIndex: f15 ? o14 : -1 };
  return !f15 && ((A4 = a11.unmount) == null || A4) && !((S11 = a11.static) != null && S11) ? import_react42.default.createElement(u4, { as: "span", "aria-hidden": "true", ...g6 }) : C({ ourProps: g6, theirProps: a11, slot: P6, defaultTag: Re2, features: Le3, visible: f15, name: "Tabs.Panel" });
}
var Se3 = U(ge4);
var Ie4 = U(me3);
var De2 = U(ye4);
var Fe3 = U(Ae4);
var he4 = U(_e3);
var $e5 = Object.assign(Se3, { Group: Ie4, List: De2, Panels: Fe3, Panel: he4 });

// node_modules/@headlessui/react/dist/components/transitions/transition.js
var import_react43 = __toESM(require_react(), 1);

// node_modules/@headlessui/react/dist/utils/once.js
function l12(r10) {
  let e5 = { called: false };
  return (...t19) => {
    if (!e5.called)
      return e5.called = true, r10(...t19);
  };
}

// node_modules/@headlessui/react/dist/components/transitions/utils/transition.js
function g4(t19, ...e5) {
  t19 && e5.length > 0 && t19.classList.add(...e5);
}
function v5(t19, ...e5) {
  t19 && e5.length > 0 && t19.classList.remove(...e5);
}
function b6(t19, e5) {
  let n8 = o4();
  if (!t19)
    return n8.dispose;
  let { transitionDuration: m13, transitionDelay: a11 } = getComputedStyle(t19), [u14, p8] = [m13, a11].map((l14) => {
    let [r10 = 0] = l14.split(",").filter(Boolean).map((i9) => i9.includes("ms") ? parseFloat(i9) : parseFloat(i9) * 1e3).sort((i9, T8) => T8 - i9);
    return r10;
  }), o14 = u14 + p8;
  if (o14 !== 0) {
    n8.group((r10) => {
      r10.setTimeout(() => {
        e5(), r10.dispose();
      }, o14), r10.addEventListener(t19, "transitionrun", (i9) => {
        i9.target === i9.currentTarget && r10.dispose();
      });
    });
    let l14 = n8.addEventListener(t19, "transitionend", (r10) => {
      r10.target === r10.currentTarget && (e5(), l14());
    });
  } else
    e5();
  return n8.add(() => e5()), n8.dispose;
}
function M5(t19, e5, n8, m13) {
  let a11 = n8 ? "enter" : "leave", u14 = o4(), p8 = m13 !== void 0 ? l12(m13) : () => {
  };
  a11 === "enter" && (t19.removeAttribute("hidden"), t19.style.display = "");
  let o14 = u(a11, { enter: () => e5.enter, leave: () => e5.leave }), l14 = u(a11, { enter: () => e5.enterTo, leave: () => e5.leaveTo }), r10 = u(a11, { enter: () => e5.enterFrom, leave: () => e5.leaveFrom });
  return v5(t19, ...e5.base, ...e5.enter, ...e5.enterTo, ...e5.enterFrom, ...e5.leave, ...e5.leaveFrom, ...e5.leaveTo, ...e5.entered), g4(t19, ...e5.base, ...o14, ...r10), u14.nextFrame(() => {
    v5(t19, ...e5.base, ...o14, ...r10), g4(t19, ...e5.base, ...o14, ...l14), b6(t19, () => (v5(t19, ...e5.base, ...o14), g4(t19, ...e5.base, ...e5.entered), p8()));
  }), u14.dispose;
}

// node_modules/@headlessui/react/dist/hooks/use-transition.js
function D6({ immediate: t19, container: s18, direction: n8, classes: u14, onStart: a11, onStop: c14 }) {
  let l14 = f7(), d17 = p(), e5 = s2(n8);
  l(() => {
    t19 && (e5.current = "enter");
  }, [t19]), l(() => {
    let r10 = o4();
    d17.add(r10.dispose);
    let i9 = s18.current;
    if (i9 && e5.current !== "idle" && l14.current)
      return r10.dispose(), a11.current(e5.current), r10.add(M5(i9, u14.current, e5.current === "enter", () => {
        r10.dispose(), c14.current(e5.current);
      })), r10.dispose;
  }, [n8]);
}

// node_modules/@headlessui/react/dist/components/transitions/transition.js
function S9(t19 = "") {
  return t19.split(/\s+/).filter((n8) => n8.length > 1);
}
var I10 = (0, import_react43.createContext)(null);
I10.displayName = "TransitionContext";
var Se4 = ((r10) => (r10.Visible = "visible", r10.Hidden = "hidden", r10))(Se4 || {});
function ye5() {
  let t19 = (0, import_react43.useContext)(I10);
  if (t19 === null)
    throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return t19;
}
function xe5() {
  let t19 = (0, import_react43.useContext)(M6);
  if (t19 === null)
    throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return t19;
}
var M6 = (0, import_react43.createContext)(null);
M6.displayName = "NestingContext";
function U6(t19) {
  return "children" in t19 ? U6(t19.children) : t19.current.filter(({ el: n8 }) => n8.current !== null).filter(({ state: n8 }) => n8 === "visible").length > 0;
}
function se3(t19, n8) {
  let r10 = s2(t19), s18 = (0, import_react43.useRef)([]), R5 = f7(), D8 = p(), p8 = o2((i9, e5 = v.Hidden) => {
    let a11 = s18.current.findIndex(({ el: o14 }) => o14 === i9);
    a11 !== -1 && (u(e5, { [v.Unmount]() {
      s18.current.splice(a11, 1);
    }, [v.Hidden]() {
      s18.current[a11].state = "hidden";
    } }), D8.microTask(() => {
      var o14;
      !U6(s18) && R5.current && ((o14 = r10.current) == null || o14.call(r10));
    }));
  }), x5 = o2((i9) => {
    let e5 = s18.current.find(({ el: a11 }) => a11 === i9);
    return e5 ? e5.state !== "visible" && (e5.state = "visible") : s18.current.push({ el: i9, state: "visible" }), () => p8(i9, v.Unmount);
  }), h10 = (0, import_react43.useRef)([]), v7 = (0, import_react43.useRef)(Promise.resolve()), u14 = (0, import_react43.useRef)({ enter: [], leave: [], idle: [] }), g6 = o2((i9, e5, a11) => {
    h10.current.splice(0), n8 && (n8.chains.current[e5] = n8.chains.current[e5].filter(([o14]) => o14 !== i9)), n8 == null || n8.chains.current[e5].push([i9, new Promise((o14) => {
      h10.current.push(o14);
    })]), n8 == null || n8.chains.current[e5].push([i9, new Promise((o14) => {
      Promise.all(u14.current[e5].map(([f15, N8]) => N8)).then(() => o14());
    })]), e5 === "enter" ? v7.current = v7.current.then(() => n8 == null ? void 0 : n8.wait.current).then(() => a11(e5)) : a11(e5);
  }), d17 = o2((i9, e5, a11) => {
    Promise.all(u14.current[e5].splice(0).map(([o14, f15]) => f15)).then(() => {
      var o14;
      (o14 = h10.current.shift()) == null || o14();
    }).then(() => a11(e5));
  });
  return (0, import_react43.useMemo)(() => ({ children: s18, register: x5, unregister: p8, onStart: g6, onStop: d17, wait: v7, chains: u14 }), [x5, p8, s18, g6, d17, u14, v7]);
}
function Ne4() {
}
var Pe6 = ["beforeEnter", "afterEnter", "beforeLeave", "afterLeave"];
function ae2(t19) {
  var r10;
  let n8 = {};
  for (let s18 of Pe6)
    n8[s18] = (r10 = t19[s18]) != null ? r10 : Ne4;
  return n8;
}
function Re3(t19) {
  let n8 = (0, import_react43.useRef)(ae2(t19));
  return (0, import_react43.useEffect)(() => {
    n8.current = ae2(t19);
  }, [t19]), n8;
}
var De3 = "div";
var le2 = O2.RenderStrategy;
function He4(t19, n8) {
  var Q5, Y4;
  let { beforeEnter: r10, afterEnter: s18, beforeLeave: R5, afterLeave: D8, enter: p8, enterFrom: x5, enterTo: h10, entered: v7, leave: u14, leaveFrom: g6, leaveTo: d17, ...i9 } = t19, e5 = (0, import_react43.useRef)(null), a11 = y3(e5, n8), o14 = (Q5 = i9.unmount) == null || Q5 ? v.Unmount : v.Hidden, { show: f15, appear: N8, initial: T8 } = ye5(), [l14, j6] = (0, import_react43.useState)(f15 ? "visible" : "hidden"), z5 = xe5(), { register: L3, unregister: O5 } = z5;
  (0, import_react43.useEffect)(() => L3(e5), [L3, e5]), (0, import_react43.useEffect)(() => {
    if (o14 === v.Hidden && e5.current) {
      if (f15 && l14 !== "visible") {
        j6("visible");
        return;
      }
      return u(l14, { ["hidden"]: () => O5(e5), ["visible"]: () => L3(e5) });
    }
  }, [l14, e5, L3, O5, f15, o14]);
  let k4 = s2({ base: S9(i9.className), enter: S9(p8), enterFrom: S9(x5), enterTo: S9(h10), entered: S9(v7), leave: S9(u14), leaveFrom: S9(g6), leaveTo: S9(d17) }), V6 = Re3({ beforeEnter: r10, afterEnter: s18, beforeLeave: R5, afterLeave: D8 }), G5 = l2();
  (0, import_react43.useEffect)(() => {
    if (G5 && l14 === "visible" && e5.current === null)
      throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
  }, [e5, l14, G5]);
  let Te3 = T8 && !N8, K5 = N8 && f15 && T8, de6 = (() => !G5 || Te3 ? "idle" : f15 ? "enter" : "leave")(), H7 = c10(0), fe4 = o2((C8) => u(C8, { enter: () => {
    H7.addFlag(d5.Opening), V6.current.beforeEnter();
  }, leave: () => {
    H7.addFlag(d5.Closing), V6.current.beforeLeave();
  }, idle: () => {
  } })), me4 = o2((C8) => u(C8, { enter: () => {
    H7.removeFlag(d5.Opening), V6.current.afterEnter();
  }, leave: () => {
    H7.removeFlag(d5.Closing), V6.current.afterLeave();
  }, idle: () => {
  } })), w7 = se3(() => {
    j6("hidden"), O5(e5);
  }, z5), B5 = (0, import_react43.useRef)(false);
  D6({ immediate: K5, container: e5, classes: k4, direction: de6, onStart: s2((C8) => {
    B5.current = true, w7.onStart(e5, C8, fe4);
  }), onStop: s2((C8) => {
    B5.current = false, w7.onStop(e5, C8, me4), C8 === "leave" && !U6(w7) && (j6("hidden"), O5(e5));
  }) });
  let P6 = i9, ce4 = { ref: a11 };
  return K5 ? P6 = { ...P6, className: t9(i9.className, ...k4.current.enter, ...k4.current.enterFrom) } : B5.current && (P6.className = t9(i9.className, (Y4 = e5.current) == null ? void 0 : Y4.className), P6.className === "" && delete P6.className), import_react43.default.createElement(M6.Provider, { value: w7 }, import_react43.default.createElement(s9, { value: u(l14, { ["visible"]: d5.Open, ["hidden"]: d5.Closed }) | H7.flags }, C({ ourProps: ce4, theirProps: P6, defaultTag: De3, features: le2, visible: l14 === "visible", name: "Transition.Child" })));
}
function Fe4(t19, n8) {
  let { show: r10, appear: s18 = false, unmount: R5 = true, ...D8 } = t19, p8 = (0, import_react43.useRef)(null), x5 = y3(p8, n8);
  l2();
  let h10 = u5();
  if (r10 === void 0 && h10 !== null && (r10 = (h10 & d5.Open) === d5.Open), ![true, false].includes(r10))
    throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
  let [v7, u14] = (0, import_react43.useState)(r10 ? "visible" : "hidden"), g6 = se3(() => {
    u14("hidden");
  }), [d17, i9] = (0, import_react43.useState)(true), e5 = (0, import_react43.useRef)([r10]);
  l(() => {
    d17 !== false && e5.current[e5.current.length - 1] !== r10 && (e5.current.push(r10), i9(false));
  }, [e5, r10]);
  let a11 = (0, import_react43.useMemo)(() => ({ show: r10, appear: s18, initial: d17 }), [r10, s18, d17]);
  (0, import_react43.useEffect)(() => {
    if (r10)
      u14("visible");
    else if (!U6(g6))
      u14("hidden");
    else {
      let T8 = p8.current;
      if (!T8)
        return;
      let l14 = T8.getBoundingClientRect();
      l14.x === 0 && l14.y === 0 && l14.width === 0 && l14.height === 0 && u14("hidden");
    }
  }, [r10, g6]);
  let o14 = { unmount: R5 }, f15 = o2(() => {
    var T8;
    d17 && i9(false), (T8 = t19.beforeEnter) == null || T8.call(t19);
  }), N8 = o2(() => {
    var T8;
    d17 && i9(false), (T8 = t19.beforeLeave) == null || T8.call(t19);
  });
  return import_react43.default.createElement(M6.Provider, { value: g6 }, import_react43.default.createElement(I10.Provider, { value: a11 }, C({ ourProps: { ...o14, as: import_react43.Fragment, children: import_react43.default.createElement(ue6, { ref: x5, ...o14, ...D8, beforeEnter: f15, beforeLeave: N8 }) }, theirProps: {}, defaultTag: import_react43.Fragment, features: le2, visible: v7 === "visible", name: "Transition" })));
}
function _e4(t19, n8) {
  let r10 = (0, import_react43.useContext)(I10) !== null, s18 = u5() !== null;
  return import_react43.default.createElement(import_react43.default.Fragment, null, !r10 && s18 ? import_react43.default.createElement(q5, { ref: n8, ...t19 }) : import_react43.default.createElement(ue6, { ref: n8, ...t19 }));
}
var q5 = U(Fe4);
var ue6 = U(He4);
var Le4 = U(_e4);
var qe6 = Object.assign(q5, { Child: Le4, Root: q5 });

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/utils/format.js
var ELLIPSIS = "…";
function formatAddress(address) {
  if (address.length <= 6) {
    return address;
  }
  const offset = address.startsWith("0x") ? 2 : 0;
  return `0x${address.slice(offset, offset + 4)}${ELLIPSIS}${address.slice(-4)}`;
}

// node_modules/@mysten/wallet-kit/node_modules/@mysten/bcs/dist/index.mjs
var import_bs58 = __toESM(require_bs58(), 1);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var toB58 = (buffer) => import_bs58.default.encode(buffer);
var fromB58 = (str) => import_bs58.default.decode(str);
function b64ToUint6(nChr) {
  return nChr > 64 && nChr < 91 ? nChr - 65 : nChr > 96 && nChr < 123 ? nChr - 71 : nChr > 47 && nChr < 58 ? nChr + 4 : nChr === 43 ? 62 : nChr === 47 ? 63 : 0;
}
function fromB64(sBase64, nBlocksSize) {
  var sB64Enc = sBase64.replace(/[^A-Za-z0-9+/]/g, ""), nInLen = sB64Enc.length, nOutLen = nBlocksSize ? Math.ceil((nInLen * 3 + 1 >> 2) / nBlocksSize) * nBlocksSize : nInLen * 3 + 1 >> 2, taBytes = new Uint8Array(nOutLen);
  for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {
    nMod4 = nInIdx & 3;
    nUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 6 * (3 - nMod4);
    if (nMod4 === 3 || nInLen - nInIdx === 1) {
      for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
        taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;
      }
      nUint24 = 0;
    }
  }
  return taBytes;
}
function uint6ToB64(nUint6) {
  return nUint6 < 26 ? nUint6 + 65 : nUint6 < 52 ? nUint6 + 71 : nUint6 < 62 ? nUint6 - 4 : nUint6 === 62 ? 43 : nUint6 === 63 ? 47 : 65;
}
function toB64(aBytes) {
  var nMod3 = 2, sB64Enc = "";
  for (var nLen = aBytes.length, nUint24 = 0, nIdx = 0; nIdx < nLen; nIdx++) {
    nMod3 = nIdx % 3;
    nUint24 |= aBytes[nIdx] << (16 >>> nMod3 & 24);
    if (nMod3 === 2 || aBytes.length - nIdx === 1) {
      sB64Enc += String.fromCodePoint(
        uint6ToB64(nUint24 >>> 18 & 63),
        uint6ToB64(nUint24 >>> 12 & 63),
        uint6ToB64(nUint24 >>> 6 & 63),
        uint6ToB64(nUint24 & 63)
      );
      nUint24 = 0;
    }
  }
  return sB64Enc.slice(0, sB64Enc.length - 2 + nMod3) + (nMod3 === 2 ? "" : nMod3 === 1 ? "=" : "==");
}
function fromHEX(hexStr) {
  var _a;
  const normalized = hexStr.startsWith("0x") ? hexStr.slice(2) : hexStr;
  const padded = normalized.length % 2 === 0 ? normalized : `0${normalized}}`;
  const intArr = ((_a = padded.match(/.{2}/g)) == null ? void 0 : _a.map((byte) => parseInt(byte, 16))) ?? [];
  return Uint8Array.from(intArr);
}
function toHEX(bytes) {
  return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
}
function ulebEncode(num) {
  let arr = [];
  let len = 0;
  if (num === 0) {
    return [0];
  }
  while (num > 0) {
    arr[len] = num & 127;
    if (num >>= 7) {
      arr[len] |= 128;
    }
    len += 1;
  }
  return arr;
}
function ulebDecode(arr) {
  let total = 0;
  let shift = 0;
  let len = 0;
  while (true) {
    let byte = arr[len];
    len += 1;
    total |= (byte & 127) << shift;
    if ((byte & 128) === 0) {
      break;
    }
    shift += 7;
  }
  return {
    value: total,
    length: len
  };
}
var BcsReader = class {
  /**
   * @param {Uint8Array} data Data to use as a buffer.
   */
  constructor(data) {
    this.bytePosition = 0;
    this.dataView = new DataView(data.buffer);
  }
  /**
   * Shift current cursor position by `bytes`.
   *
   * @param {Number} bytes Number of bytes to
   * @returns {this} Self for possible chaining.
   */
  shift(bytes) {
    this.bytePosition += bytes;
    return this;
  }
  /**
   * Read U8 value from the buffer and shift cursor by 1.
   * @returns
   */
  read8() {
    let value = this.dataView.getUint8(this.bytePosition);
    this.shift(1);
    return value;
  }
  /**
   * Read U16 value from the buffer and shift cursor by 2.
   * @returns
   */
  read16() {
    let value = this.dataView.getUint16(this.bytePosition, true);
    this.shift(2);
    return value;
  }
  /**
   * Read U32 value from the buffer and shift cursor by 4.
   * @returns
   */
  read32() {
    let value = this.dataView.getUint32(this.bytePosition, true);
    this.shift(4);
    return value;
  }
  /**
   * Read U64 value from the buffer and shift cursor by 8.
   * @returns
   */
  read64() {
    let value1 = this.read32();
    let value2 = this.read32();
    let result = value2.toString(16) + value1.toString(16).padStart(8, "0");
    return BigInt("0x" + result).toString(10);
  }
  /**
   * Read U128 value from the buffer and shift cursor by 16.
   */
  read128() {
    let value1 = BigInt(this.read64());
    let value2 = BigInt(this.read64());
    let result = value2.toString(16) + value1.toString(16).padStart(16, "0");
    return BigInt("0x" + result).toString(10);
  }
  /**
   * Read U128 value from the buffer and shift cursor by 32.
   * @returns
   */
  read256() {
    let value1 = BigInt(this.read128());
    let value2 = BigInt(this.read128());
    let result = value2.toString(16) + value1.toString(16).padStart(32, "0");
    return BigInt("0x" + result).toString(10);
  }
  /**
   * Read `num` number of bytes from the buffer and shift cursor by `num`.
   * @param num Number of bytes to read.
   */
  readBytes(num) {
    let start = this.bytePosition + this.dataView.byteOffset;
    let value = new Uint8Array(this.dataView.buffer, start, num);
    this.shift(num);
    return value;
  }
  /**
   * Read ULEB value - an integer of varying size. Used for enum indexes and
   * vector lengths.
   * @returns {Number} The ULEB value.
   */
  readULEB() {
    let start = this.bytePosition + this.dataView.byteOffset;
    let buffer = new Uint8Array(this.dataView.buffer, start);
    let { value, length } = ulebDecode(buffer);
    this.shift(length);
    return value;
  }
  /**
   * Read a BCS vector: read a length and then apply function `cb` X times
   * where X is the length of the vector, defined as ULEB in BCS bytes.
   * @param cb Callback to process elements of vector.
   * @returns {Array<Any>} Array of the resulting values, returned by callback.
   */
  readVec(cb) {
    let length = this.readULEB();
    let result = [];
    for (let i9 = 0; i9 < length; i9++) {
      result.push(cb(this, i9, length));
    }
    return result;
  }
};
function encodeStr(data, encoding) {
  switch (encoding) {
    case "base58":
      return toB58(data);
    case "base64":
      return toB64(data);
    case "hex":
      return toHEX(data);
    default:
      throw new Error("Unsupported encoding, supported values are: base64, hex");
  }
}
function decodeStr(data, encoding) {
  switch (encoding) {
    case "base58":
      return fromB58(data);
    case "base64":
      return fromB64(data);
    case "hex":
      return fromHEX(data);
    default:
      throw new Error("Unsupported encoding, supported values are: base64, hex");
  }
}
function splitGenericParameters(str, genericSeparators = ["<", ">"]) {
  const [left, right] = genericSeparators;
  const tok = [];
  let word = "";
  let nestedAngleBrackets = 0;
  for (let i9 = 0; i9 < str.length; i9++) {
    const char = str[i9];
    if (char === left) {
      nestedAngleBrackets++;
    }
    if (char === right) {
      nestedAngleBrackets--;
    }
    if (nestedAngleBrackets === 0 && char === ",") {
      tok.push(word.trim());
      word = "";
      continue;
    }
    word += char;
  }
  tok.push(word.trim());
  return tok;
}
var BcsWriter = class {
  constructor({ size = 1024, maxSize, allocateSize = 1024 } = {}) {
    this.bytePosition = 0;
    this.size = size;
    this.maxSize = maxSize || size;
    this.allocateSize = allocateSize;
    this.dataView = new DataView(new ArrayBuffer(size));
  }
  ensureSizeOrGrow(bytes) {
    const requiredSize = this.bytePosition + bytes;
    if (requiredSize > this.size) {
      const nextSize = Math.min(this.maxSize, this.size + this.allocateSize);
      if (requiredSize > nextSize) {
        throw new Error(
          `Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`
        );
      }
      this.size = nextSize;
      const nextBuffer = new ArrayBuffer(this.size);
      new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));
      this.dataView = new DataView(nextBuffer);
    }
  }
  /**
   * Shift current cursor position by `bytes`.
   *
   * @param {Number} bytes Number of bytes to
   * @returns {this} Self for possible chaining.
   */
  shift(bytes) {
    this.bytePosition += bytes;
    return this;
  }
  /**
   * Write a U8 value into a buffer and shift cursor position by 1.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write8(value) {
    this.ensureSizeOrGrow(1);
    this.dataView.setUint8(this.bytePosition, Number(value));
    return this.shift(1);
  }
  /**
   * Write a U16 value into a buffer and shift cursor position by 2.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write16(value) {
    this.ensureSizeOrGrow(2);
    this.dataView.setUint16(this.bytePosition, Number(value), true);
    return this.shift(2);
  }
  /**
   * Write a U32 value into a buffer and shift cursor position by 4.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write32(value) {
    this.ensureSizeOrGrow(4);
    this.dataView.setUint32(this.bytePosition, Number(value), true);
    return this.shift(4);
  }
  /**
   * Write a U64 value into a buffer and shift cursor position by 8.
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write64(value) {
    toLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));
    return this;
  }
  /**
   * Write a U128 value into a buffer and shift cursor position by 16.
   *
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write128(value) {
    toLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));
    return this;
  }
  /**
   * Write a U256 value into a buffer and shift cursor position by 16.
   *
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write256(value) {
    toLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));
    return this;
  }
  /**
   * Write a ULEB value into a buffer and shift cursor position by number of bytes
   * written.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  writeULEB(value) {
    ulebEncode(value).forEach((el) => this.write8(el));
    return this;
  }
  /**
   * Write a vector into a buffer by first writing the vector length and then calling
   * a callback on each passed value.
   *
   * @param {Array<Any>} vector Array of elements to write.
   * @param {WriteVecCb} cb Callback to call on each element of the vector.
   * @returns {this}
   */
  writeVec(vector, cb) {
    this.writeULEB(vector.length);
    Array.from(vector).forEach((el, i9) => cb(this, el, i9, vector.length));
    return this;
  }
  /**
   * Adds support for iterations over the object.
   * @returns {Uint8Array}
   */
  *[Symbol.iterator]() {
    for (let i9 = 0; i9 < this.bytePosition; i9++) {
      yield this.dataView.getUint8(i9);
    }
    return this.toBytes();
  }
  /**
   * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).
   * @returns {Uint8Array} Resulting bcs.
   */
  toBytes() {
    return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));
  }
  /**
   * Represent data as 'hex' or 'base64'
   * @param encoding Encoding to use: 'base64' or 'hex'
   */
  toString(encoding) {
    return encodeStr(this.toBytes(), encoding);
  }
};
function toLittleEndian(bigint2, size) {
  let result = new Uint8Array(size);
  let i9 = 0;
  while (bigint2 > 0) {
    result[i9] = Number(bigint2 % BigInt(256));
    bigint2 = bigint2 / BigInt(256);
    i9 += 1;
  }
  return result;
}
var _write;
var _serialize;
var _BcsType = class _BcsType2 {
  constructor(options) {
    __privateAdd(this, _write, void 0);
    __privateAdd(this, _serialize, void 0);
    this.name = options.name;
    this.read = options.read;
    this.serializedSize = options.serializedSize ?? (() => null);
    __privateSet(this, _write, options.write);
    __privateSet(this, _serialize, options.serialize ?? ((value, options2) => {
      const writer = new BcsWriter({ size: this.serializedSize(value) ?? void 0, ...options2 });
      __privateGet(this, _write).call(this, value, writer);
      return writer.toBytes();
    }));
    this.validate = options.validate ?? (() => {
    });
  }
  write(value, writer) {
    this.validate(value);
    __privateGet(this, _write).call(this, value, writer);
  }
  serialize(value, options) {
    this.validate(value);
    return new SerializedBcs(this, __privateGet(this, _serialize).call(this, value, options));
  }
  parse(bytes) {
    const reader = new BcsReader(bytes);
    return this.read(reader);
  }
  transform({
    name,
    input,
    output
  }) {
    return new _BcsType2({
      name: name ?? this.name,
      read: (reader) => output(this.read(reader)),
      write: (value, writer) => __privateGet(this, _write).call(this, input(value), writer),
      serializedSize: (value) => this.serializedSize(input(value)),
      serialize: (value, options) => __privateGet(this, _serialize).call(this, input(value), options),
      validate: (value) => this.validate(input(value))
    });
  }
};
_write = /* @__PURE__ */ new WeakMap();
_serialize = /* @__PURE__ */ new WeakMap();
var BcsType = _BcsType;
var SERIALIZED_BCS_BRAND = Symbol.for("@mysten/serialized-bcs");
function isSerializedBcs(obj) {
  return !!obj && typeof obj === "object" && obj[SERIALIZED_BCS_BRAND] === true;
}
var _schema;
var _bytes;
var SerializedBcs = class {
  constructor(type, schema) {
    __privateAdd(this, _schema, void 0);
    __privateAdd(this, _bytes, void 0);
    __privateSet(this, _schema, type);
    __privateSet(this, _bytes, schema);
  }
  // Used to brand SerializedBcs so that they can be identified, even between multiple copies
  // of the @mysten/bcs package are installed
  get [SERIALIZED_BCS_BRAND]() {
    return true;
  }
  toBytes() {
    return __privateGet(this, _bytes);
  }
  toHex() {
    return toHEX(__privateGet(this, _bytes));
  }
  toBase64() {
    return toB64(__privateGet(this, _bytes));
  }
  toBase58() {
    return toB58(__privateGet(this, _bytes));
  }
  parse() {
    return __privateGet(this, _schema).parse(__privateGet(this, _bytes));
  }
};
_schema = /* @__PURE__ */ new WeakMap();
_bytes = /* @__PURE__ */ new WeakMap();
function fixedSizeBcsType({
  size,
  ...options
}) {
  return new BcsType({
    ...options,
    serializedSize: () => size
  });
}
function uIntBcsType({
  readMethod,
  writeMethod,
  ...options
}) {
  return fixedSizeBcsType({
    ...options,
    read: (reader) => reader[readMethod](),
    write: (value, writer) => writer[writeMethod](value),
    validate: (value) => {
      var _a;
      if (value < 0 || value > options.maxValue) {
        throw new TypeError(
          `Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`
        );
      }
      (_a = options.validate) == null ? void 0 : _a.call(options, value);
    }
  });
}
function bigUIntBcsType({
  readMethod,
  writeMethod,
  ...options
}) {
  return fixedSizeBcsType({
    ...options,
    read: (reader) => reader[readMethod](),
    write: (value, writer) => writer[writeMethod](BigInt(value)),
    validate: (val) => {
      var _a;
      const value = BigInt(val);
      if (value < 0 || value > options.maxValue) {
        throw new TypeError(
          `Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`
        );
      }
      (_a = options.validate) == null ? void 0 : _a.call(options, value);
    }
  });
}
function dynamicSizeBcsType({
  serialize,
  ...options
}) {
  const type = new BcsType({
    ...options,
    serialize,
    write: (value, writer) => {
      for (const byte of type.serialize(value).toBytes()) {
        writer.write8(byte);
      }
    }
  });
  return type;
}
function stringLikeBcsType({
  toBytes,
  fromBytes,
  ...options
}) {
  return new BcsType({
    ...options,
    read: (reader) => {
      const length = reader.readULEB();
      const bytes = reader.readBytes(length);
      return fromBytes(bytes);
    },
    write: (hex, writer) => {
      const bytes = toBytes(hex);
      writer.writeULEB(bytes.length);
      for (let i9 = 0; i9 < bytes.length; i9++) {
        writer.write8(bytes[i9]);
      }
    },
    serialize: (value) => {
      const bytes = toBytes(value);
      const size = ulebEncode(bytes.length);
      const result = new Uint8Array(size.length + bytes.length);
      result.set(size, 0);
      result.set(bytes, size.length);
      return result;
    },
    validate: (value) => {
      var _a;
      if (typeof value !== "string") {
        throw new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);
      }
      (_a = options.validate) == null ? void 0 : _a.call(options, value);
    }
  });
}
function lazyBcsType(cb) {
  let lazyType = null;
  function getType() {
    if (!lazyType) {
      lazyType = cb();
    }
    return lazyType;
  }
  return new BcsType({
    name: "lazy",
    read: (data) => getType().read(data),
    serializedSize: (value) => getType().serializedSize(value),
    write: (value, writer) => getType().write(value, writer),
    serialize: (value, options) => getType().serialize(value, options).toBytes()
  });
}
var bcs = {
  /**
   * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.
   * @example
   * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]
   */
  u8(options) {
    return uIntBcsType({
      name: "u8",
      readMethod: "read8",
      writeMethod: "write8",
      size: 1,
      maxValue: 2 ** 8 - 1,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.
   * @example
   * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]
   */
  u16(options) {
    return uIntBcsType({
      name: "u16",
      readMethod: "read16",
      writeMethod: "write16",
      size: 2,
      maxValue: 2 ** 16 - 1,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.
   * @example
   * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]
   */
  u32(options) {
    return uIntBcsType({
      name: "u32",
      readMethod: "read32",
      writeMethod: "write32",
      size: 4,
      maxValue: 2 ** 32 - 1,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.
   * @example
   * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]
   */
  u64(options) {
    return bigUIntBcsType({
      name: "u64",
      readMethod: "read64",
      writeMethod: "write64",
      size: 8,
      maxValue: 2n ** 64n - 1n,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.
   * @example
   * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]
   */
  u128(options) {
    return bigUIntBcsType({
      name: "u128",
      readMethod: "read128",
      writeMethod: "write128",
      size: 16,
      maxValue: 2n ** 128n - 1n,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.
   * @example
   * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]
   */
  u256(options) {
    return bigUIntBcsType({
      name: "u256",
      readMethod: "read256",
      writeMethod: "write256",
      size: 32,
      maxValue: 2n ** 256n - 1n,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write boolean values.
   * @example
   * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]
   */
  bool(options) {
    return fixedSizeBcsType({
      name: "bool",
      size: 1,
      read: (reader) => reader.read8() === 1,
      write: (value, writer) => writer.write8(value ? 1 : 0),
      ...options,
      validate: (value) => {
        var _a;
        (_a = options == null ? void 0 : options.validate) == null ? void 0 : _a.call(options, value);
        if (typeof value !== "boolean") {
          throw new TypeError(`Expected boolean, found ${typeof value}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType that can be used to read and write unsigned LEB encoded integers
   * @example
   *
   */
  uleb128(options) {
    return dynamicSizeBcsType({
      name: "uleb128",
      read: (reader) => reader.readULEB(),
      serialize: (value) => {
        return Uint8Array.from(ulebEncode(value));
      },
      ...options
    });
  },
  /**
   * Creates a BcsType representing a fixed length byte array
   * @param size The number of bytes this types represents
   * @example
   * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]
   */
  bytes(size, options) {
    return fixedSizeBcsType({
      name: `bytes[${size}]`,
      size,
      read: (reader) => reader.readBytes(size),
      write: (value, writer) => {
        for (let i9 = 0; i9 < size; i9++) {
          writer.write8(value[i9] ?? 0);
        }
      },
      ...options,
      validate: (value) => {
        var _a;
        (_a = options == null ? void 0 : options.validate) == null ? void 0 : _a.call(options, value);
        if (!("length" in value)) {
          throw new TypeError(`Expected array, found ${typeof value}`);
        }
        if (value.length !== size) {
          throw new TypeError(`Expected array of length ${size}, found ${value.length}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded
   * @example
   * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]
   */
  string(options) {
    return stringLikeBcsType({
      name: "string",
      toBytes: (value) => new TextEncoder().encode(value),
      fromBytes: (bytes) => new TextDecoder().decode(bytes),
      ...options
    });
  },
  /**
   * Creates a BcsType that represents a fixed length array of a given type
   * @param size The number of elements in the array
   * @param type The BcsType of each element in the array
   * @example
   * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]
   */
  fixedArray(size, type, options) {
    return new BcsType({
      name: `${type.name}[${size}]`,
      read: (reader) => {
        const result = new Array(size);
        for (let i9 = 0; i9 < size; i9++) {
          result[i9] = type.read(reader);
        }
        return result;
      },
      write: (value, writer) => {
        for (const item of value) {
          type.write(item, writer);
        }
      },
      ...options,
      validate: (value) => {
        var _a;
        (_a = options == null ? void 0 : options.validate) == null ? void 0 : _a.call(options, value);
        if (!("length" in value)) {
          throw new TypeError(`Expected array, found ${typeof value}`);
        }
        if (value.length !== size) {
          throw new TypeError(`Expected array of length ${size}, found ${value.length}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing an optional value
   * @param type The BcsType of the optional value
   * @example
   * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]
   * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]
   */
  option(type) {
    return bcs.enum(`Option<${type.name}>`, {
      None: null,
      Some: type
    }).transform({
      input: (value) => {
        if (value == null) {
          return { None: true };
        }
        return { Some: value };
      },
      output: (value) => {
        if ("Some" in value) {
          return value.Some;
        }
        return null;
      }
    });
  },
  /**
   * Creates a BcsType representing a variable length vector of a given type
   * @param type The BcsType of each element in the vector
   *
   * @example
   * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]
   */
  vector(type, options) {
    return new BcsType({
      name: `vector<${type.name}>`,
      read: (reader) => {
        const length = reader.readULEB();
        const result = new Array(length);
        for (let i9 = 0; i9 < length; i9++) {
          result[i9] = type.read(reader);
        }
        return result;
      },
      write: (value, writer) => {
        writer.writeULEB(value.length);
        for (const item of value) {
          type.write(item, writer);
        }
      },
      ...options,
      validate: (value) => {
        var _a;
        (_a = options == null ? void 0 : options.validate) == null ? void 0 : _a.call(options, value);
        if (!("length" in value)) {
          throw new TypeError(`Expected array, found ${typeof value}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing a tuple of a given set of types
   * @param types The BcsTypes for each element in the tuple
   *
   * @example
   * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])
   * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]
   */
  tuple(types, options) {
    return new BcsType({
      name: `(${types.map((t19) => t19.name).join(", ")})`,
      serializedSize: (values) => {
        let total = 0;
        for (let i9 = 0; i9 < types.length; i9++) {
          const size = types[i9].serializedSize(values[i9]);
          if (size == null) {
            return null;
          }
          total += size;
        }
        return total;
      },
      read: (reader) => {
        const result = [];
        for (const type of types) {
          result.push(type.read(reader));
        }
        return result;
      },
      write: (value, writer) => {
        for (let i9 = 0; i9 < types.length; i9++) {
          types[i9].write(value[i9], writer);
        }
      },
      ...options,
      validate: (value) => {
        var _a;
        (_a = options == null ? void 0 : options.validate) == null ? void 0 : _a.call(options, value);
        if (!Array.isArray(value)) {
          throw new TypeError(`Expected array, found ${typeof value}`);
        }
        if (value.length !== types.length) {
          throw new TypeError(`Expected array of length ${types.length}, found ${value.length}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing a struct of a given set of fields
   * @param name The name of the struct
   * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized
   *
   * @example
   * const struct = bcs.struct('MyStruct', {
   *  a: bcs.u8(),
   *  b: bcs.string(),
   * })
   * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]
   */
  struct(name, fields, options) {
    const canonicalOrder = Object.entries(fields);
    return new BcsType({
      name,
      serializedSize: (values) => {
        let total = 0;
        for (const [field, type] of canonicalOrder) {
          const size = type.serializedSize(values[field]);
          if (size == null) {
            return null;
          }
          total += size;
        }
        return total;
      },
      read: (reader) => {
        const result = {};
        for (const [field, type] of canonicalOrder) {
          result[field] = type.read(reader);
        }
        return result;
      },
      write: (value, writer) => {
        for (const [field, type] of canonicalOrder) {
          type.write(value[field], writer);
        }
      },
      ...options,
      validate: (value) => {
        var _a;
        (_a = options == null ? void 0 : options.validate) == null ? void 0 : _a.call(options, value);
        if (typeof value !== "object" || value == null) {
          throw new TypeError(`Expected object, found ${typeof value}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing an enum of a given set of options
   * @param name The name of the enum
   * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.
   * null can be used to represent a variant with no data.
   *
   * @example
   * const enum = bcs.enum('MyEnum', {
   *   A: bcs.u8(),
   *   B: bcs.string(),
   *   C: null,
   * })
   * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]
   * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]
   * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]
   */
  enum(name, values, options) {
    const canonicalOrder = Object.entries(values);
    return new BcsType({
      name,
      read: (reader) => {
        const index = reader.readULEB();
        const [name2, type] = canonicalOrder[index];
        return {
          [name2]: (type == null ? void 0 : type.read(reader)) ?? true
        };
      },
      write: (value, writer) => {
        const [name2, val] = Object.entries(value)[0];
        for (let i9 = 0; i9 < canonicalOrder.length; i9++) {
          const [optionName, optionType] = canonicalOrder[i9];
          if (optionName === name2) {
            writer.writeULEB(i9);
            optionType == null ? void 0 : optionType.write(val, writer);
            return;
          }
        }
      },
      ...options,
      validate: (value) => {
        var _a;
        (_a = options == null ? void 0 : options.validate) == null ? void 0 : _a.call(options, value);
        if (typeof value !== "object" || value == null) {
          throw new TypeError(`Expected object, found ${typeof value}`);
        }
        const keys = Object.keys(value);
        if (keys.length !== 1) {
          throw new TypeError(`Expected object with one key, found ${keys.length}`);
        }
        const [name2] = keys;
        if (!Object.hasOwn(values, name2)) {
          throw new TypeError(`Invalid enum variant ${name2}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing a map of a given key and value type
   * @param keyType The BcsType of the key
   * @param valueType The BcsType of the value
   * @example
   * const map = bcs.map(bcs.u8(), bcs.string())
   * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]
   */
  map(keyType, valueType) {
    return bcs.vector(bcs.tuple([keyType, valueType])).transform({
      name: `Map<${keyType.name}, ${valueType.name}>`,
      input: (value) => {
        return [...value.entries()];
      },
      output: (value) => {
        const result = /* @__PURE__ */ new Map();
        for (const [key, val] of value) {
          result.set(key, val);
        }
        return result;
      }
    });
  },
  /**
   * @deprecated
   *
   * Generics should be implemented as generic typescript functions instead:
   *
   * ```ts
   * function VecMap<K, V>, (K: BcsType<K>, V: BcsType<V>) {
   *   return bcs.struct('VecMap<K, V>', {
   *     keys: bcs.vector(K),
   *     values: bcs.vector(V),
   *   })
   * }
   * ```
   */
  generic(names, cb) {
    return (...types) => {
      return cb(...types).transform({
        name: `${cb.name}<${types.map((t19) => t19.name).join(", ")}>`,
        input: (value) => value,
        output: (value) => value
      });
    };
  },
  /**
   * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.
   * @param cb A callback that returns the BcsType
   */
  lazy(cb) {
    return lazyBcsType(cb);
  }
};
var SUI_ADDRESS_LENGTH = 32;
var _BCS = class _BCS2 {
  /**
   * Construct a BCS instance with a prepared schema.
   *
   * @param schema A prepared schema with type definitions
   * @param withPrimitives Whether to register primitive types by default
   */
  constructor(schema) {
    this.types = /* @__PURE__ */ new Map();
    this.counter = 0;
    if (schema instanceof _BCS2) {
      this.schema = schema.schema;
      this.types = new Map(schema.types);
      return;
    }
    this.schema = schema;
    this.registerAddressType(_BCS2.ADDRESS, schema.addressLength, schema.addressEncoding);
    this.registerVectorType(schema.vectorType);
    if (schema.types && schema.types.structs) {
      for (let name of Object.keys(schema.types.structs)) {
        this.registerStructType(name, schema.types.structs[name]);
      }
    }
    if (schema.types && schema.types.enums) {
      for (let name of Object.keys(schema.types.enums)) {
        this.registerEnumType(name, schema.types.enums[name]);
      }
    }
    if (schema.types && schema.types.aliases) {
      for (let name of Object.keys(schema.types.aliases)) {
        this.registerAlias(name, schema.types.aliases[name]);
      }
    }
    if (schema.withPrimitives !== false) {
      registerPrimitives(this);
    }
  }
  /**
   * Name of the key to use for temporary struct definitions.
   * Returns a temp key + index (for a case when multiple temp
   * structs are processed).
   */
  tempKey() {
    return `bcs-struct-${++this.counter}`;
  }
  /**
   * Serialize data into bcs.
   *
   * @example
   * bcs.registerVectorType('vector<u8>', 'u8');
   *
   * let serialized = BCS
   *   .set('vector<u8>', [1,2,3,4,5,6])
   *   .toBytes();
   *
   * console.assert(toHex(serialized) === '06010203040506');
   *
   * @param type Name of the type to serialize (must be registered) or a struct type.
   * @param data Data to serialize.
   * @param size Serialization buffer size. Default 1024 = 1KB.
   * @return A BCS reader instance. Usually you'd want to call `.toBytes()`
   */
  ser(type, data, options) {
    if (typeof type === "string" || Array.isArray(type)) {
      const { name, params } = this.parseTypeName(type);
      return this.getTypeInterface(name).encode(this, data, options, params);
    }
    if (typeof type === "object") {
      const key = this.tempKey();
      const temp = new _BCS2(this);
      return temp.registerStructType(key, type).ser(key, data, options);
    }
    throw new Error(`Incorrect type passed into the '.ser()' function. 
${JSON.stringify(type)}`);
  }
  /**
   * Deserialize BCS into a JS type.
   *
   * @example
   * let num = bcs.ser('u64', '4294967295').toString('hex');
   * let deNum = bcs.de('u64', num, 'hex');
   * console.assert(deNum.toString(10) === '4294967295');
   *
   * @param type Name of the type to deserialize (must be registered) or a struct type definition.
   * @param data Data to deserialize.
   * @param encoding Optional - encoding to use if data is of type String
   * @return Deserialized data.
   */
  de(type, data, encoding) {
    if (typeof data === "string") {
      if (encoding) {
        data = decodeStr(data, encoding);
      } else {
        throw new Error("To pass a string to `bcs.de`, specify encoding");
      }
    }
    if (typeof type === "string" || Array.isArray(type)) {
      const { name, params } = this.parseTypeName(type);
      return this.getTypeInterface(name).decode(this, data, params);
    }
    if (typeof type === "object") {
      const temp = new _BCS2(this);
      const key = this.tempKey();
      return temp.registerStructType(key, type).de(key, data, encoding);
    }
    throw new Error(`Incorrect type passed into the '.de()' function. 
${JSON.stringify(type)}`);
  }
  /**
   * Check whether a `TypeInterface` has been loaded for a `type`.
   * @param type Name of the type to check.
   * @returns
   */
  hasType(type) {
    return this.types.has(type);
  }
  /**
   * Create an alias for a type.
   * WARNING: this can potentially lead to recursion
   * @param name Alias to use
   * @param forType Type to reference
   * @returns
   *
   * @example
   * ```
   * let bcs = new BCS(getSuiMoveConfig());
   * bcs.registerAlias('ObjectDigest', BCS.BASE58);
   * let b58_digest = bcs.de('ObjectDigest', '<digest_bytes>', 'base64');
   * ```
   */
  registerAlias(name, forType) {
    this.types.set(name, forType);
    return this;
  }
  /**
   * Method to register new types for BCS internal representation.
   * For each registered type 2 callbacks must be specified and one is optional:
   *
   * - encodeCb(writer, data) - write a way to serialize data with BcsWriter;
   * - decodeCb(reader) - write a way to deserialize data with BcsReader;
   * - validateCb(data) - validate data - either return bool or throw an error
   *
   * @example
   * // our type would be a string that consists only of numbers
   * bcs.registerType('number_string',
   *    (writer, data) => writer.writeVec(data, (w, el) => w.write8(el)),
   *    (reader) => reader.readVec((r) => r.read8()).join(''), // read each value as u8
   *    (value) => /[0-9]+/.test(value) // test that it has at least one digit
   * );
   * console.log(Array.from(bcs.ser('number_string', '12345').toBytes()) == [5,1,2,3,4,5]);
   *
   * @param name
   * @param encodeCb Callback to encode a value.
   * @param decodeCb Callback to decode a value.
   * @param validateCb Optional validator Callback to check type before serialization.
   */
  registerType(typeName, encodeCb, decodeCb, validateCb = () => true) {
    const { name, params: generics } = this.parseTypeName(typeName);
    this.types.set(name, {
      encode(self, data, options, typeParams) {
        const typeMap = generics.reduce((acc, value, index) => {
          return Object.assign(acc, { [value]: typeParams[index] });
        }, {});
        return this._encodeRaw.call(self, new BcsWriter(options), data, typeParams, typeMap);
      },
      decode(self, data, typeParams) {
        const typeMap = generics.reduce((acc, value, index) => {
          return Object.assign(acc, { [value]: typeParams[index] });
        }, {});
        return this._decodeRaw.call(self, new BcsReader(data), typeParams, typeMap);
      },
      // these methods should always be used with caution as they require pre-defined
      // reader and writer and mainly exist to allow multi-field (de)serialization;
      _encodeRaw(writer, data, typeParams, typeMap) {
        if (validateCb(data)) {
          return encodeCb.call(this, writer, data, typeParams, typeMap);
        } else {
          throw new Error(`Validation failed for type ${name}, data: ${data}`);
        }
      },
      _decodeRaw(reader, typeParams, typeMap) {
        return decodeCb.call(this, reader, typeParams, typeMap);
      }
    });
    return this;
  }
  /**
  	 * Method to register BcsType instances to the registry
  	 * Types are registered with a callback that provides BcsType instances for each generic
  	 * passed to the type.
  	 *
  	 * - createType(...generics) - Return a BcsType instance
  	 *
  	 * @example
  	 * // our type would be a string that consists only of numbers
  	 * bcs.registerType('Box<T>', (T) => {
  	 * 		return bcs.struct({
  	 * 			value: T
  	 * 		});
  	 * });
  
  	 * console.log(Array.from(bcs.ser('Box<string>', '12345').toBytes()) == [5,1,2,3,4,5]);
  	 *
  	 * @param name
  	 * @param createType a Callback to create the BcsType with any passed in generics
  	 */
  registerBcsType(typeName, createType) {
    this.registerType(
      typeName,
      (writer, data, typeParams) => {
        const generics = typeParams.map(
          (param) => new BcsType({
            name: String(param),
            write: (data2, writer2) => {
              const { name, params } = this.parseTypeName(param);
              const typeInterface = this.getTypeInterface(name);
              const typeMap = params.reduce((acc, value, index) => {
                return Object.assign(acc, { [value]: typeParams[index] });
              }, {});
              return typeInterface._encodeRaw.call(this, writer2, data2, params, typeMap);
            },
            read: () => {
              throw new Error("Not implemented");
            }
          })
        );
        createType(...generics).write(data, writer);
        return writer;
      },
      (reader, typeParams) => {
        const generics = typeParams.map(
          (param) => new BcsType({
            name: String(param),
            write: (data, writer) => {
              throw new Error("Not implemented");
            },
            read: (reader2) => {
              const { name, params } = this.parseTypeName(param);
              const typeInterface = this.getTypeInterface(name);
              const typeMap = params.reduce((acc, value, index) => {
                return Object.assign(acc, { [value]: typeParams[index] });
              }, {});
              return typeInterface._decodeRaw.call(this, reader2, params, typeMap);
            }
          })
        );
        return createType(...generics).read(reader);
      }
    );
    return this;
  }
  /**
   * Register an address type which is a sequence of U8s of specified length.
   * @example
   * bcs.registerAddressType('address', SUI_ADDRESS_LENGTH);
   * let addr = bcs.de('address', 'c3aca510c785c7094ac99aeaa1e69d493122444df50bb8a99dfa790c654a79af');
   *
   * @param name Name of the address type.
   * @param length Byte length of the address.
   * @param encoding Encoding to use for the address type
   * @returns
   */
  registerAddressType(name, length, encoding = "hex") {
    switch (encoding) {
      case "base64":
        return this.registerType(
          name,
          function encodeAddress(writer, data) {
            return fromB64(data).reduce((writer2, el) => writer2.write8(el), writer);
          },
          function decodeAddress(reader) {
            return toB64(reader.readBytes(length));
          }
        );
      case "hex":
        return this.registerType(
          name,
          function encodeAddress(writer, data) {
            return fromHEX(data).reduce((writer2, el) => writer2.write8(el), writer);
          },
          function decodeAddress(reader) {
            return toHEX(reader.readBytes(length));
          }
        );
      default:
        throw new Error("Unsupported encoding! Use either hex or base64");
    }
  }
  /**
   * Register custom vector type inside the bcs.
   *
   * @example
   * bcs.registerVectorType('vector<T>'); // generic registration
   * let array = bcs.de('vector<u8>', '06010203040506', 'hex'); // [1,2,3,4,5,6];
   * let again = bcs.ser('vector<u8>', [1,2,3,4,5,6]).toString('hex');
   *
   * @param name Name of the type to register
   * @param elementType Optional name of the inner type of the vector
   * @return Returns self for chaining.
   */
  registerVectorType(typeName) {
    let { name, params } = this.parseTypeName(typeName);
    if (params.length > 1) {
      throw new Error("Vector can have only one type parameter; got " + name);
    }
    return this.registerType(
      typeName,
      function encodeVector(writer, data, typeParams, typeMap) {
        return writer.writeVec(data, (writer2, el) => {
          let elementType = typeParams[0];
          if (!elementType) {
            throw new Error(`Incorrect number of type parameters passed a to vector '${typeName}'`);
          }
          let { name: name2, params: params2 } = this.parseTypeName(elementType);
          if (this.hasType(name2)) {
            return this.getTypeInterface(name2)._encodeRaw.call(this, writer2, el, params2, typeMap);
          }
          if (!(name2 in typeMap)) {
            throw new Error(
              `Unable to find a matching type definition for ${name2} in vector; make sure you passed a generic`
            );
          }
          let { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name2]);
          return this.getTypeInterface(innerName)._encodeRaw.call(
            this,
            writer2,
            el,
            innerParams,
            typeMap
          );
        });
      },
      function decodeVector(reader, typeParams, typeMap) {
        return reader.readVec((reader2) => {
          let elementType = typeParams[0];
          if (!elementType) {
            throw new Error(`Incorrect number of type parameters passed to a vector '${typeName}'`);
          }
          let { name: name2, params: params2 } = this.parseTypeName(elementType);
          if (this.hasType(name2)) {
            return this.getTypeInterface(name2)._decodeRaw.call(this, reader2, params2, typeMap);
          }
          if (!(name2 in typeMap)) {
            throw new Error(
              `Unable to find a matching type definition for ${name2} in vector; make sure you passed a generic`
            );
          }
          let { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name2]);
          return this.getTypeInterface(innerName)._decodeRaw.call(
            this,
            reader2,
            innerParams,
            typeMap
          );
        });
      }
    );
  }
  /**
   * Safe method to register a custom Move struct. The first argument is a name of the
   * struct which is only used on the FrontEnd and has no affect on serialization results,
   * and the second is a struct description passed as an Object.
   *
   * The description object MUST have the same order on all of the platforms (ie in Move
   * or in Rust).
   *
   * @example
   * // Move / Rust struct
   * // struct Coin {
   * //   value: u64,
   * //   owner: vector<u8>, // name // Vec<u8> in Rust
   * //   is_locked: bool,
   * // }
   *
   * bcs.registerStructType('Coin', {
   *   value: bcs.U64,
   *   owner: bcs.STRING,
   *   is_locked: bcs.BOOL
   * });
   *
   * // Created in Rust with diem/bcs
   * // let rust_bcs_str = '80d1b105600000000e4269672057616c6c65742047757900';
   * let rust_bcs_str = [ // using an Array here as BCS works with Uint8Array
   *  128, 209, 177,   5,  96,  0,  0,
   *    0,  14,  66, 105, 103, 32, 87,
   *   97, 108, 108, 101, 116, 32, 71,
   *  117, 121,   0
   * ];
   *
   * // Let's encode the value as well
   * let test_set = bcs.ser('Coin', {
   *   owner: 'Big Wallet Guy',
   *   value: '412412400000',
   *   is_locked: false,
   * });
   *
   * console.assert(Array.from(test_set.toBytes()) === rust_bcs_str, 'Whoopsie, result mismatch');
   *
   * @param name Name of the type to register.
   * @param fields Fields of the struct. Must be in the correct order.
   * @return Returns BCS for chaining.
   */
  registerStructType(typeName, fields) {
    for (let key in fields) {
      let internalName = this.tempKey();
      let value = fields[key];
      if (!Array.isArray(value) && typeof value !== "string") {
        fields[key] = internalName;
        this.registerStructType(internalName, value);
      }
    }
    let struct = Object.freeze(fields);
    let canonicalOrder = Object.keys(struct);
    let { name: structName, params: generics } = this.parseTypeName(typeName);
    return this.registerType(
      typeName,
      function encodeStruct(writer, data, typeParams, typeMap) {
        if (!data || data.constructor !== Object) {
          throw new Error(`Expected ${structName} to be an Object, got: ${data}`);
        }
        if (typeParams.length !== generics.length) {
          throw new Error(
            `Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`
          );
        }
        for (let key of canonicalOrder) {
          if (!(key in data)) {
            throw new Error(`Struct ${structName} requires field ${key}:${struct[key]}`);
          }
          const { name: fieldType, params: fieldParams } = this.parseTypeName(
            struct[key]
          );
          if (!generics.includes(fieldType)) {
            this.getTypeInterface(fieldType)._encodeRaw.call(
              this,
              writer,
              data[key],
              fieldParams,
              typeMap
            );
          } else {
            const paramIdx = generics.indexOf(fieldType);
            let { name, params } = this.parseTypeName(typeParams[paramIdx]);
            if (this.hasType(name)) {
              this.getTypeInterface(name)._encodeRaw.call(
                this,
                writer,
                data[key],
                params,
                typeMap
              );
              continue;
            }
            if (!(name in typeMap)) {
              throw new Error(
                `Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`
              );
            }
            let { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);
            this.getTypeInterface(innerName)._encodeRaw.call(
              this,
              writer,
              data[key],
              innerParams,
              typeMap
            );
          }
        }
        return writer;
      },
      function decodeStruct(reader, typeParams, typeMap) {
        if (typeParams.length !== generics.length) {
          throw new Error(
            `Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`
          );
        }
        let result = {};
        for (let key of canonicalOrder) {
          const { name: fieldName, params: fieldParams } = this.parseTypeName(
            struct[key]
          );
          if (!generics.includes(fieldName)) {
            result[key] = this.getTypeInterface(fieldName)._decodeRaw.call(
              this,
              reader,
              fieldParams,
              typeMap
            );
          } else {
            const paramIdx = generics.indexOf(fieldName);
            let { name, params } = this.parseTypeName(typeParams[paramIdx]);
            if (this.hasType(name)) {
              result[key] = this.getTypeInterface(name)._decodeRaw.call(
                this,
                reader,
                params,
                typeMap
              );
              continue;
            }
            if (!(name in typeMap)) {
              throw new Error(
                `Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`
              );
            }
            let { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);
            result[key] = this.getTypeInterface(innerName)._decodeRaw.call(
              this,
              reader,
              innerParams,
              typeMap
            );
          }
        }
        return result;
      }
    );
  }
  /**
   * Safe method to register custom enum type where each invariant holds the value of another type.
   * @example
   * bcs.registerStructType('Coin', { value: 'u64' });
   * bcs.registerEnumType('MyEnum', {
   *  single: 'Coin',
   *  multi: 'vector<Coin>',
   *  empty: null
   * });
   *
   * console.log(
   *  bcs.de('MyEnum', 'AICWmAAAAAAA', 'base64'), // { single: { value: 10000000 } }
   *  bcs.de('MyEnum', 'AQIBAAAAAAAAAAIAAAAAAAAA', 'base64')  // { multi: [ { value: 1 }, { value: 2 } ] }
   * )
   *
   * // and serialization
   * bcs.ser('MyEnum', { single: { value: 10000000 } }).toBytes();
   * bcs.ser('MyEnum', { multi: [ { value: 1 }, { value: 2 } ] });
   *
   * @param name
   * @param variants
   */
  registerEnumType(typeName, variants) {
    for (let key in variants) {
      let internalName = this.tempKey();
      let value = variants[key];
      if (value !== null && !Array.isArray(value) && typeof value !== "string") {
        variants[key] = internalName;
        this.registerStructType(internalName, value);
      }
    }
    let struct = Object.freeze(variants);
    let canonicalOrder = Object.keys(struct);
    let { name, params: canonicalTypeParams } = this.parseTypeName(typeName);
    return this.registerType(
      typeName,
      function encodeEnum(writer, data, typeParams, typeMap) {
        if (!data) {
          throw new Error(`Unable to write enum "${name}", missing data.
Received: "${data}"`);
        }
        if (typeof data !== "object") {
          throw new Error(
            `Incorrect data passed into enum "${name}", expected object with properties: "${canonicalOrder.join(
              " | "
            )}".
Received: "${JSON.stringify(data)}"`
          );
        }
        let key = Object.keys(data)[0];
        if (key === void 0) {
          throw new Error(`Empty object passed as invariant of the enum "${name}"`);
        }
        let orderByte = canonicalOrder.indexOf(key);
        if (orderByte === -1) {
          throw new Error(
            `Unknown invariant of the enum "${name}", allowed values: "${canonicalOrder.join(
              " | "
            )}"; received "${key}"`
          );
        }
        let invariant = canonicalOrder[orderByte];
        let invariantType = struct[invariant];
        writer.write8(orderByte);
        if (invariantType === null) {
          return writer;
        }
        let paramIndex = canonicalTypeParams.indexOf(invariantType);
        let typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];
        {
          let { name: name2, params } = this.parseTypeName(typeOrParam);
          return this.getTypeInterface(name2)._encodeRaw.call(
            this,
            writer,
            data[key],
            params,
            typeMap
          );
        }
      },
      function decodeEnum(reader, typeParams, typeMap) {
        let orderByte = reader.readULEB();
        let invariant = canonicalOrder[orderByte];
        let invariantType = struct[invariant];
        if (orderByte === -1) {
          throw new Error(
            `Decoding type mismatch, expected enum "${name}" invariant index, received "${orderByte}"`
          );
        }
        if (invariantType === null) {
          return { [invariant]: true };
        }
        let paramIndex = canonicalTypeParams.indexOf(invariantType);
        let typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];
        {
          let { name: name2, params } = this.parseTypeName(typeOrParam);
          return {
            [invariant]: this.getTypeInterface(name2)._decodeRaw.call(this, reader, params, typeMap)
          };
        }
      }
    );
  }
  /**
   * Get a set of encoders/decoders for specific type.
   * Mainly used to define custom type de/serialization logic.
   *
   * @param type
   * @returns {TypeInterface}
   */
  getTypeInterface(type) {
    let typeInterface = this.types.get(type);
    if (typeof typeInterface === "string") {
      let chain = [];
      while (typeof typeInterface === "string") {
        if (chain.includes(typeInterface)) {
          throw new Error(`Recursive definition found: ${chain.join(" -> ")} -> ${typeInterface}`);
        }
        chain.push(typeInterface);
        typeInterface = this.types.get(typeInterface);
      }
    }
    if (typeInterface === void 0) {
      throw new Error(`Type ${type} is not registered`);
    }
    return typeInterface;
  }
  /**
   * Parse a type name and get the type's generics.
   * @example
   * let { typeName, typeParams } = parseTypeName('Option<Coin<SUI>>');
   * // typeName: Option
   * // typeParams: [ 'Coin<SUI>' ]
   *
   * @param name Name of the type to process
   * @returns Object with typeName and typeParams listed as Array
   */
  parseTypeName(name) {
    if (Array.isArray(name)) {
      let [typeName2, ...params2] = name;
      return { name: typeName2, params: params2 };
    }
    if (typeof name !== "string") {
      throw new Error(`Illegal type passed as a name of the type: ${name}`);
    }
    let [left, right] = this.schema.genericSeparators || ["<", ">"];
    let l_bound = name.indexOf(left);
    let r_bound = Array.from(name).reverse().indexOf(right);
    if (l_bound === -1 && r_bound === -1) {
      return { name, params: [] };
    }
    if (l_bound === -1 || r_bound === -1) {
      throw new Error(`Unclosed generic in name '${name}'`);
    }
    let typeName = name.slice(0, l_bound);
    let params = splitGenericParameters(
      name.slice(l_bound + 1, name.length - r_bound - 1),
      this.schema.genericSeparators
    );
    return { name: typeName, params };
  }
};
_BCS.U8 = "u8";
_BCS.U16 = "u16";
_BCS.U32 = "u32";
_BCS.U64 = "u64";
_BCS.U128 = "u128";
_BCS.U256 = "u256";
_BCS.BOOL = "bool";
_BCS.VECTOR = "vector";
_BCS.ADDRESS = "address";
_BCS.STRING = "string";
_BCS.HEX = "hex-string";
_BCS.BASE58 = "base58-string";
_BCS.BASE64 = "base64-string";
var BCS = _BCS;
function registerPrimitives(bcs2) {
  bcs2.registerType(
    BCS.U8,
    function(writer, data) {
      return writer.write8(data);
    },
    function(reader) {
      return reader.read8();
    },
    (u82) => u82 < 256
  );
  bcs2.registerType(
    BCS.U16,
    function(writer, data) {
      return writer.write16(data);
    },
    function(reader) {
      return reader.read16();
    },
    (u16) => u16 < 65536
  );
  bcs2.registerType(
    BCS.U32,
    function(writer, data) {
      return writer.write32(data);
    },
    function(reader) {
      return reader.read32();
    },
    (u32) => u32 <= 4294967296n
  );
  bcs2.registerType(
    BCS.U64,
    function(writer, data) {
      return writer.write64(data);
    },
    function(reader) {
      return reader.read64();
    }
  );
  bcs2.registerType(
    BCS.U128,
    function(writer, data) {
      return writer.write128(data);
    },
    function(reader) {
      return reader.read128();
    }
  );
  bcs2.registerType(
    BCS.U256,
    function(writer, data) {
      return writer.write256(data);
    },
    function(reader) {
      return reader.read256();
    }
  );
  bcs2.registerType(
    BCS.BOOL,
    function(writer, data) {
      return writer.write8(data);
    },
    function(reader) {
      return reader.read8().toString(10) === "1";
    }
  );
  bcs2.registerType(
    BCS.STRING,
    function(writer, data) {
      return writer.writeVec(Array.from(data), (writer2, el) => writer2.write8(el.charCodeAt(0)));
    },
    function(reader) {
      return reader.readVec((reader2) => reader2.read8()).map((el) => String.fromCharCode(Number(el))).join("");
    },
    (_str) => true
  );
  bcs2.registerType(
    BCS.HEX,
    function(writer, data) {
      return writer.writeVec(Array.from(fromHEX(data)), (writer2, el) => writer2.write8(el));
    },
    function(reader) {
      let bytes = reader.readVec((reader2) => reader2.read8());
      return toHEX(new Uint8Array(bytes));
    }
  );
  bcs2.registerType(
    BCS.BASE58,
    function(writer, data) {
      return writer.writeVec(Array.from(fromB58(data)), (writer2, el) => writer2.write8(el));
    },
    function(reader) {
      let bytes = reader.readVec((reader2) => reader2.read8());
      return toB58(new Uint8Array(bytes));
    }
  );
  bcs2.registerType(
    BCS.BASE64,
    function(writer, data) {
      return writer.writeVec(Array.from(fromB64(data)), (writer2, el) => writer2.write8(el));
    },
    function(reader) {
      let bytes = reader.readVec((reader2) => reader2.read8());
      return toB64(new Uint8Array(bytes));
    }
  );
}
function getSuiMoveConfig() {
  return {
    genericSeparators: ["<", ">"],
    vectorType: "vector",
    addressLength: SUI_ADDRESS_LENGTH,
    addressEncoding: "hex"
  };
}

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/utils/sui-types.js
var TX_DIGEST_LENGTH = 32;
function isValidTransactionDigest(value) {
  try {
    const buffer = fromB58(value);
    return buffer.length === TX_DIGEST_LENGTH;
  } catch (e5) {
    return false;
  }
}
var SUI_ADDRESS_LENGTH2 = 32;
function isValidSuiAddress(value) {
  return isHex(value) && getHexByteLength(value) === SUI_ADDRESS_LENGTH2;
}
function isValidSuiObjectId(value) {
  return isValidSuiAddress(value);
}
function normalizeSuiAddress(value, forceAdd0x = false) {
  let address = value.toLowerCase();
  if (!forceAdd0x && address.startsWith("0x")) {
    address = address.slice(2);
  }
  return `0x${address.padStart(SUI_ADDRESS_LENGTH2 * 2, "0")}`;
}
function normalizeSuiObjectId(value, forceAdd0x = false) {
  return normalizeSuiAddress(value, forceAdd0x);
}
function isHex(value) {
  return /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;
}
function getHexByteLength(value) {
  return /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;
}

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/utils/index.js
var MIST_PER_SUI = BigInt(1e9);
var MOVE_STDLIB_ADDRESS = "0x1";
var SUI_FRAMEWORK_ADDRESS = "0x2";
var SUI_CLOCK_OBJECT_ID = normalizeSuiObjectId("0x6");
var SUI_TYPE_ARG = `${SUI_FRAMEWORK_ADDRESS}::sui::SUI`;
var SUI_SYSTEM_STATE_OBJECT_ID = normalizeSuiObjectId("0x5");

// node_modules/@stitches/react/dist/index.mjs
var import_react44 = __toESM(require_react(), 1);
var e4 = "colors";
var t18 = "sizes";
var r9 = "space";
var n7 = { gap: r9, gridGap: r9, columnGap: r9, gridColumnGap: r9, rowGap: r9, gridRowGap: r9, inset: r9, insetBlock: r9, insetBlockEnd: r9, insetBlockStart: r9, insetInline: r9, insetInlineEnd: r9, insetInlineStart: r9, margin: r9, marginTop: r9, marginRight: r9, marginBottom: r9, marginLeft: r9, marginBlock: r9, marginBlockEnd: r9, marginBlockStart: r9, marginInline: r9, marginInlineEnd: r9, marginInlineStart: r9, padding: r9, paddingTop: r9, paddingRight: r9, paddingBottom: r9, paddingLeft: r9, paddingBlock: r9, paddingBlockEnd: r9, paddingBlockStart: r9, paddingInline: r9, paddingInlineEnd: r9, paddingInlineStart: r9, top: r9, right: r9, bottom: r9, left: r9, scrollMargin: r9, scrollMarginTop: r9, scrollMarginRight: r9, scrollMarginBottom: r9, scrollMarginLeft: r9, scrollMarginX: r9, scrollMarginY: r9, scrollMarginBlock: r9, scrollMarginBlockEnd: r9, scrollMarginBlockStart: r9, scrollMarginInline: r9, scrollMarginInlineEnd: r9, scrollMarginInlineStart: r9, scrollPadding: r9, scrollPaddingTop: r9, scrollPaddingRight: r9, scrollPaddingBottom: r9, scrollPaddingLeft: r9, scrollPaddingX: r9, scrollPaddingY: r9, scrollPaddingBlock: r9, scrollPaddingBlockEnd: r9, scrollPaddingBlockStart: r9, scrollPaddingInline: r9, scrollPaddingInlineEnd: r9, scrollPaddingInlineStart: r9, fontSize: "fontSizes", background: e4, backgroundColor: e4, backgroundImage: e4, borderImage: e4, border: e4, borderBlock: e4, borderBlockEnd: e4, borderBlockStart: e4, borderBottom: e4, borderBottomColor: e4, borderColor: e4, borderInline: e4, borderInlineEnd: e4, borderInlineStart: e4, borderLeft: e4, borderLeftColor: e4, borderRight: e4, borderRightColor: e4, borderTop: e4, borderTopColor: e4, caretColor: e4, color: e4, columnRuleColor: e4, fill: e4, outline: e4, outlineColor: e4, stroke: e4, textDecorationColor: e4, fontFamily: "fonts", fontWeight: "fontWeights", lineHeight: "lineHeights", letterSpacing: "letterSpacings", blockSize: t18, minBlockSize: t18, maxBlockSize: t18, inlineSize: t18, minInlineSize: t18, maxInlineSize: t18, width: t18, minWidth: t18, maxWidth: t18, height: t18, minHeight: t18, maxHeight: t18, flexBasis: t18, gridTemplateColumns: t18, gridTemplateRows: t18, borderWidth: "borderWidths", borderTopWidth: "borderWidths", borderRightWidth: "borderWidths", borderBottomWidth: "borderWidths", borderLeftWidth: "borderWidths", borderStyle: "borderStyles", borderTopStyle: "borderStyles", borderRightStyle: "borderStyles", borderBottomStyle: "borderStyles", borderLeftStyle: "borderStyles", borderRadius: "radii", borderTopLeftRadius: "radii", borderTopRightRadius: "radii", borderBottomRightRadius: "radii", borderBottomLeftRadius: "radii", boxShadow: "shadows", textShadow: "shadows", transition: "transitions", zIndex: "zIndices" };
var i8 = (e5, t19) => "function" == typeof t19 ? { "()": Function.prototype.toString.call(t19) } : t19;
var o13 = () => {
  const e5 = /* @__PURE__ */ Object.create(null);
  return (t19, r10, ...n8) => {
    const o14 = ((e6) => JSON.stringify(e6, i8))(t19);
    return o14 in e5 ? e5[o14] : e5[o14] = r10(t19, ...n8);
  };
};
var l13 = Symbol.for("sxs.internal");
var s17 = (e5, t19) => Object.defineProperties(e5, Object.getOwnPropertyDescriptors(t19));
var a10 = (e5) => {
  for (const t19 in e5)
    return true;
  return false;
};
var { hasOwnProperty: c13 } = Object.prototype;
var d16 = (e5) => e5.includes("-") ? e5 : e5.replace(/[A-Z]/g, (e6) => "-" + e6.toLowerCase());
var g5 = /\s+(?![^()]*\))/;
var p7 = (e5) => (t19) => e5(..."string" == typeof t19 ? String(t19).split(g5) : [t19]);
var u13 = { appearance: (e5) => ({ WebkitAppearance: e5, appearance: e5 }), backfaceVisibility: (e5) => ({ WebkitBackfaceVisibility: e5, backfaceVisibility: e5 }), backdropFilter: (e5) => ({ WebkitBackdropFilter: e5, backdropFilter: e5 }), backgroundClip: (e5) => ({ WebkitBackgroundClip: e5, backgroundClip: e5 }), boxDecorationBreak: (e5) => ({ WebkitBoxDecorationBreak: e5, boxDecorationBreak: e5 }), clipPath: (e5) => ({ WebkitClipPath: e5, clipPath: e5 }), content: (e5) => ({ content: e5.includes('"') || e5.includes("'") || /^([A-Za-z]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)$/.test(e5) ? e5 : `"${e5}"` }), hyphens: (e5) => ({ WebkitHyphens: e5, hyphens: e5 }), maskImage: (e5) => ({ WebkitMaskImage: e5, maskImage: e5 }), maskSize: (e5) => ({ WebkitMaskSize: e5, maskSize: e5 }), tabSize: (e5) => ({ MozTabSize: e5, tabSize: e5 }), textSizeAdjust: (e5) => ({ WebkitTextSizeAdjust: e5, textSizeAdjust: e5 }), userSelect: (e5) => ({ WebkitUserSelect: e5, userSelect: e5 }), marginBlock: p7((e5, t19) => ({ marginBlockStart: e5, marginBlockEnd: t19 || e5 })), marginInline: p7((e5, t19) => ({ marginInlineStart: e5, marginInlineEnd: t19 || e5 })), maxSize: p7((e5, t19) => ({ maxBlockSize: e5, maxInlineSize: t19 || e5 })), minSize: p7((e5, t19) => ({ minBlockSize: e5, minInlineSize: t19 || e5 })), paddingBlock: p7((e5, t19) => ({ paddingBlockStart: e5, paddingBlockEnd: t19 || e5 })), paddingInline: p7((e5, t19) => ({ paddingInlineStart: e5, paddingInlineEnd: t19 || e5 })) };
var h9 = /([\d.]+)([^]*)/;
var f14 = (e5, t19) => e5.length ? e5.reduce((e6, r10) => (e6.push(...t19.map((e7) => e7.includes("&") ? e7.replace(/&/g, /[ +>|~]/.test(r10) && /&.*&/.test(e7) ? `:is(${r10})` : r10) : r10 + " " + e7)), e6), []) : t19;
var m12 = (e5, t19) => e5 in b7 && "string" == typeof t19 ? t19.replace(/^((?:[^]*[^\w-])?)(fit-content|stretch)((?:[^\w-][^]*)?)$/, (t20, r10, n8, i9) => r10 + ("stretch" === n8 ? `-moz-available${i9};${d16(e5)}:${r10}-webkit-fill-available` : `-moz-fit-content${i9};${d16(e5)}:${r10}fit-content`) + i9) : String(t19);
var b7 = { blockSize: 1, height: 1, inlineSize: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, width: 1 };
var S10 = (e5) => e5 ? e5 + "-" : "";
var k3 = (e5, t19, r10) => e5.replace(/([+-])?((?:\d+(?:\.\d*)?|\.\d+)(?:[Ee][+-]?\d+)?)?(\$|--)([$\w-]+)/g, (e6, n8, i9, o14, l14) => "$" == o14 == !!i9 ? e6 : (n8 || "--" == o14 ? "calc(" : "") + "var(--" + ("$" === o14 ? S10(t19) + (l14.includes("$") ? "" : S10(r10)) + l14.replace(/\$/g, "-") : l14) + ")" + (n8 || "--" == o14 ? "*" + (n8 || "") + (i9 || "1") + ")" : ""));
var y7 = /\s*,\s*(?![^()]*\))/;
var B4 = Object.prototype.toString;
var $6 = (e5, t19, r10, n8, i9) => {
  let o14, l14, s18;
  const a11 = (e6, t20, r11) => {
    let c14, g6;
    const p8 = (e7) => {
      for (c14 in e7) {
        const R5 = 64 === c14.charCodeAt(0), z5 = R5 && Array.isArray(e7[c14]) ? e7[c14] : [e7[c14]];
        for (g6 of z5) {
          const e8 = /[A-Z]/.test($7 = c14) ? $7 : $7.replace(/-[^]/g, (e9) => e9[1].toUpperCase()), z6 = "object" == typeof g6 && g6 && g6.toString === B4 && (!n8.utils[e8] || !t20.length);
          if (e8 in n8.utils && !z6) {
            const t21 = n8.utils[e8];
            if (t21 !== l14) {
              l14 = t21, p8(t21(g6)), l14 = null;
              continue;
            }
          } else if (e8 in u13) {
            const t21 = u13[e8];
            if (t21 !== s18) {
              s18 = t21, p8(t21(g6)), s18 = null;
              continue;
            }
          }
          if (R5 && (b8 = c14.slice(1) in n8.media ? "@media " + n8.media[c14.slice(1)] : c14, c14 = b8.replace(/\(\s*([\w-]+)\s*(=|<|<=|>|>=)\s*([\w-]+)\s*(?:(<|<=|>|>=)\s*([\w-]+)\s*)?\)/g, (e9, t21, r12, n9, i10, o15) => {
            const l15 = h9.test(t21), s19 = 0.0625 * (l15 ? -1 : 1), [a12, c15] = l15 ? [n9, t21] : [t21, n9];
            return "(" + ("=" === r12[0] ? "" : ">" === r12[0] === l15 ? "max-" : "min-") + a12 + ":" + ("=" !== r12[0] && 1 === r12.length ? c15.replace(h9, (e10, t22, n10) => Number(t22) + s19 * (">" === r12 ? 1 : -1) + n10) : c15) + (i10 ? ") and (" + (">" === i10[0] ? "min-" : "max-") + a12 + ":" + (1 === i10.length ? o15.replace(h9, (e10, t22, r13) => Number(t22) + s19 * (">" === i10 ? -1 : 1) + r13) : o15) : "") + ")";
          })), z6) {
            const e9 = R5 ? r11.concat(c14) : [...r11], n9 = R5 ? [...t20] : f14(t20, c14.split(y7));
            void 0 !== o14 && i9(x4(...o14)), o14 = void 0, a11(g6, n9, e9);
          } else
            void 0 === o14 && (o14 = [[], t20, r11]), c14 = R5 || 36 !== c14.charCodeAt(0) ? c14 : `--${S10(n8.prefix)}${c14.slice(1).replace(/\$/g, "-")}`, g6 = z6 ? g6 : "number" == typeof g6 ? g6 && e8 in I11 ? String(g6) + "px" : String(g6) : k3(m12(e8, null == g6 ? "" : g6), n8.prefix, n8.themeMap[e8]), o14[0].push(`${R5 ? `${c14} ` : `${d16(c14)}:`}${g6}`);
        }
      }
      var b8, $7;
    };
    p8(e6), void 0 !== o14 && i9(x4(...o14)), o14 = void 0;
  };
  a11(e5, t19, r10);
};
var x4 = (e5, t19, r10) => `${r10.map((e6) => `${e6}{`).join("")}${t19.length ? `${t19.join(",")}{` : ""}${e5.join(";")}${t19.length ? "}" : ""}${Array(r10.length ? r10.length + 1 : 0).join("}")}`;
var I11 = { animationDelay: 1, animationDuration: 1, backgroundSize: 1, blockSize: 1, border: 1, borderBlock: 1, borderBlockEnd: 1, borderBlockEndWidth: 1, borderBlockStart: 1, borderBlockStartWidth: 1, borderBlockWidth: 1, borderBottom: 1, borderBottomLeftRadius: 1, borderBottomRightRadius: 1, borderBottomWidth: 1, borderEndEndRadius: 1, borderEndStartRadius: 1, borderInlineEnd: 1, borderInlineEndWidth: 1, borderInlineStart: 1, borderInlineStartWidth: 1, borderInlineWidth: 1, borderLeft: 1, borderLeftWidth: 1, borderRadius: 1, borderRight: 1, borderRightWidth: 1, borderSpacing: 1, borderStartEndRadius: 1, borderStartStartRadius: 1, borderTop: 1, borderTopLeftRadius: 1, borderTopRightRadius: 1, borderTopWidth: 1, borderWidth: 1, bottom: 1, columnGap: 1, columnRule: 1, columnRuleWidth: 1, columnWidth: 1, containIntrinsicSize: 1, flexBasis: 1, fontSize: 1, gap: 1, gridAutoColumns: 1, gridAutoRows: 1, gridTemplateColumns: 1, gridTemplateRows: 1, height: 1, inlineSize: 1, inset: 1, insetBlock: 1, insetBlockEnd: 1, insetBlockStart: 1, insetInline: 1, insetInlineEnd: 1, insetInlineStart: 1, left: 1, letterSpacing: 1, margin: 1, marginBlock: 1, marginBlockEnd: 1, marginBlockStart: 1, marginBottom: 1, marginInline: 1, marginInlineEnd: 1, marginInlineStart: 1, marginLeft: 1, marginRight: 1, marginTop: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, offsetDistance: 1, offsetRotate: 1, outline: 1, outlineOffset: 1, outlineWidth: 1, overflowClipMargin: 1, padding: 1, paddingBlock: 1, paddingBlockEnd: 1, paddingBlockStart: 1, paddingBottom: 1, paddingInline: 1, paddingInlineEnd: 1, paddingInlineStart: 1, paddingLeft: 1, paddingRight: 1, paddingTop: 1, perspective: 1, right: 1, rowGap: 1, scrollMargin: 1, scrollMarginBlock: 1, scrollMarginBlockEnd: 1, scrollMarginBlockStart: 1, scrollMarginBottom: 1, scrollMarginInline: 1, scrollMarginInlineEnd: 1, scrollMarginInlineStart: 1, scrollMarginLeft: 1, scrollMarginRight: 1, scrollMarginTop: 1, scrollPadding: 1, scrollPaddingBlock: 1, scrollPaddingBlockEnd: 1, scrollPaddingBlockStart: 1, scrollPaddingBottom: 1, scrollPaddingInline: 1, scrollPaddingInlineEnd: 1, scrollPaddingInlineStart: 1, scrollPaddingLeft: 1, scrollPaddingRight: 1, scrollPaddingTop: 1, shapeMargin: 1, textDecoration: 1, textDecorationThickness: 1, textIndent: 1, textUnderlineOffset: 1, top: 1, transitionDelay: 1, transitionDuration: 1, verticalAlign: 1, width: 1, wordSpacing: 1 };
var R4 = (e5) => String.fromCharCode(e5 + (e5 > 25 ? 39 : 97));
var z4 = (e5) => ((e6) => {
  let t19, r10 = "";
  for (t19 = Math.abs(e6); t19 > 52; t19 = t19 / 52 | 0)
    r10 = R4(t19 % 52) + r10;
  return R4(t19 % 52) + r10;
})(((e6, t19) => {
  let r10 = t19.length;
  for (; r10; )
    e6 = 33 * e6 ^ t19.charCodeAt(--r10);
  return e6;
})(5381, JSON.stringify(e5)) >>> 0);
var W = ["themed", "global", "styled", "onevar", "resonevar", "allvar", "inline"];
var j5 = (e5) => {
  if (e5.href && !e5.href.startsWith(location.origin))
    return false;
  try {
    return !!e5.cssRules;
  } catch (e6) {
    return false;
  }
};
var E8 = (e5) => {
  let t19;
  const r10 = () => {
    const { cssRules: e6 } = t19.sheet;
    return [].map.call(e6, (r11, n9) => {
      const { cssText: i9 } = r11;
      let o14 = "";
      if (i9.startsWith("--sxs"))
        return "";
      if (e6[n9 - 1] && (o14 = e6[n9 - 1].cssText).startsWith("--sxs")) {
        if (!r11.cssRules.length)
          return "";
        for (const e7 in t19.rules)
          if (t19.rules[e7].group === r11)
            return `--sxs{--sxs:${[...t19.rules[e7].cache].join(" ")}}${i9}`;
        return r11.cssRules.length ? `${o14}${i9}` : "";
      }
      return i9;
    }).join("");
  }, n8 = () => {
    if (t19) {
      const { rules: e6, sheet: r11 } = t19;
      if (!r11.deleteRule) {
        for (; 3 === Object(Object(r11.cssRules)[0]).type; )
          r11.cssRules.splice(0, 1);
        r11.cssRules = [];
      }
      for (const t20 in e6)
        delete e6[t20];
    }
    const i9 = Object(e5).styleSheets || [];
    for (const e6 of i9)
      if (j5(e6)) {
        for (let i10 = 0, o15 = e6.cssRules; o15[i10]; ++i10) {
          const l15 = Object(o15[i10]);
          if (1 !== l15.type)
            continue;
          const s18 = Object(o15[i10 + 1]);
          if (4 !== s18.type)
            continue;
          ++i10;
          const { cssText: a11 } = l15;
          if (!a11.startsWith("--sxs"))
            continue;
          const c14 = a11.slice(14, -3).trim().split(/\s+/), d17 = W[c14[0]];
          d17 && (t19 || (t19 = { sheet: e6, reset: n8, rules: {}, toString: r10 }), t19.rules[d17] = { group: s18, index: i10, cache: new Set(c14) });
        }
        if (t19)
          break;
      }
    if (!t19) {
      const i10 = (e6, t20) => ({ type: t20, cssRules: [], insertRule(e7, t21) {
        this.cssRules.splice(t21, 0, i10(e7, { import: 3, undefined: 1 }[(e7.toLowerCase().match(/^@([a-z]+)/) || [])[1]] || 4));
      }, get cssText() {
        return "@media{}" === e6 ? `@media{${[].map.call(this.cssRules, (e7) => e7.cssText).join("")}}` : e6;
      } });
      t19 = { sheet: e5 ? (e5.head || e5).appendChild(document.createElement("style")).sheet : i10("", "text/css"), rules: {}, reset: n8, toString: r10 };
    }
    const { sheet: o14, rules: l14 } = t19;
    for (let e6 = W.length - 1; e6 >= 0; --e6) {
      const t20 = W[e6];
      if (!l14[t20]) {
        const r11 = W[e6 + 1], n9 = l14[r11] ? l14[r11].index : o14.cssRules.length;
        o14.insertRule("@media{}", n9), o14.insertRule(`--sxs{--sxs:${e6}}`, n9), l14[t20] = { group: o14.cssRules[n9 + 1], index: n9, cache: /* @__PURE__ */ new Set([e6]) };
      }
      v6(l14[t20]);
    }
  };
  return n8(), t19;
};
var v6 = (e5) => {
  const t19 = e5.group;
  let r10 = t19.cssRules.length;
  e5.apply = (e6) => {
    try {
      t19.insertRule(e6, r10), ++r10;
    } catch (e7) {
    }
  };
};
var T7 = Symbol();
var w6 = o13();
var M7 = (e5, t19) => w6(e5, () => (...r10) => {
  let n8 = { type: null, composers: /* @__PURE__ */ new Set() };
  for (const t20 of r10)
    if (null != t20)
      if (t20[l13]) {
        null == n8.type && (n8.type = t20[l13].type);
        for (const e6 of t20[l13].composers)
          n8.composers.add(e6);
      } else
        t20.constructor !== Object || t20.$$typeof ? null == n8.type && (n8.type = t20) : n8.composers.add(C7(t20, e5));
  return null == n8.type && (n8.type = "span"), n8.composers.size || n8.composers.add(["PJLV", {}, [], [], {}, []]), P5(e5, n8, t19);
});
var C7 = ({ variants: e5, compoundVariants: t19, defaultVariants: r10, ...n8 }, i9) => {
  const o14 = `${S10(i9.prefix)}c-${z4(n8)}`, l14 = [], s18 = [], d17 = /* @__PURE__ */ Object.create(null), g6 = [];
  for (const e6 in r10)
    d17[e6] = String(r10[e6]);
  if ("object" == typeof e5 && e5)
    for (const t20 in e5) {
      p8 = d17, u14 = t20, c13.call(p8, u14) || (d17[t20] = "undefined");
      const r11 = e5[t20];
      for (const e6 in r11) {
        const n9 = { [t20]: String(e6) };
        "undefined" === String(e6) && g6.push(t20);
        const i10 = r11[e6], o15 = [n9, i10, !a10(i10)];
        l14.push(o15);
      }
    }
  var p8, u14;
  if ("object" == typeof t19 && t19)
    for (const e6 of t19) {
      let { css: t20, ...r11 } = e6;
      t20 = "object" == typeof t20 && t20 || {};
      for (const e7 in r11)
        r11[e7] = String(r11[e7]);
      const n9 = [r11, t20, !a10(t20)];
      s18.push(n9);
    }
  return [o14, n8, l14, s18, d17, g6];
};
var P5 = (e5, t19, r10) => {
  const [n8, i9, o14, a11] = L2(t19.composers), c14 = "function" == typeof t19.type || t19.type.$$typeof ? ((e6) => {
    function t20() {
      for (let r11 = 0; r11 < t20[T7].length; r11++) {
        const [n9, i10] = t20[T7][r11];
        e6.rules[n9].apply(i10);
      }
      return t20[T7] = [], null;
    }
    return t20[T7] = [], t20.rules = {}, W.forEach((e7) => t20.rules[e7] = { apply: (r11) => t20[T7].push([e7, r11]) }), t20;
  })(r10) : null, d17 = (c14 || r10).rules, g6 = `.${n8}${i9.length > 1 ? `:where(.${i9.slice(1).join(".")})` : ""}`, p8 = (l14) => {
    l14 = "object" == typeof l14 && l14 || A3;
    const { css: s18, ...p9 } = l14, u14 = {};
    for (const e6 in o14)
      if (delete p9[e6], e6 in l14) {
        let t20 = l14[e6];
        "object" == typeof t20 && t20 ? u14[e6] = { "@initial": o14[e6], ...t20 } : (t20 = String(t20), u14[e6] = "undefined" !== t20 || a11.has(e6) ? t20 : o14[e6]);
      } else
        u14[e6] = o14[e6];
    const h10 = /* @__PURE__ */ new Set([...i9]);
    for (const [n9, i10, o15, l15] of t19.composers) {
      r10.rules.styled.cache.has(n9) || (r10.rules.styled.cache.add(n9), $6(i10, [`.${n9}`], [], e5, (e6) => {
        d17.styled.apply(e6);
      }));
      const t20 = O4(o15, u14, e5.media), s19 = O4(l15, u14, e5.media, true);
      for (const i11 of t20)
        if (void 0 !== i11)
          for (const [t21, o16, l16] of i11) {
            const i12 = `${n9}-${z4(o16)}-${t21}`;
            h10.add(i12);
            const s20 = (l16 ? r10.rules.resonevar : r10.rules.onevar).cache, a12 = l16 ? d17.resonevar : d17.onevar;
            s20.has(i12) || (s20.add(i12), $6(o16, [`.${i12}`], [], e5, (e6) => {
              a12.apply(e6);
            }));
          }
      for (const t21 of s19)
        if (void 0 !== t21)
          for (const [i11, o16] of t21) {
            const t22 = `${n9}-${z4(o16)}-${i11}`;
            h10.add(t22), r10.rules.allvar.cache.has(t22) || (r10.rules.allvar.cache.add(t22), $6(o16, [`.${t22}`], [], e5, (e6) => {
              d17.allvar.apply(e6);
            }));
          }
    }
    if ("object" == typeof s18 && s18) {
      const t20 = `${n8}-i${z4(s18)}-css`;
      h10.add(t20), r10.rules.inline.cache.has(t20) || (r10.rules.inline.cache.add(t20), $6(s18, [`.${t20}`], [], e5, (e6) => {
        d17.inline.apply(e6);
      }));
    }
    for (const e6 of String(l14.className || "").trim().split(/\s+/))
      e6 && h10.add(e6);
    const f15 = p9.className = [...h10].join(" ");
    return { type: t19.type, className: f15, selector: g6, props: p9, toString: () => f15, deferredInjector: c14 };
  };
  return s17(p8, { className: n8, selector: g6, [l13]: t19, toString: () => (r10.rules.styled.cache.has(n8) || p8(), n8) });
};
var L2 = (e5) => {
  let t19 = "";
  const r10 = [], n8 = {}, i9 = [];
  for (const [o14, , , , l14, s18] of e5) {
    "" === t19 && (t19 = o14), r10.push(o14), i9.push(...s18);
    for (const e6 in l14) {
      const t20 = l14[e6];
      (void 0 === n8[e6] || "undefined" !== t20 || s18.includes(t20)) && (n8[e6] = t20);
    }
  }
  return [t19, r10, n8, new Set(i9)];
};
var O4 = (e5, t19, r10, n8) => {
  const i9 = [];
  e:
    for (let [o14, l14, s18] of e5) {
      if (s18)
        continue;
      let e6, a11 = 0, c14 = false;
      for (e6 in o14) {
        const n9 = o14[e6];
        let i10 = t19[e6];
        if (i10 !== n9) {
          if ("object" != typeof i10 || !i10)
            continue e;
          {
            let e7, t20, o15 = 0;
            for (const l15 in i10) {
              if (n9 === String(i10[l15])) {
                if ("@initial" !== l15) {
                  const e8 = l15.slice(1);
                  (t20 = t20 || []).push(e8 in r10 ? r10[e8] : l15.replace(/^@media ?/, "")), c14 = true;
                }
                a11 += o15, e7 = true;
              }
              ++o15;
            }
            if (t20 && t20.length && (l14 = { ["@media " + t20.join(", ")]: l14 }), !e7)
              continue e;
          }
        }
      }
      (i9[a11] = i9[a11] || []).push([n8 ? "cv" : `${e6}-${o14[e6]}`, l14, c14]);
    }
  return i9;
};
var A3 = {};
var N7 = o13();
var D7 = (e5, t19) => N7(e5, () => (...r10) => {
  const n8 = () => {
    for (let n9 of r10) {
      n9 = "object" == typeof n9 && n9 || {};
      let r11 = z4(n9);
      if (!t19.rules.global.cache.has(r11)) {
        if (t19.rules.global.cache.add(r11), "@import" in n9) {
          let e6 = [].indexOf.call(t19.sheet.cssRules, t19.rules.themed.group) - 1;
          for (let r12 of [].concat(n9["@import"]))
            r12 = r12.includes('"') || r12.includes("'") ? r12 : `"${r12}"`, t19.sheet.insertRule(`@import ${r12};`, e6++);
          delete n9["@import"];
        }
        $6(n9, [], [], e5, (e6) => {
          t19.rules.global.apply(e6);
        });
      }
    }
    return "";
  };
  return s17(n8, { toString: n8 });
});
var H6 = o13();
var V5 = (e5, t19) => H6(e5, () => (r10) => {
  const n8 = `${S10(e5.prefix)}k-${z4(r10)}`, i9 = () => {
    if (!t19.rules.global.cache.has(n8)) {
      t19.rules.global.cache.add(n8);
      const i10 = [];
      $6(r10, [], [], e5, (e6) => i10.push(e6));
      const o14 = `@keyframes ${n8}{${i10.join("")}}`;
      t19.rules.global.apply(o14);
    }
    return n8;
  };
  return s17(i9, { get name() {
    return i9();
  }, toString: i9 });
});
var G4 = class {
  constructor(e5, t19, r10, n8) {
    this.token = null == e5 ? "" : String(e5), this.value = null == t19 ? "" : String(t19), this.scale = null == r10 ? "" : String(r10), this.prefix = null == n8 ? "" : String(n8);
  }
  get computedValue() {
    return "var(" + this.variable + ")";
  }
  get variable() {
    return "--" + S10(this.prefix) + S10(this.scale) + this.token;
  }
  toString() {
    return this.computedValue;
  }
};
var F10 = o13();
var J6 = (e5, t19) => F10(e5, () => (r10, n8) => {
  n8 = "object" == typeof r10 && r10 || Object(n8);
  const i9 = `.${r10 = (r10 = "string" == typeof r10 ? r10 : "") || `${S10(e5.prefix)}t-${z4(n8)}`}`, o14 = {}, l14 = [];
  for (const t20 in n8) {
    o14[t20] = {};
    for (const r11 in n8[t20]) {
      const i10 = `--${S10(e5.prefix)}${t20}-${r11}`, s19 = k3(String(n8[t20][r11]), e5.prefix, t20);
      o14[t20][r11] = new G4(r11, s19, t20, e5.prefix), l14.push(`${i10}:${s19}`);
    }
  }
  const s18 = () => {
    if (l14.length && !t19.rules.themed.cache.has(r10)) {
      t19.rules.themed.cache.add(r10);
      const i10 = `${n8 === e5.theme ? ":root," : ""}.${r10}{${l14.join(";")}}`;
      t19.rules.themed.apply(i10);
    }
    return r10;
  };
  return { ...o14, get className() {
    return s18();
  }, selector: i9, toString: s18 };
});
var U7 = o13();
var X5;
var Y3 = o13();
var q6 = (e5) => {
  const t19 = ((e6) => {
    let t20 = false;
    const r10 = U7(e6, (e7) => {
      t20 = true;
      const r11 = "prefix" in (e7 = "object" == typeof e7 && e7 || {}) ? String(e7.prefix) : "", i9 = "object" == typeof e7.media && e7.media || {}, o14 = "object" == typeof e7.root ? e7.root || null : globalThis.document || null, l14 = "object" == typeof e7.theme && e7.theme || {}, s18 = { prefix: r11, media: i9, theme: l14, themeMap: "object" == typeof e7.themeMap && e7.themeMap || { ...n7 }, utils: "object" == typeof e7.utils && e7.utils || {} }, a11 = E8(o14), c14 = { css: M7(s18, a11), globalCss: D7(s18, a11), keyframes: V5(s18, a11), createTheme: J6(s18, a11), reset() {
        a11.reset(), c14.theme.toString();
      }, theme: {}, sheet: a11, config: s18, prefix: r11, getCssText: a11.toString, toString: a11.toString };
      return String(c14.theme = c14.createTheme(l14)), c14;
    });
    return t20 || r10.reset(), r10;
  })(e5);
  return t19.styled = (({ config: e6, sheet: t20 }) => Y3(e6, () => {
    const r10 = M7(e6, t20);
    return (...e7) => {
      const t21 = r10(...e7), n8 = t21[l13].type, i9 = import_react44.default.forwardRef((e8, r11) => {
        const i10 = e8 && e8.as || n8, { props: o14, deferredInjector: l14 } = t21(e8);
        return delete o14.as, o14.ref = r11, l14 ? import_react44.default.createElement(import_react44.default.Fragment, null, import_react44.default.createElement(i10, o14), import_react44.default.createElement(l14, null)) : import_react44.default.createElement(i10, o14);
      });
      return i9.className = t21.className, i9.displayName = `Styled.${n8.displayName || n8.name || n8}`, i9.selector = t21.selector, i9.toString = () => t21.selector, i9[l13] = t21[l13], i9;
    };
  }))(t19), t19;
};
var K4 = () => X5 || (X5 = q6());
var re5 = (...e5) => K4().styled(...e5);

// node_modules/@mysten/wallet-kit/dist/index.mjs
var import_react47 = __toESM(require_react(), 1);
var import_react49 = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);

// node_modules/@wallet-standard/app/lib/esm/wallets.js
var __classPrivateFieldGet = function(receiver, state, kind, f15) {
  if (kind === "a" && !f15)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f15 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f15 : kind === "a" ? f15.call(receiver) : f15 ? f15.value : state.get(receiver);
};
var __classPrivateFieldSet = function(receiver, state, value, kind, f15) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f15)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f15 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f15.call(receiver, value) : f15 ? f15.value = value : state.set(receiver, value), value;
};
var _AppReadyEvent_detail;
var wallets = void 0;
var registeredWalletsSet = /* @__PURE__ */ new Set();
function addRegisteredWallet(wallet) {
  cachedWalletsArray = void 0;
  registeredWalletsSet.add(wallet);
}
function removeRegisteredWallet(wallet) {
  cachedWalletsArray = void 0;
  registeredWalletsSet.delete(wallet);
}
var listeners = {};
function getWallets() {
  if (wallets)
    return wallets;
  wallets = Object.freeze({ register, get, on });
  if (typeof window === "undefined")
    return wallets;
  const api = Object.freeze({ register });
  try {
    window.addEventListener("wallet-standard:register-wallet", ({ detail: callback }) => callback(api));
  } catch (error) {
    console.error("wallet-standard:register-wallet event listener could not be added\n", error);
  }
  try {
    window.dispatchEvent(new AppReadyEvent(api));
  } catch (error) {
    console.error("wallet-standard:app-ready event could not be dispatched\n", error);
  }
  return wallets;
}
function register(...wallets2) {
  var _a;
  wallets2 = wallets2.filter((wallet) => !registeredWalletsSet.has(wallet));
  if (!wallets2.length)
    return () => {
    };
  wallets2.forEach((wallet) => addRegisteredWallet(wallet));
  (_a = listeners["register"]) == null ? void 0 : _a.forEach((listener) => guard(() => listener(...wallets2)));
  return function unregister() {
    var _a2;
    wallets2.forEach((wallet) => removeRegisteredWallet(wallet));
    (_a2 = listeners["unregister"]) == null ? void 0 : _a2.forEach((listener) => guard(() => listener(...wallets2)));
  };
}
var cachedWalletsArray;
function get() {
  if (!cachedWalletsArray) {
    cachedWalletsArray = [...registeredWalletsSet];
  }
  return cachedWalletsArray;
}
function on(event, listener) {
  var _a;
  ((_a = listeners[event]) == null ? void 0 : _a.push(listener)) || (listeners[event] = [listener]);
  return function off() {
    var _a2;
    listeners[event] = (_a2 = listeners[event]) == null ? void 0 : _a2.filter((existingListener) => listener !== existingListener);
  };
}
function guard(callback) {
  try {
    callback();
  } catch (error) {
    console.error(error);
  }
}
var AppReadyEvent = class extends Event {
  get detail() {
    return __classPrivateFieldGet(this, _AppReadyEvent_detail, "f");
  }
  get type() {
    return "wallet-standard:app-ready";
  }
  constructor(api) {
    super("wallet-standard:app-ready", {
      bubbles: false,
      cancelable: false,
      composed: false
    });
    _AppReadyEvent_detail.set(this, void 0);
    __classPrivateFieldSet(this, _AppReadyEvent_detail, api, "f");
  }
  /** @deprecated */
  preventDefault() {
    throw new Error("preventDefault cannot be called");
  }
  /** @deprecated */
  stopImmediatePropagation() {
    throw new Error("stopImmediatePropagation cannot be called");
  }
  /** @deprecated */
  stopPropagation() {
    throw new Error("stopPropagation cannot be called");
  }
};
_AppReadyEvent_detail = /* @__PURE__ */ new WeakMap();

// node_modules/@wallet-standard/wallet/lib/esm/register.js
var _RegisterWalletEvent_detail;
_RegisterWalletEvent_detail = /* @__PURE__ */ new WeakMap();

// node_modules/@wallet-standard/wallet/lib/esm/util.js
var __classPrivateFieldGet2 = function(receiver, state, kind, f15) {
  if (kind === "a" && !f15)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f15 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f15 : kind === "a" ? f15.call(receiver) : f15 ? f15.value : state.get(receiver);
};
var __classPrivateFieldSet2 = function(receiver, state, value, kind, f15) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f15)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f15 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f15.call(receiver, value) : f15 ? f15.value = value : state.set(receiver, value), value;
};
var _ReadonlyWalletAccount_address;
var _ReadonlyWalletAccount_publicKey;
var _ReadonlyWalletAccount_chains;
var _ReadonlyWalletAccount_features;
var _ReadonlyWalletAccount_label;
var _ReadonlyWalletAccount_icon;
var ReadonlyWalletAccount = class _ReadonlyWalletAccount {
  /** Implementation of {@link "@wallet-standard/base".WalletAccount.address | WalletAccount::address} */
  get address() {
    return __classPrivateFieldGet2(this, _ReadonlyWalletAccount_address, "f");
  }
  /** Implementation of {@link "@wallet-standard/base".WalletAccount.publicKey | WalletAccount::publicKey} */
  get publicKey() {
    return __classPrivateFieldGet2(this, _ReadonlyWalletAccount_publicKey, "f").slice();
  }
  /** Implementation of {@link "@wallet-standard/base".WalletAccount.chains | WalletAccount::chains} */
  get chains() {
    return __classPrivateFieldGet2(this, _ReadonlyWalletAccount_chains, "f").slice();
  }
  /** Implementation of {@link "@wallet-standard/base".WalletAccount.features | WalletAccount::features} */
  get features() {
    return __classPrivateFieldGet2(this, _ReadonlyWalletAccount_features, "f").slice();
  }
  /** Implementation of {@link "@wallet-standard/base".WalletAccount.label | WalletAccount::label} */
  get label() {
    return __classPrivateFieldGet2(this, _ReadonlyWalletAccount_label, "f");
  }
  /** Implementation of {@link "@wallet-standard/base".WalletAccount.icon | WalletAccount::icon} */
  get icon() {
    return __classPrivateFieldGet2(this, _ReadonlyWalletAccount_icon, "f");
  }
  /**
   * Create and freeze a read-only account.
   *
   * @param account Account to copy properties from.
   */
  constructor(account) {
    _ReadonlyWalletAccount_address.set(this, void 0);
    _ReadonlyWalletAccount_publicKey.set(this, void 0);
    _ReadonlyWalletAccount_chains.set(this, void 0);
    _ReadonlyWalletAccount_features.set(this, void 0);
    _ReadonlyWalletAccount_label.set(this, void 0);
    _ReadonlyWalletAccount_icon.set(this, void 0);
    if (new.target === _ReadonlyWalletAccount) {
      Object.freeze(this);
    }
    __classPrivateFieldSet2(this, _ReadonlyWalletAccount_address, account.address, "f");
    __classPrivateFieldSet2(this, _ReadonlyWalletAccount_publicKey, account.publicKey.slice(), "f");
    __classPrivateFieldSet2(this, _ReadonlyWalletAccount_chains, account.chains.slice(), "f");
    __classPrivateFieldSet2(this, _ReadonlyWalletAccount_features, account.features.slice(), "f");
    __classPrivateFieldSet2(this, _ReadonlyWalletAccount_label, account.label, "f");
    __classPrivateFieldSet2(this, _ReadonlyWalletAccount_icon, account.icon, "f");
  }
};
_ReadonlyWalletAccount_address = /* @__PURE__ */ new WeakMap(), _ReadonlyWalletAccount_publicKey = /* @__PURE__ */ new WeakMap(), _ReadonlyWalletAccount_chains = /* @__PURE__ */ new WeakMap(), _ReadonlyWalletAccount_features = /* @__PURE__ */ new WeakMap(), _ReadonlyWalletAccount_label = /* @__PURE__ */ new WeakMap(), _ReadonlyWalletAccount_icon = /* @__PURE__ */ new WeakMap();

// node_modules/@mysten/wallet-standard/dist/index.mjs
var REQUIRED_FEATURES = [
  "standard:connect",
  "standard:events"
];
function isWalletWithSuiFeatures(wallet, features = []) {
  return [...REQUIRED_FEATURES, ...features].every((feature) => feature in wallet.features);
}
var SUI_DEVNET_CHAIN = "sui:devnet";
var SUI_TESTNET_CHAIN = "sui:testnet";
var SUI_LOCALNET_CHAIN = "sui:localnet";
var SUI_MAINNET_CHAIN = "sui:mainnet";
var SUI_CHAINS = [
  SUI_DEVNET_CHAIN,
  SUI_TESTNET_CHAIN,
  SUI_LOCALNET_CHAIN,
  SUI_MAINNET_CHAIN
];

// node_modules/@mysten/wallet-kit-core/dist/index.mjs
var localStorageAdapter = {
  async set(key, value) {
    return localStorage.setItem(key, value);
  },
  async get(key) {
    return localStorage.getItem(key);
  },
  async del(key) {
    localStorage.removeItem(key);
  }
};
var DEFAULT_FEATURES = [
  "sui:signAndExecuteTransactionBlock"
];
var WalletKitCoreConnectionStatus = ((WalletKitCoreConnectionStatus2) => {
  WalletKitCoreConnectionStatus2["DISCONNECTED"] = "DISCONNECTED";
  WalletKitCoreConnectionStatus2["CONNECTING"] = "CONNECTING";
  WalletKitCoreConnectionStatus2["CONNECTED"] = "CONNECTED";
  WalletKitCoreConnectionStatus2["ERROR"] = "ERROR";
  return WalletKitCoreConnectionStatus2;
})(WalletKitCoreConnectionStatus || {});
var SUI_WALLET_NAME = "Sui Wallet";
var RECENT_WALLET_STORAGE = "wallet-kit:last-wallet";
function waitToBeVisible() {
  if (!document || document.visibilityState === "visible") {
    return Promise.resolve();
  }
  let promiseResolve = null;
  const promise = new Promise((r10) => promiseResolve = r10);
  const callback = () => {
    if (promiseResolve && document.visibilityState === "visible") {
      promiseResolve();
      document.removeEventListener("visibilitychange", callback);
    }
  };
  document.addEventListener("visibilitychange", callback);
  return promise;
}
function sortWallets(wallets2, preferredWallets, features) {
  const suiWallets = wallets2.filter(
    (wallet) => isWalletWithSuiFeatures(wallet, features)
  );
  return [
    // Preferred wallets, in order:
    ...preferredWallets.map((name) => suiWallets.find((wallet) => wallet.name === name)).filter(Boolean),
    // Wallets in default order:
    ...suiWallets.filter((wallet) => !preferredWallets.includes(wallet.name))
  ];
}
function createWalletKitCore({
  preferredWallets = [SUI_WALLET_NAME],
  storageAdapter = localStorageAdapter,
  storageKey = RECENT_WALLET_STORAGE,
  features = DEFAULT_FEATURES
}) {
  const registeredWallets = getWallets();
  let wallets2 = registeredWallets.get();
  const subscriptions = /* @__PURE__ */ new Set();
  let walletEventUnsubscribe = null;
  let internalState = {
    accounts: [],
    currentAccount: null,
    wallets: sortWallets(wallets2, preferredWallets, features),
    currentWallet: null,
    status: "DISCONNECTED"
    /* DISCONNECTED */
  };
  const computeState = () => ({
    ...internalState,
    isConnecting: internalState.status === "CONNECTING",
    isConnected: internalState.status === "CONNECTED",
    isError: internalState.status === "ERROR"
    /* ERROR */
  });
  let state = computeState();
  function setState(nextInternalState) {
    internalState = {
      ...internalState,
      ...nextInternalState
    };
    state = computeState();
    subscriptions.forEach((handler) => {
      try {
        handler(state);
      } catch {
      }
    });
  }
  function disconnected() {
    if (walletEventUnsubscribe) {
      walletEventUnsubscribe();
      walletEventUnsubscribe = null;
    }
    setState({
      status: "DISCONNECTED",
      accounts: [],
      currentAccount: null,
      currentWallet: null
    });
  }
  const handleWalletsChanged = () => {
    setState({
      wallets: sortWallets(registeredWallets.get(), preferredWallets, features)
    });
  };
  registeredWallets.on("register", handleWalletsChanged);
  registeredWallets.on("unregister", handleWalletsChanged);
  const walletKit = {
    async autoconnect() {
      if (state.currentWallet)
        return;
      await waitToBeVisible();
      try {
        const lastWalletName = await storageAdapter.get(storageKey);
        if (lastWalletName) {
          walletKit.connect(lastWalletName, { silent: true });
        }
      } catch {
      }
    },
    getState() {
      return state;
    },
    subscribe(handler) {
      subscriptions.add(handler);
      try {
        handler(state);
      } catch {
      }
      return () => {
        subscriptions.delete(handler);
      };
    },
    selectAccount(account) {
      if (account === internalState.currentAccount || !internalState.accounts.includes(account)) {
        return;
      }
      setState({
        currentAccount: account
      });
    },
    async connect(walletName, connectInput) {
      const currentWallet = internalState.wallets.find((wallet) => wallet.name === walletName) ?? null;
      setState({ currentWallet });
      if (currentWallet) {
        if (walletEventUnsubscribe) {
          walletEventUnsubscribe();
        }
        walletEventUnsubscribe = currentWallet.features["standard:events"].on(
          "change",
          ({ accounts, features: features2, chains }) => {
            if (accounts) {
              setState({
                accounts,
                currentAccount: internalState.currentAccount && !accounts.find(({ address }) => {
                  var _a;
                  return address === ((_a = internalState.currentAccount) == null ? void 0 : _a.address);
                }) ? accounts[0] : internalState.currentAccount
              });
            }
          }
        );
        try {
          setState({
            status: "CONNECTING"
            /* CONNECTING */
          });
          await currentWallet.features["standard:connect"].connect(connectInput);
          setState({
            status: "CONNECTED"
            /* CONNECTED */
          });
          try {
            await storageAdapter.set(storageKey, currentWallet.name);
          } catch {
          }
          setState({
            accounts: currentWallet.accounts,
            currentAccount: currentWallet.accounts[0] ?? null
          });
        } catch (e5) {
          console.log("Wallet connection error", e5);
          setState({
            status: "ERROR"
            /* ERROR */
          });
        }
      } else {
        setState({
          status: "DISCONNECTED"
          /* DISCONNECTED */
        });
      }
    },
    async disconnect() {
      var _a;
      if (!internalState.currentWallet) {
        console.warn("Attempted to `disconnect` but no wallet was connected.");
        return;
      }
      try {
        await storageAdapter.del(storageKey);
      } catch {
      }
      await ((_a = internalState.currentWallet.features["standard:disconnect"]) == null ? void 0 : _a.disconnect());
      disconnected();
    },
    /** @deprecated Use `signPersonalMessage` instead. */
    signMessage(messageInput) {
      if (!internalState.currentWallet || !internalState.currentAccount) {
        throw new Error("No wallet is currently connected, cannot call `signMessage`.");
      }
      if (!internalState.currentWallet.features["sui:signMessage"]) {
        throw new Error("Wallet does not support deprecated `signMessage` method.");
      }
      return internalState.currentWallet.features["sui:signMessage"].signMessage({
        ...messageInput,
        account: messageInput.account ?? internalState.currentAccount
      });
    },
    signPersonalMessage(messageInput) {
      if (!internalState.currentWallet || !internalState.currentAccount) {
        throw new Error("No wallet is currently connected, cannot call `signPersonalMessage`.");
      }
      if (!internalState.currentWallet.features["sui:signPersonalMessage"]) {
        throw new Error("Wallet does not support the new `signPersonalMessage` method.");
      }
      return internalState.currentWallet.features["sui:signPersonalMessage"].signPersonalMessage({
        ...messageInput,
        account: messageInput.account ?? internalState.currentAccount
      });
    },
    async signTransactionBlock(transactionInput) {
      if (!internalState.currentWallet || !internalState.currentAccount) {
        throw new Error("No wallet is currently connected, cannot call `signTransaction`.");
      }
      const {
        account = internalState.currentAccount,
        chain = internalState.currentAccount.chains[0]
      } = transactionInput;
      if (!chain) {
        throw new Error("Missing chain");
      }
      return internalState.currentWallet.features["sui:signTransactionBlock"].signTransactionBlock({
        ...transactionInput,
        account,
        chain
      });
    },
    async signAndExecuteTransactionBlock(transactionInput) {
      if (!internalState.currentWallet || !internalState.currentAccount) {
        throw new Error(
          "No wallet is currently connected, cannot call `signAndExecuteTransactionBlock`."
        );
      }
      const {
        account = internalState.currentAccount,
        chain = internalState.currentAccount.chains[0]
      } = transactionInput;
      if (!chain) {
        throw new Error("Missing chain");
      }
      return internalState.currentWallet.features["sui:signAndExecuteTransactionBlock"].signAndExecuteTransactionBlock({
        ...transactionInput,
        account,
        chain
      });
    }
  };
  return walletKit;
}

// node_modules/@mysten/wallet-kit/dist/index.mjs
var import_react52 = __toESM(require_react(), 1);

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/version.js
var PACKAGE_VERSION = "0.48.0";
var TARGETED_RPC_VERSION = "1.16.0";

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/client/errors.js
var CODE_TO_ERROR_TYPE = {
  "-32700": "ParseError",
  "-32600": "InvalidRequest",
  "-32601": "MethodNotFound",
  "-32602": "InvalidParams",
  "-32603": "InternalError"
};
var SuiHTTPTransportError = class extends Error {
};
var JsonRpcError = class extends SuiHTTPTransportError {
  constructor(message, code) {
    super(message);
    this.code = code;
    this.type = CODE_TO_ERROR_TYPE[code] ?? "ServerError";
  }
};
var SuiHTTPStatusError = class extends SuiHTTPTransportError {
  constructor(message, status, statusText) {
    super(message);
    this.status = status;
    this.statusText = statusText;
  }
};

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/client/rpc-websocket-client.js
var __accessCheck2 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet2 = (obj, member, getter) => {
  __accessCheck2(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd2 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet2 = (obj, member, value, setter) => {
  __accessCheck2(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet2(obj, member, value, setter);
  },
  get _() {
    return __privateGet2(obj, member, getter);
  }
});
var __privateMethod = (obj, member, method) => {
  __accessCheck2(obj, member, "access private method");
  return method;
};
var _requestId;
var _disconnects;
var _webSocket;
var _connectionPromise;
var _subscriptions;
var _pendingRequests;
var _setupWebSocket;
var setupWebSocket_fn;
var _reconnect;
var reconnect_fn;
function getWebsocketUrl(httpUrl) {
  const url = new URL(httpUrl);
  url.protocol = url.protocol.replace("http", "ws");
  return url.toString();
}
var DEFAULT_CLIENT_OPTIONS = {
  // We fudge the typing because we also check for undefined in the constructor:
  WebSocketConstructor: typeof WebSocket !== "undefined" ? WebSocket : void 0,
  callTimeout: 3e4,
  reconnectTimeout: 3e3,
  maxReconnects: 5
};
var WebsocketClient = class {
  constructor(endpoint, options = {}) {
    __privateAdd2(this, _setupWebSocket);
    __privateAdd2(this, _reconnect);
    __privateAdd2(this, _requestId, 0);
    __privateAdd2(this, _disconnects, 0);
    __privateAdd2(this, _webSocket, null);
    __privateAdd2(this, _connectionPromise, null);
    __privateAdd2(this, _subscriptions, /* @__PURE__ */ new Set());
    __privateAdd2(this, _pendingRequests, /* @__PURE__ */ new Map());
    this.endpoint = endpoint;
    this.options = { ...DEFAULT_CLIENT_OPTIONS, ...options };
    if (!this.options.WebSocketConstructor) {
      throw new Error("Missing WebSocket constructor");
    }
    if (this.endpoint.startsWith("http")) {
      this.endpoint = getWebsocketUrl(this.endpoint);
    }
  }
  async makeRequest(method, params) {
    const webSocket = await __privateMethod(this, _setupWebSocket, setupWebSocket_fn).call(this);
    return new Promise((resolve, reject) => {
      __privateSet2(this, _requestId, __privateGet2(this, _requestId) + 1);
      __privateGet2(this, _pendingRequests).set(__privateGet2(this, _requestId), {
        resolve,
        reject,
        timeout: setTimeout(() => {
          __privateGet2(this, _pendingRequests).delete(__privateGet2(this, _requestId));
          reject(new Error(`Request timeout: ${method}`));
        }, this.options.callTimeout)
      });
      webSocket.send(JSON.stringify({ jsonrpc: "2.0", id: __privateGet2(this, _requestId), method, params }));
    }).then(({ error, result }) => {
      if (error) {
        throw new JsonRpcError(error.message, error.code);
      }
      return result;
    });
  }
  async subscribe(input) {
    const subscription = new RpcSubscription(input);
    __privateGet2(this, _subscriptions).add(subscription);
    await subscription.subscribe(this);
    return () => subscription.unsubscribe(this);
  }
};
_requestId = /* @__PURE__ */ new WeakMap();
_disconnects = /* @__PURE__ */ new WeakMap();
_webSocket = /* @__PURE__ */ new WeakMap();
_connectionPromise = /* @__PURE__ */ new WeakMap();
_subscriptions = /* @__PURE__ */ new WeakMap();
_pendingRequests = /* @__PURE__ */ new WeakMap();
_setupWebSocket = /* @__PURE__ */ new WeakSet();
setupWebSocket_fn = function() {
  if (__privateGet2(this, _connectionPromise)) {
    return __privateGet2(this, _connectionPromise);
  }
  __privateSet2(this, _connectionPromise, new Promise((resolve) => {
    var _a;
    (_a = __privateGet2(this, _webSocket)) == null ? void 0 : _a.close();
    __privateSet2(this, _webSocket, new this.options.WebSocketConstructor(this.endpoint));
    __privateGet2(this, _webSocket).addEventListener("open", () => {
      __privateSet2(this, _disconnects, 0);
      resolve(__privateGet2(this, _webSocket));
    });
    __privateGet2(this, _webSocket).addEventListener("close", () => {
      __privateWrapper(this, _disconnects)._++;
      if (__privateGet2(this, _disconnects) <= this.options.maxReconnects) {
        setTimeout(() => {
          __privateMethod(this, _reconnect, reconnect_fn).call(this);
        }, this.options.reconnectTimeout);
      }
    });
    __privateGet2(this, _webSocket).addEventListener("message", ({ data }) => {
      let json;
      try {
        json = JSON.parse(data);
      } catch (error) {
        console.error(new Error(`Failed to parse RPC message: ${data}`, { cause: error }));
        return;
      }
      if ("id" in json && json.id != null && __privateGet2(this, _pendingRequests).has(json.id)) {
        const { resolve: resolve2, timeout } = __privateGet2(this, _pendingRequests).get(json.id);
        clearTimeout(timeout);
        resolve2(json);
      } else if ("params" in json) {
        const { params } = json;
        __privateGet2(this, _subscriptions).forEach((subscription) => {
          if (subscription.subscriptionId === params.subscription) {
            if (params.subscription === subscription.subscriptionId) {
              subscription.onMessage(params.result);
            }
          }
        });
      }
    });
  }));
  return __privateGet2(this, _connectionPromise);
};
_reconnect = /* @__PURE__ */ new WeakSet();
reconnect_fn = async function() {
  var _a;
  (_a = __privateGet2(this, _webSocket)) == null ? void 0 : _a.close();
  __privateSet2(this, _connectionPromise, null);
  return Promise.allSettled(
    [...__privateGet2(this, _subscriptions)].map((subscription) => subscription.subscribe(this))
  );
};
var RpcSubscription = class {
  constructor(input) {
    this.subscriptionId = null;
    this.subscribed = false;
    this.input = input;
  }
  onMessage(message) {
    if (this.subscribed) {
      this.input.onMessage(message);
    }
  }
  async unsubscribe(client) {
    const { subscriptionId } = this;
    this.subscribed = false;
    if (subscriptionId == null)
      return false;
    this.subscriptionId = null;
    return client.makeRequest(this.input.unsubscribe, [subscriptionId]);
  }
  async subscribe(client) {
    this.subscriptionId = null;
    this.subscribed = true;
    const newSubscriptionId = await client.makeRequest(
      this.input.method,
      this.input.params
    );
    if (this.subscribed) {
      this.subscriptionId = newSubscriptionId;
    }
  }
};

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/client/http-transport.js
var __accessCheck3 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet3 = (obj, member, getter) => {
  __accessCheck3(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd3 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet3 = (obj, member, value, setter) => {
  __accessCheck3(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod2 = (obj, member, method) => {
  __accessCheck3(obj, member, "access private method");
  return method;
};
var _requestId2;
var _options;
var _websocketClient;
var _getWebsocketClient;
var getWebsocketClient_fn;
var SuiHTTPTransport = class {
  constructor(options) {
    __privateAdd3(this, _getWebsocketClient);
    __privateAdd3(this, _requestId2, 0);
    __privateAdd3(this, _options, void 0);
    __privateAdd3(this, _websocketClient, void 0);
    __privateSet3(this, _options, options);
  }
  fetch(input, init) {
    const fetch2 = __privateGet3(this, _options).fetch ?? globalThis.fetch;
    if (!this.fetch) {
      throw new Error(
        "The current environment does not support fetch, you can provide a fetch implementation in the options for SuiHTTPTransport."
      );
    }
    return fetch2(input, init);
  }
  async request(input) {
    var _a, _b;
    __privateSet3(this, _requestId2, __privateGet3(this, _requestId2) + 1);
    const res = await this.fetch(((_a = __privateGet3(this, _options).rpc) == null ? void 0 : _a.url) ?? __privateGet3(this, _options).url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Client-Sdk-Type": "typescript",
        "Client-Sdk-Version": PACKAGE_VERSION,
        "Client-Target-Api-Version": TARGETED_RPC_VERSION,
        ...(_b = __privateGet3(this, _options).rpc) == null ? void 0 : _b.headers
      },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: __privateGet3(this, _requestId2),
        method: input.method,
        params: input.params
      })
    });
    if (!res.ok) {
      throw new SuiHTTPStatusError(
        `Unexpected status code: ${res.status}`,
        res.status,
        res.statusText
      );
    }
    const data = await res.json();
    if ("error" in data && data.error != null) {
      throw new JsonRpcError(data.error.message, data.error.code);
    }
    return data.result;
  }
  async subscribe(input) {
    const unsubscribe = await __privateMethod2(this, _getWebsocketClient, getWebsocketClient_fn).call(this).subscribe(input);
    return async () => !!await unsubscribe();
  }
};
_requestId2 = /* @__PURE__ */ new WeakMap();
_options = /* @__PURE__ */ new WeakMap();
_websocketClient = /* @__PURE__ */ new WeakMap();
_getWebsocketClient = /* @__PURE__ */ new WeakSet();
getWebsocketClient_fn = function() {
  var _a;
  if (!__privateGet3(this, _websocketClient)) {
    const WebSocketConstructor = __privateGet3(this, _options).WebSocketConstructor ?? globalThis.WebSocket;
    if (!WebSocketConstructor) {
      throw new Error(
        "The current environment does not support WebSocket, you can provide a WebSocketConstructor in the options for SuiHTTPTransport."
      );
    }
    __privateSet3(this, _websocketClient, new WebsocketClient(
      ((_a = __privateGet3(this, _options).websocket) == null ? void 0 : _a.url) ?? __privateGet3(this, _options).url,
      {
        WebSocketConstructor: __privateGet3(this, _options).WebSocketConstructor,
        ...__privateGet3(this, _options).websocket
      }
    ));
  }
  return __privateGet3(this, _websocketClient);
};

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/client/network.js
function getFullnodeUrl(network) {
  switch (network) {
    case "mainnet":
      return "https://fullnode.mainnet.sui.io:443";
    case "testnet":
      return "https://fullnode.testnet.sui.io:443";
    case "devnet":
      return "https://fullnode.devnet.sui.io:443";
    case "localnet":
      return "http://127.0.0.1:9000";
    default:
      throw new Error(`Unknown network: ${network}`);
  }
}

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/bcs/type-tag-serializer.js
var VECTOR_REGEX = /^vector<(.+)>$/;
var STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;
var TypeTagSerializer = class _TypeTagSerializer {
  static parseFromStr(str, normalizeAddress = false) {
    if (str === "address") {
      return { address: null };
    } else if (str === "bool") {
      return { bool: null };
    } else if (str === "u8") {
      return { u8: null };
    } else if (str === "u16") {
      return { u16: null };
    } else if (str === "u32") {
      return { u32: null };
    } else if (str === "u64") {
      return { u64: null };
    } else if (str === "u128") {
      return { u128: null };
    } else if (str === "u256") {
      return { u256: null };
    } else if (str === "signer") {
      return { signer: null };
    }
    const vectorMatch = str.match(VECTOR_REGEX);
    if (vectorMatch) {
      return {
        vector: _TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress)
      };
    }
    const structMatch = str.match(STRUCT_REGEX);
    if (structMatch) {
      const address = normalizeAddress ? normalizeSuiAddress(structMatch[1]) : structMatch[1];
      return {
        struct: {
          address,
          module: structMatch[2],
          name: structMatch[3],
          typeParams: structMatch[5] === void 0 ? [] : _TypeTagSerializer.parseStructTypeArgs(structMatch[5], normalizeAddress)
        }
      };
    }
    throw new Error(`Encountered unexpected token when parsing type args for ${str}`);
  }
  static parseStructTypeArgs(str, normalizeAddress = false) {
    return splitGenericParameters(str).map(
      (tok) => _TypeTagSerializer.parseFromStr(tok, normalizeAddress)
    );
  }
  static tagToString(tag) {
    if ("bool" in tag) {
      return "bool";
    }
    if ("u8" in tag) {
      return "u8";
    }
    if ("u16" in tag) {
      return "u16";
    }
    if ("u32" in tag) {
      return "u32";
    }
    if ("u64" in tag) {
      return "u64";
    }
    if ("u128" in tag) {
      return "u128";
    }
    if ("u256" in tag) {
      return "u256";
    }
    if ("address" in tag) {
      return "address";
    }
    if ("signer" in tag) {
      return "signer";
    }
    if ("vector" in tag) {
      return `vector<${_TypeTagSerializer.tagToString(tag.vector)}>`;
    }
    if ("struct" in tag) {
      const struct = tag.struct;
      const typeParams = struct.typeParams.map(_TypeTagSerializer.tagToString).join(", ");
      return `${struct.address}::${struct.module}::${struct.name}${typeParams ? `<${typeParams}>` : ""}`;
    }
    throw new Error("Invalid TypeTag");
  }
};

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/bcs/index.js
var bcsRegistry = new BCS({
  ...getSuiMoveConfig(),
  types: {
    enums: {
      "Option<T>": {
        None: null,
        Some: "T"
      }
    }
  }
});
function unsafe_u64(options) {
  return bcs.u64({
    name: "unsafe_u64",
    ...options
  }).transform({
    input: (val) => val,
    output: (val) => Number(val)
  });
}
function optionEnum(type) {
  return bcs.enum("Option", {
    None: null,
    Some: type
  });
}
function enumKind(type) {
  return type.transform({
    input: (val) => ({
      [val.kind]: val
    }),
    output: (val) => {
      const key = Object.keys(val)[0];
      return { kind: key, ...val[key] };
    }
  });
}
var Address = bcs.bytes(SUI_ADDRESS_LENGTH2).transform({
  input: (val) => typeof val === "string" ? fromHEX(normalizeSuiAddress(val)) : val,
  output: (val) => normalizeSuiAddress(toHEX(val))
});
var ObjectDigest = bcs.vector(bcs.u8()).transform({
  name: "ObjectDigest",
  input: (value) => fromB58(value),
  output: (value) => toB58(new Uint8Array(value))
});
var SuiObjectRef = bcs.struct("SuiObjectRef", {
  objectId: Address,
  version: bcs.u64(),
  digest: ObjectDigest
});
var SharedObjectRef = bcs.struct("SharedObjectRef", {
  objectId: Address,
  initialSharedVersion: bcs.u64(),
  mutable: bcs.bool()
});
var ObjectArg = bcs.enum("ObjectArg", {
  ImmOrOwned: SuiObjectRef,
  Shared: SharedObjectRef,
  Receiving: SuiObjectRef
});
var CallArg = bcs.enum("CallArg", {
  Pure: bcs.vector(bcs.u8()),
  Object: ObjectArg,
  ObjVec: bcs.vector(ObjectArg)
});
var TypeTag = bcs.enum("TypeTag", {
  bool: null,
  u8: null,
  u64: null,
  u128: null,
  address: null,
  signer: null,
  vector: bcs.lazy(() => TypeTag),
  struct: bcs.lazy(() => StructTag),
  u16: null,
  u32: null,
  u256: null
});
var Argument = enumKind(
  bcs.enum("Argument", {
    GasCoin: null,
    Input: bcs.struct("Input", { index: bcs.u16() }),
    Result: bcs.struct("Result", { index: bcs.u16() }),
    NestedResult: bcs.struct("NestedResult", { index: bcs.u16(), resultIndex: bcs.u16() })
  })
);
var ProgrammableMoveCall = bcs.struct("ProgrammableMoveCall", {
  package: Address,
  module: bcs.string(),
  function: bcs.string(),
  type_arguments: bcs.vector(TypeTag),
  arguments: bcs.vector(Argument)
}).transform({
  input: (data) => {
    const [pkg, module, fun] = data.target.split("::");
    const type_arguments = data.typeArguments.map(
      (tag) => TypeTagSerializer.parseFromStr(tag, true)
    );
    return {
      package: normalizeSuiAddress(pkg),
      module,
      function: fun,
      type_arguments,
      arguments: data.arguments
    };
  },
  output: (data) => {
    return {
      target: [data.package, data.module, data.function].join(
        "::"
      ),
      arguments: data.arguments,
      typeArguments: data.type_arguments.map(TypeTagSerializer.tagToString)
    };
  }
});
var Transaction = enumKind(
  bcs.enum("Transaction", {
    /**
     * A Move Call - any public Move function can be called via
     * this transaction. The results can be used that instant to pass
     * into the next transaction.
     */
    MoveCall: ProgrammableMoveCall,
    /**
     * Transfer vector of objects to a receiver.
     */
    TransferObjects: bcs.struct("TransferObjects", {
      objects: bcs.vector(Argument),
      address: Argument
    }),
    /**
     * Split `amount` from a `coin`.
     */
    SplitCoins: bcs.struct("SplitCoins", { coin: Argument, amounts: bcs.vector(Argument) }),
    /**
     * Merge Vector of Coins (`sources`) into a `destination`.
     */
    MergeCoins: bcs.struct("MergeCoins", { destination: Argument, sources: bcs.vector(Argument) }),
    /**
     * Publish a Move module.
     */
    Publish: bcs.struct("Publish", {
      modules: bcs.vector(bcs.vector(bcs.u8())),
      dependencies: bcs.vector(Address)
    }),
    /**
     * Build a vector of objects using the input arguments.
     * It is impossible to construct a `vector<T: key>` otherwise,
     * so this call serves a utility function.
     */
    MakeMoveVec: bcs.struct("MakeMoveVec", {
      type: optionEnum(TypeTag),
      objects: bcs.vector(Argument)
    }),
    /**  */
    Upgrade: bcs.struct("Upgrade", {
      modules: bcs.vector(bcs.vector(bcs.u8())),
      dependencies: bcs.vector(Address),
      packageId: Address,
      ticket: Argument
    })
  })
);
var ProgrammableTransaction = bcs.struct("ProgrammableTransaction", {
  inputs: bcs.vector(CallArg),
  transactions: bcs.vector(Transaction)
});
var TransactionKind = bcs.enum("TransactionKind", {
  ProgrammableTransaction,
  ChangeEpoch: null,
  Genesis: null,
  ConsensusCommitPrologue: null
});
var TransactionExpiration = bcs.enum("TransactionExpiration", {
  None: null,
  Epoch: unsafe_u64()
});
var StructTag = bcs.struct("StructTag", {
  address: Address,
  module: bcs.string(),
  name: bcs.string(),
  typeParams: bcs.vector(TypeTag)
});
var GasData = bcs.struct("GasData", {
  payment: bcs.vector(SuiObjectRef),
  owner: Address,
  price: bcs.u64(),
  budget: bcs.u64()
});
var TransactionDataV1 = bcs.struct("TransactionDataV1", {
  kind: TransactionKind,
  sender: Address,
  gasData: GasData,
  expiration: TransactionExpiration
});
var TransactionData = bcs.enum("TransactionData", {
  V1: TransactionDataV1
});
var SenderSignedData = bcs.struct("SenderSignedData", {
  data: TransactionData,
  txSignatures: bcs.vector(bcs.vector(bcs.u8()))
});
var CompressedSignature = bcs.enum("CompressedSignature", {
  ED25519: bcs.fixedArray(64, bcs.u8()),
  Secp256k1: bcs.fixedArray(64, bcs.u8()),
  Secp256r1: bcs.fixedArray(64, bcs.u8()),
  ZkLogin: bcs.vector(bcs.u8())
});
var PublicKey = bcs.enum("PublicKey", {
  ED25519: bcs.fixedArray(32, bcs.u8()),
  Secp256k1: bcs.fixedArray(33, bcs.u8()),
  Secp256r1: bcs.fixedArray(33, bcs.u8()),
  ZkLogin: bcs.vector(bcs.u8())
});
var MultiSigPkMap = bcs.struct("MultiSigPkMap", {
  pubKey: PublicKey,
  weight: bcs.u8()
});
var MultiSigPublicKey = bcs.struct("MultiSigPublicKey", {
  pk_map: bcs.vector(MultiSigPkMap),
  threshold: bcs.u16()
});
var MultiSig = bcs.struct("MultiSig", {
  sigs: bcs.vector(CompressedSignature),
  bitmap: bcs.u16(),
  multisig_pk: MultiSigPublicKey
});
var suiBcs = {
  ...bcs,
  U8: bcs.u8(),
  U16: bcs.u16(),
  U32: bcs.u32(),
  U64: bcs.u64(),
  U128: bcs.u128(),
  U256: bcs.u256(),
  ULEB128: bcs.uleb128(),
  Bool: bcs.bool(),
  String: bcs.string(),
  Address,
  Argument,
  CallArg,
  CompressedSignature,
  GasData,
  MultiSig,
  MultiSigPkMap,
  MultiSigPublicKey,
  ObjectArg,
  ObjectDigest,
  ProgrammableMoveCall,
  ProgrammableTransaction,
  PublicKey,
  SenderSignedData,
  SharedObjectRef,
  StructTag,
  SuiObjectRef,
  Transaction,
  TransactionData,
  TransactionDataV1,
  TransactionExpiration,
  TransactionKind,
  TypeTag,
  // preserve backwards compatibility with old bcs export
  ser: bcsRegistry.ser.bind(bcsRegistry),
  de: bcsRegistry.de.bind(bcsRegistry),
  getTypeInterface: bcsRegistry.getTypeInterface.bind(bcsRegistry),
  hasType: bcsRegistry.hasType.bind(bcsRegistry),
  parseTypeName: bcsRegistry.parseTypeName.bind(bcsRegistry),
  registerAddressType: bcsRegistry.registerAddressType.bind(bcsRegistry),
  registerAlias: bcsRegistry.registerAlias.bind(bcsRegistry),
  registerBcsType: bcsRegistry.registerBcsType.bind(bcsRegistry),
  registerEnumType: bcsRegistry.registerEnumType.bind(bcsRegistry),
  registerStructType: bcsRegistry.registerStructType.bind(bcsRegistry),
  registerType: bcsRegistry.registerType.bind(bcsRegistry),
  types: bcsRegistry.types
};
bcsRegistry.registerBcsType("utf8string", () => bcs.string({ name: "utf8string" }));
bcsRegistry.registerBcsType("unsafe_u64", () => unsafe_u64());
bcsRegistry.registerBcsType("enumKind", (T8) => enumKind(T8));
[
  Address,
  Argument,
  CallArg,
  CompressedSignature,
  GasData,
  MultiSig,
  MultiSigPkMap,
  MultiSigPublicKey,
  ObjectArg,
  ObjectDigest,
  ProgrammableMoveCall,
  ProgrammableTransaction,
  PublicKey,
  SenderSignedData,
  SharedObjectRef,
  StructTag,
  SuiObjectRef,
  Transaction,
  TransactionData,
  TransactionDataV1,
  TransactionExpiration,
  TransactionKind,
  TypeTag
].forEach((type) => {
  bcsRegistry.registerBcsType(type.name, () => type);
});

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/types/common.js
var ObjectOwner = union([
  object({
    AddressOwner: string()
  }),
  object({
    ObjectOwner: string()
  }),
  object({
    Shared: object({
      initial_shared_version: nullable(string())
    })
  }),
  literal("Immutable")
]);
var SuiJsonValue = define("SuiJsonValue", () => true);
var ProtocolConfigValue = union([
  object({ u32: string() }),
  object({ u64: string() }),
  object({ f64: string() })
]);
var ProtocolConfig = object({
  attributes: record(string(), nullable(ProtocolConfigValue)),
  featureFlags: record(string(), boolean()),
  maxSupportedProtocolVersion: string(),
  minSupportedProtocolVersion: string(),
  protocolVersion: string()
});

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/types/objects.js
var ObjectType = union([string(), literal("package")]);
var SuiObjectRef2 = object({
  /** Base64 string representing the object digest */
  digest: string(),
  /** Hex code as string representing the object id */
  objectId: string(),
  /** Object version */
  version: union([number(), string(), bigint()])
});
var OwnedObjectRef = object({
  owner: ObjectOwner,
  reference: SuiObjectRef2
});
var TransactionEffectsModifiedAtVersions = object({
  objectId: string(),
  sequenceNumber: string()
});
var SuiGasData = object({
  payment: array(SuiObjectRef2),
  /** Gas Object's owner */
  owner: string(),
  price: string(),
  budget: string()
});
var SuiObjectInfo = assign(
  SuiObjectRef2,
  object({
    type: string(),
    owner: ObjectOwner,
    previousTransaction: string()
  })
);
var ObjectContentFields = record(string(), any());
var MovePackageContent = record(string(), unknown());
var SuiMoveObject = object({
  /** Move type (e.g., "0x2::coin::Coin<0x2::sui::SUI>") */
  type: string(),
  /** Fields and values stored inside the Move object */
  fields: ObjectContentFields,
  hasPublicTransfer: boolean()
});
var SuiMovePackage = object({
  /** A mapping from module name to disassembled Move bytecode */
  disassembled: MovePackageContent
});
var SuiParsedData = union([
  assign(SuiMoveObject, object({ dataType: literal("moveObject") })),
  assign(SuiMovePackage, object({ dataType: literal("package") }))
]);
var SuiRawMoveObject = object({
  /** Move type (e.g., "0x2::coin::Coin<0x2::sui::SUI>") */
  type: string(),
  hasPublicTransfer: boolean(),
  version: string(),
  bcsBytes: string()
});
var SuiRawMovePackage = object({
  id: string(),
  /** A mapping from module name to Move bytecode enocded in base64*/
  moduleMap: record(string(), string())
});
var SuiRawData = union([
  assign(SuiRawMoveObject, object({ dataType: literal("moveObject") })),
  assign(SuiRawMovePackage, object({ dataType: literal("package") }))
]);
var MIST_PER_SUI2 = BigInt(1e9);
var SuiObjectResponseError = object({
  code: string(),
  error: optional(string()),
  object_id: optional(string()),
  parent_object_id: optional(string()),
  version: optional(string()),
  digest: optional(string())
});
var DisplayFieldsResponse = object({
  data: nullable(optional(record(string(), string()))),
  error: nullable(optional(SuiObjectResponseError))
});
var DisplayFieldsBackwardCompatibleResponse = union([
  DisplayFieldsResponse,
  optional(record(string(), string()))
]);
var SuiObjectData = object({
  objectId: string(),
  version: string(),
  digest: string(),
  /**
   * Type of the object, default to be undefined unless SuiObjectDataOptions.showType is set to true
   */
  type: nullable(optional(string())),
  /**
   * Move object content or package content, default to be undefined unless SuiObjectDataOptions.showContent is set to true
   */
  content: nullable(optional(SuiParsedData)),
  /**
   * Move object content or package content in BCS bytes, default to be undefined unless SuiObjectDataOptions.showBcs is set to true
   */
  bcs: nullable(optional(SuiRawData)),
  /**
   * The owner of this object. Default to be undefined unless SuiObjectDataOptions.showOwner is set to true
   */
  owner: nullable(optional(ObjectOwner)),
  /**
   * The digest of the transaction that created or last mutated this object.
   * Default to be undefined unless SuiObjectDataOptions.showPreviousTransaction is set to true
   */
  previousTransaction: nullable(optional(string())),
  /**
   * The amount of SUI we would rebate if this object gets deleted.
   * This number is re-calculated each time the object is mutated based on
   * the present storage gas price.
   * Default to be undefined unless SuiObjectDataOptions.showStorageRebate is set to true
   */
  storageRebate: nullable(optional(string())),
  /**
   * Display metadata for this object, default to be undefined unless SuiObjectDataOptions.showDisplay is set to true
   * This can also be None if the struct type does not have Display defined
   * See more details in https://forums.sui.io/t/nft-object-display-proposal/4872
   */
  display: nullable(optional(DisplayFieldsBackwardCompatibleResponse))
});
var SuiObjectDataOptions = object({
  /* Whether to fetch the object type, default to be true */
  showType: nullable(optional(boolean())),
  /* Whether to fetch the object content, default to be false */
  showContent: nullable(optional(boolean())),
  /* Whether to fetch the object content in BCS bytes, default to be false */
  showBcs: nullable(optional(boolean())),
  /* Whether to fetch the object owner, default to be false */
  showOwner: nullable(optional(boolean())),
  /* Whether to fetch the previous transaction digest, default to be false */
  showPreviousTransaction: nullable(optional(boolean())),
  /* Whether to fetch the storage rebate, default to be false */
  showStorageRebate: nullable(optional(boolean())),
  /* Whether to fetch the display metadata, default to be false */
  showDisplay: nullable(optional(boolean()))
});
var ObjectStatus = union([literal("Exists"), literal("notExists"), literal("Deleted")]);
var GetOwnedObjectsResponse = array(SuiObjectInfo);
var SuiObjectResponse = object({
  data: nullable(optional(SuiObjectData)),
  error: nullable(optional(SuiObjectResponseError))
});
function getSuiObjectData(resp) {
  return resp.data;
}
function getObjectDeletedResponse(resp) {
  if (resp.error && "object_id" in resp.error && "version" in resp.error && "digest" in resp.error) {
    const error = resp.error;
    return {
      objectId: error.object_id,
      version: error.version,
      digest: error.digest
    };
  }
  return void 0;
}
function getObjectReference(resp) {
  if ("reference" in resp) {
    return resp.reference;
  }
  const exists = getSuiObjectData(resp);
  if (exists) {
    return {
      objectId: exists.objectId,
      version: exists.version,
      digest: exists.digest
    };
  }
  return getObjectDeletedResponse(resp);
}
var CheckpointedObjectId = object({
  objectId: string(),
  atCheckpoint: optional(number())
});
var PaginatedObjectsResponse = object({
  data: array(SuiObjectResponse),
  nextCursor: optional(nullable(string())),
  hasNextPage: boolean()
});
var ObjectRead = union([
  object({
    details: SuiObjectData,
    status: literal("VersionFound")
  }),
  object({
    details: string(),
    status: literal("ObjectNotExists")
  }),
  object({
    details: SuiObjectRef2,
    status: literal("ObjectDeleted")
  }),
  object({
    details: tuple([string(), number()]),
    status: literal("VersionNotFound")
  }),
  object({
    details: object({
      asked_version: number(),
      latest_version: number(),
      object_id: string()
    }),
    status: literal("VersionTooHigh")
  })
]);

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/types/normalized.js
var SuiMoveFunctionArgType = union([string(), object({ Object: string() })]);
var SuiMoveFunctionArgTypes = array(SuiMoveFunctionArgType);
var SuiMoveModuleId = object({
  address: string(),
  name: string()
});
var SuiMoveVisibility = union([literal("Private"), literal("Public"), literal("Friend")]);
var SuiMoveAbilitySet = object({
  abilities: array(string())
});
var SuiMoveStructTypeParameter = object({
  constraints: SuiMoveAbilitySet,
  isPhantom: boolean()
});
var SuiMoveNormalizedTypeParameterType = object({
  TypeParameter: number()
});
var MoveCallMetric = tuple([
  object({
    module: string(),
    package: string(),
    function: string()
  }),
  string()
]);
var MoveCallMetrics = object({
  rank3Days: array(MoveCallMetric),
  rank7Days: array(MoveCallMetric),
  rank30Days: array(MoveCallMetric)
});
function isSuiMoveNormalizedType(value) {
  if (!value)
    return false;
  if (typeof value === "string")
    return true;
  if (is(value, SuiMoveNormalizedTypeParameterType))
    return true;
  if (isSuiMoveNormalizedStructType(value))
    return true;
  if (typeof value !== "object")
    return false;
  const valueProperties = value;
  if (is(valueProperties.Reference, SuiMoveNormalizedType))
    return true;
  if (is(valueProperties.MutableReference, SuiMoveNormalizedType))
    return true;
  if (is(valueProperties.Vector, SuiMoveNormalizedType))
    return true;
  return false;
}
var SuiMoveNormalizedType = define(
  "SuiMoveNormalizedType",
  isSuiMoveNormalizedType
);
function isSuiMoveNormalizedStructType(value) {
  if (!value || typeof value !== "object")
    return false;
  const valueProperties = value;
  if (!valueProperties.Struct || typeof valueProperties.Struct !== "object")
    return false;
  const structProperties = valueProperties.Struct;
  if (typeof structProperties.address !== "string" || typeof structProperties.module !== "string" || typeof structProperties.name !== "string" || !Array.isArray(structProperties.typeArguments) || !structProperties.typeArguments.every((value2) => isSuiMoveNormalizedType(value2))) {
    return false;
  }
  return true;
}
var SuiMoveNormalizedStructType = define(
  "SuiMoveNormalizedStructType",
  isSuiMoveNormalizedStructType
);
var SuiMoveNormalizedFunction = object({
  visibility: SuiMoveVisibility,
  isEntry: boolean(),
  typeParameters: array(SuiMoveAbilitySet),
  parameters: array(SuiMoveNormalizedType),
  return: array(SuiMoveNormalizedType)
});
var SuiMoveNormalizedField = object({
  name: string(),
  type: SuiMoveNormalizedType
});
var SuiMoveNormalizedStruct = object({
  abilities: SuiMoveAbilitySet,
  typeParameters: array(SuiMoveStructTypeParameter),
  fields: array(SuiMoveNormalizedField)
});
var SuiMoveNormalizedModule = object({
  fileFormatVersion: number(),
  address: string(),
  name: string(),
  friends: array(SuiMoveModuleId),
  structs: record(string(), SuiMoveNormalizedStruct),
  exposedFunctions: record(string(), SuiMoveNormalizedFunction)
});
var SuiMoveNormalizedModules = record(string(), SuiMoveNormalizedModule);
function extractMutableReference(normalizedType) {
  return typeof normalizedType === "object" && "MutableReference" in normalizedType ? normalizedType.MutableReference : void 0;
}
function extractReference(normalizedType) {
  return typeof normalizedType === "object" && "Reference" in normalizedType ? normalizedType.Reference : void 0;
}
function extractStructTag(normalizedType) {
  if (typeof normalizedType === "object" && "Struct" in normalizedType) {
    return normalizedType;
  }
  const ref = extractReference(normalizedType);
  const mutRef = extractMutableReference(normalizedType);
  if (typeof ref === "object" && "Struct" in ref) {
    return ref;
  }
  if (typeof mutRef === "object" && "Struct" in mutRef) {
    return mutRef;
  }
  return void 0;
}

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/builder/Inputs.js
var ObjectArg2 = union([
  object({ ImmOrOwned: SuiObjectRef2 }),
  object({
    Shared: object({
      objectId: string(),
      initialSharedVersion: union([integer(), string()]),
      mutable: boolean()
    })
  }),
  object({ Receiving: SuiObjectRef2 })
]);
var PureCallArg = object({ Pure: array(integer()) });
var ObjectCallArg = object({ Object: ObjectArg2 });
var BuilderCallArg = union([PureCallArg, ObjectCallArg]);
function Pure(data, type) {
  return {
    Pure: Array.from(
      data instanceof Uint8Array ? data : isSerializedBcs(data) ? data.toBytes() : (
        // NOTE: We explicitly set this to be growable to infinity, because we have maxSize validation at the builder-level:
        suiBcs.ser(type, data, { maxSize: Infinity }).toBytes()
      )
    )
  };
}
var Inputs = {
  Pure,
  ObjectRef({ objectId, digest, version }) {
    return {
      Object: {
        ImmOrOwned: {
          digest,
          version,
          objectId: normalizeSuiAddress(objectId)
        }
      }
    };
  },
  SharedObjectRef({ objectId, mutable, initialSharedVersion }) {
    return {
      Object: {
        Shared: {
          mutable,
          initialSharedVersion,
          objectId: normalizeSuiAddress(objectId)
        }
      }
    };
  },
  ReceivingRef({ objectId, digest, version }) {
    return {
      Object: {
        Receiving: {
          digest,
          version,
          objectId: normalizeSuiAddress(objectId)
        }
      }
    };
  }
};
function getIdFromCallArg(arg) {
  if (typeof arg === "string") {
    return normalizeSuiAddress(arg);
  }
  if ("ImmOrOwned" in arg.Object) {
    return normalizeSuiAddress(arg.Object.ImmOrOwned.objectId);
  }
  if ("Receiving" in arg.Object) {
    return normalizeSuiAddress(arg.Object.Receiving.objectId);
  }
  return normalizeSuiAddress(arg.Object.Shared.objectId);
}
function getSharedObjectInput(arg) {
  return typeof arg === "object" && "Object" in arg && "Shared" in arg.Object ? arg.Object.Shared : void 0;
}
function isMutableSharedObjectInput(arg) {
  var _a;
  return ((_a = getSharedObjectInput(arg)) == null ? void 0 : _a.mutable) ?? false;
}

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/builder/pure.js
function createPure(makePure) {
  function pure(value, type) {
    return makePure(value, type);
  }
  pure.u8 = (value) => makePure(suiBcs.U8.serialize(value));
  pure.u16 = (value) => makePure(suiBcs.U16.serialize(value));
  pure.u32 = (value) => makePure(suiBcs.U32.serialize(value));
  pure.u64 = (value) => makePure(suiBcs.U64.serialize(value));
  pure.u128 = (value) => makePure(suiBcs.U128.serialize(value));
  pure.u256 = (value) => makePure(suiBcs.U256.serialize(value));
  pure.bool = (value) => makePure(suiBcs.Bool.serialize(value));
  pure.string = (value) => makePure(suiBcs.String.serialize(value));
  pure.address = (value) => makePure(suiBcs.Address.serialize(value));
  pure.id = pure.address;
  return pure;
}

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/builder/serializer.js
var OBJECT_MODULE_NAME = "object";
var ID_STRUCT_NAME = "ID";
var STD_ASCII_MODULE_NAME = "ascii";
var STD_ASCII_STRUCT_NAME = "String";
var STD_UTF8_MODULE_NAME = "string";
var STD_UTF8_STRUCT_NAME = "String";
var STD_OPTION_MODULE_NAME = "option";
var STD_OPTION_STRUCT_NAME = "Option";
var RESOLVED_SUI_ID = {
  address: SUI_FRAMEWORK_ADDRESS,
  module: OBJECT_MODULE_NAME,
  name: ID_STRUCT_NAME
};
var RESOLVED_ASCII_STR = {
  address: MOVE_STDLIB_ADDRESS,
  module: STD_ASCII_MODULE_NAME,
  name: STD_ASCII_STRUCT_NAME
};
var RESOLVED_UTF8_STR = {
  address: MOVE_STDLIB_ADDRESS,
  module: STD_UTF8_MODULE_NAME,
  name: STD_UTF8_STRUCT_NAME
};
var RESOLVED_STD_OPTION = {
  address: MOVE_STDLIB_ADDRESS,
  module: STD_OPTION_MODULE_NAME,
  name: STD_OPTION_STRUCT_NAME
};
var isSameStruct = (a11, b8) => a11.address === b8.address && a11.module === b8.module && a11.name === b8.name;
function isTxContext(param) {
  var _a;
  const struct = (_a = extractStructTag(param)) == null ? void 0 : _a.Struct;
  return (struct == null ? void 0 : struct.address) === "0x2" && (struct == null ? void 0 : struct.module) === "tx_context" && (struct == null ? void 0 : struct.name) === "TxContext";
}
function expectType(typeName, argVal) {
  if (typeof argVal === "undefined") {
    return;
  }
  if (typeof argVal !== typeName) {
    throw new Error(`Expect ${argVal} to be ${typeName}, received ${typeof argVal}`);
  }
}
var allowedTypes = ["Address", "Bool", "U8", "U16", "U32", "U64", "U128", "U256"];
function getPureSerializationType(normalizedType, argVal) {
  if (typeof normalizedType === "string" && allowedTypes.includes(normalizedType)) {
    if (normalizedType in ["U8", "U16", "U32", "U64", "U128", "U256"]) {
      expectType("number", argVal);
    } else if (normalizedType === "Bool") {
      expectType("boolean", argVal);
    } else if (normalizedType === "Address") {
      expectType("string", argVal);
      if (argVal && !isValidSuiAddress(argVal)) {
        throw new Error("Invalid Sui Address");
      }
    }
    return normalizedType.toLowerCase();
  } else if (typeof normalizedType === "string") {
    throw new Error(`Unknown pure normalized type ${JSON.stringify(normalizedType, null, 2)}`);
  }
  if ("Vector" in normalizedType) {
    if ((argVal === void 0 || typeof argVal === "string") && normalizedType.Vector === "U8") {
      return "string";
    }
    if (argVal !== void 0 && !Array.isArray(argVal)) {
      throw new Error(`Expect ${argVal} to be a array, received ${typeof argVal}`);
    }
    const innerType = getPureSerializationType(
      normalizedType.Vector,
      // undefined when argVal is empty
      argVal ? argVal[0] : void 0
    );
    if (innerType === void 0) {
      return;
    }
    return `vector<${innerType}>`;
  }
  if ("Struct" in normalizedType) {
    if (isSameStruct(normalizedType.Struct, RESOLVED_ASCII_STR)) {
      return "string";
    } else if (isSameStruct(normalizedType.Struct, RESOLVED_UTF8_STR)) {
      return "utf8string";
    } else if (isSameStruct(normalizedType.Struct, RESOLVED_SUI_ID)) {
      return "address";
    } else if (isSameStruct(normalizedType.Struct, RESOLVED_STD_OPTION)) {
      const optionToVec = {
        Vector: normalizedType.Struct.typeArguments[0]
      };
      return getPureSerializationType(optionToVec, argVal);
    }
  }
  return void 0;
}

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/builder/hash.js
function hashTypedData(typeTag, data) {
  const typeTagBytes = Array.from(`${typeTag}::`).map((e5) => e5.charCodeAt(0));
  const dataWithTag = new Uint8Array(typeTagBytes.length + data.length);
  dataWithTag.set(typeTagBytes);
  dataWithTag.set(data, typeTagBytes.length);
  return blake2b(dataWithTag, { dkLen: 32 });
}

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/builder/utils.js
function create2(value, struct) {
  return create(value, struct);
}

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/builder/Transactions.js
var option = (some) => union([object({ None: union([literal(true), literal(null)]) }), object({ Some: some })]);
var TransactionBlockInput = union([
  object({
    kind: literal("Input"),
    index: integer(),
    value: optional(any()),
    type: optional(literal("object"))
  }),
  object({
    kind: literal("Input"),
    index: integer(),
    value: optional(any()),
    type: literal("pure")
  })
]);
var TransactionArgumentTypes = [
  TransactionBlockInput,
  object({ kind: literal("GasCoin") }),
  object({ kind: literal("Result"), index: integer() }),
  object({
    kind: literal("NestedResult"),
    index: integer(),
    resultIndex: integer()
  })
];
var TransactionArgument = union([...TransactionArgumentTypes]);
var MoveCallTransaction = object({
  kind: literal("MoveCall"),
  target: define("target", string().validator),
  typeArguments: array(string()),
  arguments: array(TransactionArgument)
});
var TransferObjectsTransaction = object({
  kind: literal("TransferObjects"),
  objects: array(TransactionArgument),
  address: TransactionArgument
});
var SplitCoinsTransaction = object({
  kind: literal("SplitCoins"),
  coin: TransactionArgument,
  amounts: array(TransactionArgument)
});
var MergeCoinsTransaction = object({
  kind: literal("MergeCoins"),
  destination: TransactionArgument,
  sources: array(TransactionArgument)
});
var MakeMoveVecTransaction = object({
  kind: literal("MakeMoveVec"),
  // TODO: ideally we should use `TypeTag` instead of `record()` here,
  // but TypeTag is recursively defined and it's tricky to define a
  // recursive struct in superstruct
  type: optional(option(record(string(), unknown()))),
  objects: array(TransactionArgument)
});
var PublishTransaction = object({
  kind: literal("Publish"),
  modules: array(array(integer())),
  dependencies: array(string())
});
var UpgradePolicy = ((UpgradePolicy2) => {
  UpgradePolicy2[UpgradePolicy2["COMPATIBLE"] = 0] = "COMPATIBLE";
  UpgradePolicy2[UpgradePolicy2["ADDITIVE"] = 128] = "ADDITIVE";
  UpgradePolicy2[UpgradePolicy2["DEP_ONLY"] = 192] = "DEP_ONLY";
  return UpgradePolicy2;
})(UpgradePolicy || {});
var UpgradeTransaction = object({
  kind: literal("Upgrade"),
  modules: array(array(integer())),
  dependencies: array(string()),
  packageId: string(),
  ticket: TransactionArgument
});
var TransactionTypes = [
  MoveCallTransaction,
  TransferObjectsTransaction,
  SplitCoinsTransaction,
  MergeCoinsTransaction,
  PublishTransaction,
  UpgradeTransaction,
  MakeMoveVecTransaction
];
var TransactionType = union([...TransactionTypes]);
var Transactions = {
  MoveCall(input) {
    return create2(
      {
        kind: "MoveCall",
        target: input.target,
        arguments: input.arguments ?? [],
        typeArguments: input.typeArguments ?? []
      },
      MoveCallTransaction
    );
  },
  TransferObjects(objects, address) {
    if (address.kind === "Input" && address.type === "pure" && typeof address.value !== "object") {
      address.value = Inputs.Pure(suiBcs.Address.serialize(address.value));
    }
    return create2({ kind: "TransferObjects", objects, address }, TransferObjectsTransaction);
  },
  SplitCoins(coin, amounts) {
    amounts.forEach((input) => {
      if (input.kind === "Input" && input.type === "pure" && typeof input.value !== "object") {
        input.value = Inputs.Pure(suiBcs.U64.serialize(input.value));
      }
    });
    return create2(
      {
        kind: "SplitCoins",
        coin,
        amounts
      },
      SplitCoinsTransaction
    );
  },
  MergeCoins(destination, sources) {
    return create2({ kind: "MergeCoins", destination, sources }, MergeCoinsTransaction);
  },
  Publish({
    modules,
    dependencies
  }) {
    return create2(
      {
        kind: "Publish",
        modules: modules.map(
          (module) => typeof module === "string" ? Array.from(fromB64(module)) : module
        ),
        dependencies: dependencies.map((dep) => normalizeSuiObjectId(dep))
      },
      PublishTransaction
    );
  },
  Upgrade({
    modules,
    dependencies,
    packageId,
    ticket
  }) {
    return create2(
      {
        kind: "Upgrade",
        modules: modules.map(
          (module) => typeof module === "string" ? Array.from(fromB64(module)) : module
        ),
        dependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),
        packageId,
        ticket
      },
      UpgradeTransaction
    );
  },
  MakeMoveVec({
    type,
    objects
  }) {
    return create2(
      {
        kind: "MakeMoveVec",
        type: type ? { Some: TypeTagSerializer.parseFromStr(type) } : { None: null },
        objects
      },
      MakeMoveVecTransaction
    );
  }
};

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/builder/TransactionBlockData.js
var TransactionExpiration2 = optional(
  nullable(
    union([object({ Epoch: integer() }), object({ None: union([literal(true), literal(null)]) })])
  )
);
var StringEncodedBigint = define("StringEncodedBigint", (val) => {
  if (!["string", "number", "bigint"].includes(typeof val))
    return false;
  try {
    BigInt(val);
    return true;
  } catch {
    return false;
  }
});
var GasConfig = object({
  budget: optional(StringEncodedBigint),
  price: optional(StringEncodedBigint),
  payment: optional(array(SuiObjectRef2)),
  owner: optional(string())
});
var SerializedTransactionDataBuilder = object({
  version: literal(1),
  sender: optional(string()),
  expiration: TransactionExpiration2,
  gasConfig: GasConfig,
  inputs: array(TransactionBlockInput),
  transactions: array(TransactionType)
});
function prepareSuiAddress(address) {
  return normalizeSuiAddress(address).replace("0x", "");
}
var TransactionBlockDataBuilder = class _TransactionBlockDataBuilder {
  constructor(clone) {
    this.version = 1;
    this.sender = clone == null ? void 0 : clone.sender;
    this.expiration = clone == null ? void 0 : clone.expiration;
    this.gasConfig = (clone == null ? void 0 : clone.gasConfig) ?? {};
    this.inputs = (clone == null ? void 0 : clone.inputs) ?? [];
    this.transactions = (clone == null ? void 0 : clone.transactions) ?? [];
  }
  static fromKindBytes(bytes) {
    const kind = suiBcs.TransactionKind.parse(bytes);
    const programmableTx = "ProgrammableTransaction" in kind ? kind.ProgrammableTransaction : null;
    if (!programmableTx) {
      throw new Error("Unable to deserialize from bytes.");
    }
    const serialized = create2(
      {
        version: 1,
        gasConfig: {},
        inputs: programmableTx.inputs.map(
          (value, index) => create2(
            {
              kind: "Input",
              value,
              index,
              type: is(value, PureCallArg) ? "pure" : "object"
            },
            TransactionBlockInput
          )
        ),
        transactions: programmableTx.transactions
      },
      SerializedTransactionDataBuilder
    );
    return _TransactionBlockDataBuilder.restore(serialized);
  }
  static fromBytes(bytes) {
    var _a;
    const rawData = suiBcs.TransactionData.parse(bytes);
    const data = rawData == null ? void 0 : rawData.V1;
    const programmableTx = "ProgrammableTransaction" in data.kind ? (_a = data == null ? void 0 : data.kind) == null ? void 0 : _a.ProgrammableTransaction : null;
    if (!data || !programmableTx) {
      throw new Error("Unable to deserialize from bytes.");
    }
    const serialized = create2(
      {
        version: 1,
        sender: data.sender,
        expiration: data.expiration,
        gasConfig: data.gasData,
        inputs: programmableTx.inputs.map(
          (value, index) => create2(
            {
              kind: "Input",
              value,
              index,
              type: is(value, PureCallArg) ? "pure" : "object"
            },
            TransactionBlockInput
          )
        ),
        transactions: programmableTx.transactions
      },
      SerializedTransactionDataBuilder
    );
    return _TransactionBlockDataBuilder.restore(serialized);
  }
  static restore(data) {
    assert(data, SerializedTransactionDataBuilder);
    const transactionData = new _TransactionBlockDataBuilder();
    Object.assign(transactionData, data);
    return transactionData;
  }
  /**
   * Generate transaction digest.
   *
   * @param bytes BCS serialized transaction data
   * @returns transaction digest.
   */
  static getDigestFromBytes(bytes) {
    const hash = hashTypedData("TransactionData", bytes);
    return toB58(hash);
  }
  build({
    maxSizeBytes = Infinity,
    overrides,
    onlyTransactionKind
  } = {}) {
    const inputs = this.inputs.map((input) => {
      assert(input.value, BuilderCallArg);
      return input.value;
    });
    const kind = {
      ProgrammableTransaction: {
        inputs,
        transactions: this.transactions
      }
    };
    if (onlyTransactionKind) {
      return suiBcs.TransactionKind.serialize(kind, { maxSize: maxSizeBytes }).toBytes();
    }
    const expiration = (overrides == null ? void 0 : overrides.expiration) ?? this.expiration;
    const sender = (overrides == null ? void 0 : overrides.sender) ?? this.sender;
    const gasConfig = { ...this.gasConfig, ...overrides == null ? void 0 : overrides.gasConfig };
    if (!sender) {
      throw new Error("Missing transaction sender");
    }
    if (!gasConfig.budget) {
      throw new Error("Missing gas budget");
    }
    if (!gasConfig.payment) {
      throw new Error("Missing gas payment");
    }
    if (!gasConfig.price) {
      throw new Error("Missing gas price");
    }
    const transactionData = {
      sender: prepareSuiAddress(sender),
      expiration: expiration ? expiration : { None: true },
      gasData: {
        payment: gasConfig.payment,
        owner: prepareSuiAddress(this.gasConfig.owner ?? sender),
        price: BigInt(gasConfig.price),
        budget: BigInt(gasConfig.budget)
      },
      kind: {
        ProgrammableTransaction: {
          inputs,
          transactions: this.transactions
        }
      }
    };
    return suiBcs.TransactionData.serialize(
      { V1: transactionData },
      { maxSize: maxSizeBytes }
    ).toBytes();
  }
  getDigest() {
    const bytes = this.build({ onlyTransactionKind: false });
    return _TransactionBlockDataBuilder.getDigestFromBytes(bytes);
  }
  snapshot() {
    return create2(this, SerializedTransactionDataBuilder);
  }
};

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/builder/TransactionBlock.js
var __accessCheck4 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet4 = (obj, member, getter) => {
  __accessCheck4(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd4 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet4 = (obj, member, value, setter) => {
  __accessCheck4(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod3 = (obj, member, method) => {
  __accessCheck4(obj, member, "access private method");
  return method;
};
var _blockData;
var _input;
var input_fn;
var _normalizeTransactionArgument;
var normalizeTransactionArgument_fn;
var _getConfig;
var getConfig_fn;
var _validate;
var validate_fn;
var _prepareGasPayment;
var prepareGasPayment_fn;
var _prepareGasPrice;
var prepareGasPrice_fn;
var _prepareTransactions;
var prepareTransactions_fn;
var _prepare;
var prepare_fn;
var DefaultOfflineLimits = {
  maxPureArgumentSize: 16 * 1024,
  maxTxGas: 5e10,
  maxGasObjects: 256,
  maxTxSizeBytes: 128 * 1024
};
function createTransactionResult(index) {
  const baseResult = { kind: "Result", index };
  const nestedResults = [];
  const nestedResultFor = (resultIndex) => nestedResults[resultIndex] ?? (nestedResults[resultIndex] = {
    kind: "NestedResult",
    index,
    resultIndex
  });
  return new Proxy(baseResult, {
    set() {
      throw new Error(
        "The transaction result is a proxy, and does not support setting properties directly"
      );
    },
    // TODO: Instead of making this return a concrete argument, we should ideally
    // make it reference-based (so that this gets resolved at build-time), which
    // allows re-ordering transactions.
    get(target, property) {
      if (property in target) {
        return Reflect.get(target, property);
      }
      if (property === Symbol.iterator) {
        return function* () {
          let i9 = 0;
          while (true) {
            yield nestedResultFor(i9);
            i9++;
          }
        };
      }
      if (typeof property === "symbol")
        return;
      const resultIndex = parseInt(property, 10);
      if (Number.isNaN(resultIndex) || resultIndex < 0)
        return;
      return nestedResultFor(resultIndex);
    }
  });
}
function isReceivingType(normalizedType) {
  const tag = extractStructTag(normalizedType);
  if (tag) {
    return tag.Struct.address === "0x2" && tag.Struct.module === "transfer" && tag.Struct.name === "Receiving";
  }
  return false;
}
function expectClient(options) {
  if (!options.client) {
    throw new Error(
      `No provider passed to Transaction#build, but transaction data was not sufficient to build offline.`
    );
  }
  return options.client;
}
var TRANSACTION_BRAND = Symbol.for("@mysten/transaction");
var LIMITS = {
  // The maximum gas that is allowed.
  maxTxGas: "max_tx_gas",
  // The maximum number of gas objects that can be selected for one transaction.
  maxGasObjects: "max_gas_payment_objects",
  // The maximum size (in bytes) that the transaction can be:
  maxTxSizeBytes: "max_tx_size_bytes",
  // The maximum size (in bytes) that pure arguments can be:
  maxPureArgumentSize: "max_pure_argument_size"
};
var GAS_SAFE_OVERHEAD = 1000n;
var MAX_OBJECTS_PER_FETCH = 50;
var chunk = (arr, size) => Array.from(
  { length: Math.ceil(arr.length / size) },
  (_5, i9) => arr.slice(i9 * size, i9 * size + size)
);
function isTransactionBlock(obj) {
  return !!obj && typeof obj === "object" && obj[TRANSACTION_BRAND] === true;
}
var _TransactionBlock = class {
  constructor(transaction) {
    __privateAdd4(this, _input);
    __privateAdd4(this, _normalizeTransactionArgument);
    __privateAdd4(this, _getConfig);
    __privateAdd4(this, _validate);
    __privateAdd4(this, _prepareGasPayment);
    __privateAdd4(this, _prepareGasPrice);
    __privateAdd4(this, _prepareTransactions);
    __privateAdd4(this, _prepare);
    __privateAdd4(this, _blockData, void 0);
    __privateSet4(this, _blockData, new TransactionBlockDataBuilder(
      transaction ? transaction.blockData : void 0
    ));
  }
  /**
   * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.
   * Supports either a byte array, or base64-encoded bytes.
   */
  static fromKind(serialized) {
    const tx = new _TransactionBlock();
    __privateSet4(tx, _blockData, TransactionBlockDataBuilder.fromKindBytes(
      typeof serialized === "string" ? fromB64(serialized) : serialized
    ));
    return tx;
  }
  /**
   * Converts from a serialized transaction format to a `Transaction` class.
   * There are two supported serialized formats:
   * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.
   * - A byte array (or base64-encoded bytes) containing BCS transaction data.
   */
  static from(serialized) {
    const tx = new _TransactionBlock();
    if (typeof serialized !== "string" || !serialized.startsWith("{")) {
      __privateSet4(tx, _blockData, TransactionBlockDataBuilder.fromBytes(
        typeof serialized === "string" ? fromB64(serialized) : serialized
      ));
    } else {
      __privateSet4(tx, _blockData, TransactionBlockDataBuilder.restore(JSON.parse(serialized)));
    }
    return tx;
  }
  setSender(sender) {
    __privateGet4(this, _blockData).sender = sender;
  }
  /**
   * Sets the sender only if it has not already been set.
   * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.
   */
  setSenderIfNotSet(sender) {
    if (!__privateGet4(this, _blockData).sender) {
      __privateGet4(this, _blockData).sender = sender;
    }
  }
  setExpiration(expiration) {
    __privateGet4(this, _blockData).expiration = expiration;
  }
  setGasPrice(price) {
    __privateGet4(this, _blockData).gasConfig.price = String(price);
  }
  setGasBudget(budget) {
    __privateGet4(this, _blockData).gasConfig.budget = String(budget);
  }
  setGasOwner(owner) {
    __privateGet4(this, _blockData).gasConfig.owner = owner;
  }
  setGasPayment(payments) {
    __privateGet4(this, _blockData).gasConfig.payment = payments.map((payment) => mask(payment, SuiObjectRef2));
  }
  /** Get a snapshot of the transaction data, in JSON form: */
  get blockData() {
    return __privateGet4(this, _blockData).snapshot();
  }
  // Used to brand transaction classes so that they can be identified, even between multiple copies
  // of the builder.
  get [TRANSACTION_BRAND]() {
    return true;
  }
  // Temporary workaround for the wallet interface accidentally serializing transaction blocks via postMessage
  get pure() {
    Object.defineProperty(this, "pure", {
      enumerable: false,
      value: createPure((value, type) => {
        if (isSerializedBcs(value)) {
          return __privateMethod3(this, _input, input_fn).call(this, "pure", {
            Pure: Array.from(value.toBytes())
          });
        }
        return __privateMethod3(this, _input, input_fn).call(this, "pure", value instanceof Uint8Array ? Inputs.Pure(value) : type ? Inputs.Pure(value, type) : value);
      })
    });
    return this.pure;
  }
  /** Returns an argument for the gas coin, to be used in a transaction. */
  get gas() {
    return { kind: "GasCoin" };
  }
  /**
   * Add a new object input to the transaction.
   */
  object(value) {
    if (typeof value === "object" && "kind" in value) {
      return value;
    }
    const id = getIdFromCallArg(value);
    const inserted = __privateGet4(this, _blockData).inputs.find(
      (i9) => i9.type === "object" && id === getIdFromCallArg(i9.value)
    );
    return inserted ?? __privateMethod3(this, _input, input_fn).call(this, "object", typeof value === "string" ? normalizeSuiAddress(value) : value);
  }
  /**
   * Add a new object input to the transaction using the fully-resolved object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  objectRef(...args) {
    return this.object(Inputs.ObjectRef(...args));
  }
  /**
   * Add a new receiving input to the transaction using the fully-resolved object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  receivingRef(...args) {
    return this.object(Inputs.ReceivingRef(...args));
  }
  /**
   * Add a new shared object input to the transaction using the fully-resolved shared object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  sharedObjectRef(...args) {
    return this.object(Inputs.SharedObjectRef(...args));
  }
  /** Add a transaction to the transaction block. */
  add(transaction) {
    const index = __privateGet4(this, _blockData).transactions.push(transaction);
    return createTransactionResult(index - 1);
  }
  // Method shorthands:
  splitCoins(coin, amounts) {
    return this.add(
      Transactions.SplitCoins(
        typeof coin === "string" ? this.object(coin) : coin,
        amounts.map(
          (amount) => typeof amount === "number" || typeof amount === "bigint" || typeof amount === "string" ? this.pure.u64(amount) : __privateMethod3(this, _normalizeTransactionArgument, normalizeTransactionArgument_fn).call(this, amount)
        )
      )
    );
  }
  mergeCoins(destination, sources) {
    return this.add(
      Transactions.MergeCoins(
        typeof destination === "string" ? this.object(destination) : destination,
        sources.map((src) => typeof src === "string" ? this.object(src) : src)
      )
    );
  }
  publish({ modules, dependencies }) {
    return this.add(
      Transactions.Publish({
        modules,
        dependencies
      })
    );
  }
  upgrade({
    modules,
    dependencies,
    packageId,
    ticket
  }) {
    return this.add(
      Transactions.Upgrade({
        modules,
        dependencies,
        packageId,
        ticket: typeof ticket === "string" ? this.object(ticket) : ticket
      })
    );
  }
  moveCall({
    arguments: args,
    typeArguments,
    target
  }) {
    return this.add(
      Transactions.MoveCall({
        arguments: args == null ? void 0 : args.map((arg) => __privateMethod3(this, _normalizeTransactionArgument, normalizeTransactionArgument_fn).call(this, arg)),
        typeArguments,
        target
      })
    );
  }
  transferObjects(objects, address) {
    return this.add(
      Transactions.TransferObjects(
        objects.map((obj) => typeof obj === "string" ? this.object(obj) : obj),
        typeof address === "string" ? this.pure.address(address) : __privateMethod3(this, _normalizeTransactionArgument, normalizeTransactionArgument_fn).call(this, address)
      )
    );
  }
  makeMoveVec({
    type,
    objects
  }) {
    return this.add(
      Transactions.MakeMoveVec({
        type,
        objects: objects.map((obj) => typeof obj === "string" ? this.object(obj) : obj)
      })
    );
  }
  /**
   * Serialize the transaction to a string so that it can be sent to a separate context.
   * This is different from `build` in that it does not serialize to BCS bytes, and instead
   * uses a separate format that is unique to the transaction builder. This allows
   * us to serialize partially-complete transactions, that can then be completed and
   * built in a separate context.
   *
   * For example, a dapp can construct a transaction, but not provide gas objects
   * or a gas budget. The transaction then can be sent to the wallet, where this
   * information is automatically filled in (e.g. by querying for coin objects
   * and performing a dry run).
   */
  serialize() {
    return JSON.stringify(__privateGet4(this, _blockData).snapshot());
  }
  /** Build the transaction to BCS bytes, and sign it with the provided keypair. */
  async sign(options) {
    const { signer, ...buildOptions } = options;
    const bytes = await this.build(buildOptions);
    return signer.signTransactionBlock(bytes);
  }
  /** Build the transaction to BCS bytes. */
  async build(options = {}) {
    await __privateMethod3(this, _prepare, prepare_fn).call(this, options);
    return __privateGet4(this, _blockData).build({
      maxSizeBytes: __privateMethod3(this, _getConfig, getConfig_fn).call(this, "maxTxSizeBytes", options),
      onlyTransactionKind: options.onlyTransactionKind
    });
  }
  /** Derive transaction digest */
  async getDigest(options = {}) {
    await __privateMethod3(this, _prepare, prepare_fn).call(this, options);
    return __privateGet4(this, _blockData).getDigest();
  }
};
_blockData = /* @__PURE__ */ new WeakMap();
_input = /* @__PURE__ */ new WeakSet();
input_fn = function(type, value) {
  const index = __privateGet4(this, _blockData).inputs.length;
  const input = create2(
    {
      kind: "Input",
      // bigints can't be serialized to JSON, so just string-convert them here:
      value: typeof value === "bigint" ? String(value) : value,
      index,
      type
    },
    TransactionBlockInput
  );
  __privateGet4(this, _blockData).inputs.push(input);
  return input;
};
_normalizeTransactionArgument = /* @__PURE__ */ new WeakSet();
normalizeTransactionArgument_fn = function(arg) {
  if (isSerializedBcs(arg)) {
    return this.pure(arg);
  }
  return arg;
};
_getConfig = /* @__PURE__ */ new WeakSet();
getConfig_fn = function(key, { protocolConfig, limits }) {
  if (limits && typeof limits[key] === "number") {
    return limits[key];
  }
  if (!protocolConfig) {
    return DefaultOfflineLimits[key];
  }
  const attribute = protocolConfig == null ? void 0 : protocolConfig.attributes[LIMITS[key]];
  if (!attribute) {
    throw new Error(`Missing expected protocol config: "${LIMITS[key]}"`);
  }
  const value = "u64" in attribute ? attribute.u64 : "u32" in attribute ? attribute.u32 : attribute.f64;
  if (!value) {
    throw new Error(`Unexpected protocol config value found for: "${LIMITS[key]}"`);
  }
  return Number(value);
};
_validate = /* @__PURE__ */ new WeakSet();
validate_fn = function(options) {
  const maxPureArgumentSize = __privateMethod3(this, _getConfig, getConfig_fn).call(this, "maxPureArgumentSize", options);
  __privateGet4(this, _blockData).inputs.forEach((input, index) => {
    if (is(input.value, PureCallArg)) {
      if (input.value.Pure.length > maxPureArgumentSize) {
        throw new Error(
          `Input at index ${index} is too large, max pure input size is ${maxPureArgumentSize} bytes, got ${input.value.Pure.length} bytes`
        );
      }
    }
  });
};
_prepareGasPayment = /* @__PURE__ */ new WeakSet();
prepareGasPayment_fn = async function(options) {
  if (__privateGet4(this, _blockData).gasConfig.payment) {
    const maxGasObjects = __privateMethod3(this, _getConfig, getConfig_fn).call(this, "maxGasObjects", options);
    if (__privateGet4(this, _blockData).gasConfig.payment.length > maxGasObjects) {
      throw new Error(`Payment objects exceed maximum amount: ${maxGasObjects}`);
    }
  }
  if (options.onlyTransactionKind || __privateGet4(this, _blockData).gasConfig.payment) {
    return;
  }
  const gasOwner = __privateGet4(this, _blockData).gasConfig.owner ?? __privateGet4(this, _blockData).sender;
  const coins = await expectClient(options).getCoins({
    owner: gasOwner,
    coinType: SUI_TYPE_ARG
  });
  const paymentCoins = coins.data.filter((coin) => {
    const matchingInput = __privateGet4(this, _blockData).inputs.find((input) => {
      if (is(input.value, BuilderCallArg) && "Object" in input.value && "ImmOrOwned" in input.value.Object) {
        return coin.coinObjectId === input.value.Object.ImmOrOwned.objectId;
      }
      return false;
    });
    return !matchingInput;
  }).slice(0, __privateMethod3(this, _getConfig, getConfig_fn).call(this, "maxGasObjects", options) - 1).map((coin) => ({
    objectId: coin.coinObjectId,
    digest: coin.digest,
    version: coin.version
  }));
  if (!paymentCoins.length) {
    throw new Error("No valid gas coins found for the transaction.");
  }
  this.setGasPayment(paymentCoins);
};
_prepareGasPrice = /* @__PURE__ */ new WeakSet();
prepareGasPrice_fn = async function(options) {
  if (options.onlyTransactionKind || __privateGet4(this, _blockData).gasConfig.price) {
    return;
  }
  this.setGasPrice(await expectClient(options).getReferenceGasPrice());
};
_prepareTransactions = /* @__PURE__ */ new WeakSet();
prepareTransactions_fn = async function(options) {
  const { inputs, transactions } = __privateGet4(this, _blockData);
  const moveModulesToResolve = [];
  const objectsToResolve = [];
  inputs.forEach((input) => {
    if (input.type === "object" && typeof input.value === "string") {
      objectsToResolve.push({ id: normalizeSuiAddress(input.value), input });
      return;
    }
  });
  transactions.forEach((transaction) => {
    if (transaction.kind === "MoveCall") {
      const needsResolution = transaction.arguments.some(
        (arg) => arg.kind === "Input" && !is(inputs[arg.index].value, BuilderCallArg)
      );
      if (needsResolution) {
        moveModulesToResolve.push(transaction);
      }
    }
    if (transaction.kind === "SplitCoins") {
      transaction.amounts.forEach((amount) => {
        if (amount.kind === "Input") {
          const input = inputs[amount.index];
          if (typeof input.value !== "object") {
            input.value = Inputs.Pure(suiBcs.U64.serialize(input.value));
          }
        }
      });
    }
    if (transaction.kind === "TransferObjects") {
      if (transaction.address.kind === "Input") {
        const input = inputs[transaction.address.index];
        if (typeof input.value !== "object") {
          input.value = Inputs.Pure(suiBcs.Address.serialize(input.value));
        }
      }
    }
  });
  if (moveModulesToResolve.length) {
    await Promise.all(
      moveModulesToResolve.map(async (moveCall) => {
        const [packageId, moduleName, functionName] = moveCall.target.split("::");
        const normalized = await expectClient(options).getNormalizedMoveFunction({
          package: normalizeSuiObjectId(packageId),
          module: moduleName,
          function: functionName
        });
        const hasTxContext = normalized.parameters.length > 0 && isTxContext(normalized.parameters.at(-1));
        const params = hasTxContext ? normalized.parameters.slice(0, normalized.parameters.length - 1) : normalized.parameters;
        if (params.length !== moveCall.arguments.length) {
          throw new Error("Incorrect number of arguments.");
        }
        params.forEach((param, i9) => {
          const arg = moveCall.arguments[i9];
          if (arg.kind !== "Input")
            return;
          const input = inputs[arg.index];
          if (is(input.value, BuilderCallArg))
            return;
          const inputValue = input.value;
          const serType = getPureSerializationType(param, inputValue);
          if (serType) {
            input.value = Inputs.Pure(inputValue, serType);
            return;
          }
          const structVal = extractStructTag(param);
          if (structVal != null || typeof param === "object" && "TypeParameter" in param) {
            if (typeof inputValue !== "string") {
              throw new Error(
                `Expect the argument to be an object id string, got ${JSON.stringify(
                  inputValue,
                  null,
                  2
                )}`
              );
            }
            objectsToResolve.push({
              id: inputValue,
              input,
              normalizedType: param
            });
            return;
          }
          throw new Error(
            `Unknown call arg type ${JSON.stringify(param, null, 2)} for value ${JSON.stringify(
              inputValue,
              null,
              2
            )}`
          );
        });
      })
    );
  }
  if (objectsToResolve.length) {
    const dedupedIds = [...new Set(objectsToResolve.map(({ id }) => id))];
    const objectChunks = chunk(dedupedIds, MAX_OBJECTS_PER_FETCH);
    const objects = (await Promise.all(
      objectChunks.map(
        (chunk2) => expectClient(options).multiGetObjects({
          ids: chunk2,
          options: { showOwner: true }
        })
      )
    )).flat();
    let objectsById = new Map(
      dedupedIds.map((id, index) => {
        return [id, objects[index]];
      })
    );
    const invalidObjects = Array.from(objectsById).filter(([_5, obj]) => obj.error).map(([id, _5]) => id);
    if (invalidObjects.length) {
      throw new Error(`The following input objects are invalid: ${invalidObjects.join(", ")}`);
    }
    objectsToResolve.forEach(({ id, input, normalizedType }) => {
      var _a;
      const object2 = objectsById.get(id);
      const owner = (_a = object2.data) == null ? void 0 : _a.owner;
      const initialSharedVersion = owner && typeof owner === "object" && "Shared" in owner ? owner.Shared.initial_shared_version : void 0;
      if (initialSharedVersion) {
        const isByValue = normalizedType != null && extractMutableReference(normalizedType) == null && extractReference(normalizedType) == null;
        const mutable = isMutableSharedObjectInput(input.value) || isByValue || normalizedType != null && extractMutableReference(normalizedType) != null;
        input.value = Inputs.SharedObjectRef({
          objectId: id,
          initialSharedVersion,
          mutable
        });
      } else if (normalizedType && isReceivingType(normalizedType)) {
        input.value = Inputs.ReceivingRef(getObjectReference(object2));
      } else {
        input.value = Inputs.ObjectRef(getObjectReference(object2));
      }
    });
  }
};
_prepare = /* @__PURE__ */ new WeakSet();
prepare_fn = async function(options) {
  if (!options.onlyTransactionKind && !__privateGet4(this, _blockData).sender) {
    throw new Error("Missing transaction sender");
  }
  if (!options.protocolConfig && !options.limits && options.client) {
    options.protocolConfig = await options.client.getProtocolConfig();
  }
  await Promise.all([__privateMethod3(this, _prepareGasPrice, prepareGasPrice_fn).call(this, options), __privateMethod3(this, _prepareTransactions, prepareTransactions_fn).call(this, options)]);
  if (!options.onlyTransactionKind) {
    await __privateMethod3(this, _prepareGasPayment, prepareGasPayment_fn).call(this, options);
    if (!__privateGet4(this, _blockData).gasConfig.budget) {
      const dryRunResult = await expectClient(options).dryRunTransactionBlock({
        transactionBlock: __privateGet4(this, _blockData).build({
          maxSizeBytes: __privateMethod3(this, _getConfig, getConfig_fn).call(this, "maxTxSizeBytes", options),
          overrides: {
            gasConfig: {
              budget: String(__privateMethod3(this, _getConfig, getConfig_fn).call(this, "maxTxGas", options)),
              payment: []
            }
          }
        })
      });
      if (dryRunResult.effects.status.status !== "success") {
        throw new Error(
          `Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`,
          { cause: dryRunResult }
        );
      }
      const safeOverhead = GAS_SAFE_OVERHEAD * BigInt(this.blockData.gasConfig.price || 1n);
      const baseComputationCostWithOverhead = BigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;
      const gasBudget = baseComputationCostWithOverhead + BigInt(dryRunResult.effects.gasUsed.storageCost) - BigInt(dryRunResult.effects.gasUsed.storageRebate);
      this.setGasBudget(
        gasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead
      );
    }
  }
  __privateMethod3(this, _validate, validate_fn).call(this, options);
};

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/client/client.js
var SUI_CLIENT_BRAND = Symbol.for("@mysten/SuiClient");
var SuiClient = class {
  get [SUI_CLIENT_BRAND]() {
    return true;
  }
  /**
   * Establish a connection to a Sui RPC endpoint
   *
   * @param options configuration options for the API Client
   */
  constructor(options) {
    this.transport = options.transport ?? new SuiHTTPTransport({ url: options.url });
  }
  async getRpcApiVersion() {
    const resp = await this.transport.request({
      method: "rpc.discover",
      params: []
    });
    return resp.info.version;
  }
  /**
   * Get all Coin<`coin_type`> objects owned by an address.
   */
  async getCoins(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({
      method: "suix_getCoins",
      params: [input.owner, input.coinType, input.cursor, input.limit]
    });
  }
  /**
   * Get all Coin objects owned by an address.
   */
  async getAllCoins(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({
      method: "suix_getAllCoins",
      params: [input.owner, input.cursor, input.limit]
    });
  }
  /**
   * Get the total coin balance for one coin type, owned by the address owner.
   */
  async getBalance(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({
      method: "suix_getBalance",
      params: [input.owner, input.coinType]
    });
  }
  /**
   * Get the total coin balance for all coin types, owned by the address owner.
   */
  async getAllBalances(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({ method: "suix_getAllBalances", params: [input.owner] });
  }
  /**
   * Fetch CoinMetadata for a given coin type
   */
  async getCoinMetadata(input) {
    return await this.transport.request({
      method: "suix_getCoinMetadata",
      params: [input.coinType]
    });
  }
  /**
   *  Fetch total supply for a coin
   */
  async getTotalSupply(input) {
    return await this.transport.request({
      method: "suix_getTotalSupply",
      params: [input.coinType]
    });
  }
  /**
   * Invoke any RPC method
   * @param method the method to be invoked
   * @param args the arguments to be passed to the RPC request
   */
  async call(method, params) {
    return await this.transport.request({ method, params });
  }
  /**
   * Get Move function argument types like read, write and full access
   */
  async getMoveFunctionArgTypes(input) {
    return await this.transport.request({
      method: "sui_getMoveFunctionArgTypes",
      params: [input.package, input.module, input.function]
    });
  }
  /**
   * Get a map from module name to
   * structured representations of Move modules
   */
  async getNormalizedMoveModulesByPackage(input) {
    return await this.transport.request({
      method: "sui_getNormalizedMoveModulesByPackage",
      params: [input.package]
    });
  }
  /**
   * Get a structured representation of Move module
   */
  async getNormalizedMoveModule(input) {
    return await this.transport.request({
      method: "sui_getNormalizedMoveModule",
      params: [input.package, input.module]
    });
  }
  /**
   * Get a structured representation of Move function
   */
  async getNormalizedMoveFunction(input) {
    return await this.transport.request({
      method: "sui_getNormalizedMoveFunction",
      params: [input.package, input.module, input.function]
    });
  }
  /**
   * Get a structured representation of Move struct
   */
  async getNormalizedMoveStruct(input) {
    return await this.transport.request({
      method: "sui_getNormalizedMoveStruct",
      params: [input.package, input.module, input.struct]
    });
  }
  /**
   * Get all objects owned by an address
   */
  async getOwnedObjects(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({
      method: "suix_getOwnedObjects",
      params: [
        input.owner,
        {
          filter: input.filter,
          options: input.options
        },
        input.cursor,
        input.limit
      ]
    });
  }
  /**
   * Get details about an object
   */
  async getObject(input) {
    if (!input.id || !isValidSuiObjectId(normalizeSuiObjectId(input.id))) {
      throw new Error("Invalid Sui Object id");
    }
    return await this.transport.request({
      method: "sui_getObject",
      params: [input.id, input.options]
    });
  }
  async tryGetPastObject(input) {
    return await this.transport.request({
      method: "sui_tryGetPastObject",
      params: [input.id, input.version, input.options]
    });
  }
  /**
   * Batch get details about a list of objects. If any of the object ids are duplicates the call will fail
   */
  async multiGetObjects(input) {
    input.ids.forEach((id) => {
      if (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {
        throw new Error(`Invalid Sui Object id ${id}`);
      }
    });
    const hasDuplicates = input.ids.length !== new Set(input.ids).size;
    if (hasDuplicates) {
      throw new Error(`Duplicate object ids in batch call ${input.ids}`);
    }
    return await this.transport.request({
      method: "sui_multiGetObjects",
      params: [input.ids, input.options]
    });
  }
  /**
   * Get transaction blocks for a given query criteria
   */
  async queryTransactionBlocks(input) {
    return await this.transport.request({
      method: "suix_queryTransactionBlocks",
      params: [
        {
          filter: input.filter,
          options: input.options
        },
        input.cursor,
        input.limit,
        (input.order || "descending") === "descending"
      ]
    });
  }
  async getTransactionBlock(input) {
    if (!isValidTransactionDigest(input.digest)) {
      throw new Error("Invalid Transaction digest");
    }
    return await this.transport.request({
      method: "sui_getTransactionBlock",
      params: [input.digest, input.options]
    });
  }
  async multiGetTransactionBlocks(input) {
    input.digests.forEach((d17) => {
      if (!isValidTransactionDigest(d17)) {
        throw new Error(`Invalid Transaction digest ${d17}`);
      }
    });
    const hasDuplicates = input.digests.length !== new Set(input.digests).size;
    if (hasDuplicates) {
      throw new Error(`Duplicate digests in batch call ${input.digests}`);
    }
    return await this.transport.request({
      method: "sui_multiGetTransactionBlocks",
      params: [input.digests, input.options]
    });
  }
  async executeTransactionBlock(input) {
    return await this.transport.request({
      method: "sui_executeTransactionBlock",
      params: [
        typeof input.transactionBlock === "string" ? input.transactionBlock : toB64(input.transactionBlock),
        Array.isArray(input.signature) ? input.signature : [input.signature],
        input.options,
        input.requestType
      ]
    });
  }
  async signAndExecuteTransactionBlock({
    transactionBlock,
    signer,
    ...input
  }) {
    let transactionBytes;
    if (transactionBlock instanceof Uint8Array) {
      transactionBytes = transactionBlock;
    } else {
      transactionBlock.setSenderIfNotSet(signer.toSuiAddress());
      transactionBytes = await transactionBlock.build({ client: this });
    }
    const { signature, bytes } = await signer.signTransactionBlock(transactionBytes);
    return this.executeTransactionBlock({
      transactionBlock: bytes,
      signature,
      ...input
    });
  }
  /**
   * Get total number of transactions
   */
  async getTotalTransactionBlocks() {
    const resp = await this.transport.request({
      method: "sui_getTotalTransactionBlocks",
      params: []
    });
    return BigInt(resp);
  }
  /**
   * Getting the reference gas price for the network
   */
  async getReferenceGasPrice() {
    const resp = await this.transport.request({
      method: "suix_getReferenceGasPrice",
      params: []
    });
    return BigInt(resp);
  }
  /**
   * Return the delegated stakes for an address
   */
  async getStakes(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({ method: "suix_getStakes", params: [input.owner] });
  }
  /**
   * Return the delegated stakes queried by id.
   */
  async getStakesByIds(input) {
    input.stakedSuiIds.forEach((id) => {
      if (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {
        throw new Error(`Invalid Sui Stake id ${id}`);
      }
    });
    return await this.transport.request({
      method: "suix_getStakesByIds",
      params: [input.stakedSuiIds]
    });
  }
  /**
   * Return the latest system state content.
   */
  async getLatestSuiSystemState() {
    return await this.transport.request({ method: "suix_getLatestSuiSystemState", params: [] });
  }
  /**
   * Get events for a given query criteria
   */
  async queryEvents(input) {
    return await this.transport.request({
      method: "suix_queryEvents",
      params: [
        input.query,
        input.cursor,
        input.limit,
        (input.order || "descending") === "descending"
      ]
    });
  }
  /**
   * Subscribe to get notifications whenever an event matching the filter occurs
   */
  async subscribeEvent(input) {
    return this.transport.subscribe({
      method: "suix_subscribeEvent",
      unsubscribe: "suix_unsubscribeEvent",
      params: [input.filter],
      onMessage: input.onMessage
    });
  }
  async subscribeTransaction(input) {
    return this.transport.subscribe({
      method: "suix_subscribeTransaction",
      unsubscribe: "suix_unsubscribeTransaction",
      params: [input.filter],
      onMessage: input.onMessage
    });
  }
  /**
   * Runs the transaction block in dev-inspect mode. Which allows for nearly any
   * transaction (or Move call) with any arguments. Detailed results are
   * provided, including both the transaction effects and any return values.
   */
  async devInspectTransactionBlock(input) {
    var _a;
    let devInspectTxBytes;
    if (isTransactionBlock(input.transactionBlock)) {
      input.transactionBlock.setSenderIfNotSet(input.sender);
      devInspectTxBytes = toB64(
        await input.transactionBlock.build({
          client: this,
          onlyTransactionKind: true
        })
      );
    } else if (typeof input.transactionBlock === "string") {
      devInspectTxBytes = input.transactionBlock;
    } else if (input.transactionBlock instanceof Uint8Array) {
      devInspectTxBytes = toB64(input.transactionBlock);
    } else {
      throw new Error("Unknown transaction block format.");
    }
    return await this.transport.request({
      method: "sui_devInspectTransactionBlock",
      params: [input.sender, devInspectTxBytes, (_a = input.gasPrice) == null ? void 0 : _a.toString(), input.epoch]
    });
  }
  /**
   * Dry run a transaction block and return the result.
   */
  async dryRunTransactionBlock(input) {
    return await this.transport.request({
      method: "sui_dryRunTransactionBlock",
      params: [
        typeof input.transactionBlock === "string" ? input.transactionBlock : toB64(input.transactionBlock)
      ]
    });
  }
  /**
   * Return the list of dynamic field objects owned by an object
   */
  async getDynamicFields(input) {
    if (!input.parentId || !isValidSuiObjectId(normalizeSuiObjectId(input.parentId))) {
      throw new Error("Invalid Sui Object id");
    }
    return await this.transport.request({
      method: "suix_getDynamicFields",
      params: [input.parentId, input.cursor, input.limit]
    });
  }
  /**
   * Return the dynamic field object information for a specified object
   */
  async getDynamicFieldObject(input) {
    return await this.transport.request({
      method: "suix_getDynamicFieldObject",
      params: [input.parentId, input.name]
    });
  }
  /**
   * Get the sequence number of the latest checkpoint that has been executed
   */
  async getLatestCheckpointSequenceNumber() {
    const resp = await this.transport.request({
      method: "sui_getLatestCheckpointSequenceNumber",
      params: []
    });
    return String(resp);
  }
  /**
   * Returns information about a given checkpoint
   */
  async getCheckpoint(input) {
    return await this.transport.request({ method: "sui_getCheckpoint", params: [input.id] });
  }
  /**
   * Returns historical checkpoints paginated
   */
  async getCheckpoints(input) {
    return await this.transport.request({
      method: "sui_getCheckpoints",
      params: [input.cursor, input == null ? void 0 : input.limit, input.descendingOrder]
    });
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getCommitteeInfo(input) {
    return await this.transport.request({
      method: "suix_getCommitteeInfo",
      params: [input == null ? void 0 : input.epoch]
    });
  }
  async getNetworkMetrics() {
    return await this.transport.request({ method: "suix_getNetworkMetrics", params: [] });
  }
  async getAddressMetrics() {
    return await this.transport.request({ method: "suix_getLatestAddressMetrics", params: [] });
  }
  async getEpochMetrics(input) {
    return await this.transport.request({
      method: "suix_getEpochMetrics",
      params: [input == null ? void 0 : input.cursor, input == null ? void 0 : input.limit, input == null ? void 0 : input.descendingOrder]
    });
  }
  async getAllEpochAddressMetrics(input) {
    return await this.transport.request({
      method: "suix_getAllEpochAddressMetrics",
      params: [input == null ? void 0 : input.descendingOrder]
    });
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getEpochs(input) {
    return await this.transport.request({
      method: "suix_getEpochs",
      params: [input == null ? void 0 : input.cursor, input == null ? void 0 : input.limit, input == null ? void 0 : input.descendingOrder]
    });
  }
  /**
   * Returns list of top move calls by usage
   */
  async getMoveCallMetrics() {
    return await this.transport.request({ method: "suix_getMoveCallMetrics", params: [] });
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getCurrentEpoch() {
    return await this.transport.request({ method: "suix_getCurrentEpoch", params: [] });
  }
  /**
   * Return the Validators APYs
   */
  async getValidatorsApy() {
    return await this.transport.request({ method: "suix_getValidatorsApy", params: [] });
  }
  // TODO: Migrate this to `sui_getChainIdentifier` once it is widely available.
  async getChainIdentifier() {
    const checkpoint = await this.getCheckpoint({ id: "0" });
    const bytes = fromB58(checkpoint.digest);
    return toHEX(bytes.slice(0, 4));
  }
  async resolveNameServiceAddress(input) {
    return await this.transport.request({
      method: "suix_resolveNameServiceAddress",
      params: [input.name]
    });
  }
  async resolveNameServiceNames(input) {
    return await this.transport.request({
      method: "suix_resolveNameServiceNames",
      params: [input.address, input.cursor, input.limit]
    });
  }
  async getProtocolConfig(input) {
    return await this.transport.request({
      method: "sui_getProtocolConfig",
      params: [input == null ? void 0 : input.version]
    });
  }
  /**
   * Wait for a transaction block result to be available over the API.
   * This can be used in conjunction with `executeTransactionBlock` to wait for the transaction to
   * be available via the API.
   * This currently polls the `getTransactionBlock` API to check for the transaction.
   */
  async waitForTransactionBlock({
    signal,
    timeout = 60 * 1e3,
    pollInterval = 2 * 1e3,
    ...input
  }) {
    const timeoutSignal = AbortSignal.timeout(timeout);
    const timeoutPromise = new Promise((_5, reject) => {
      timeoutSignal.addEventListener("abort", () => reject(timeoutSignal.reason));
    });
    timeoutPromise.catch(() => {
    });
    while (!timeoutSignal.aborted) {
      signal == null ? void 0 : signal.throwIfAborted();
      try {
        return await this.getTransactionBlock(input);
      } catch (e5) {
        await Promise.race([
          new Promise((resolve) => setTimeout(resolve, pollInterval)),
          timeoutPromise
        ]);
      }
    }
    timeoutSignal.throwIfAborted();
    throw new Error("Unexpected error while waiting for transaction block.");
  }
};

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/faucet/index.js
var FaucetRateLimitError = class extends Error {
};
async function faucetRequest({ host, path, body, headers, method }) {
  const endpoint = new URL(path, host).toString();
  const res = await fetch(endpoint, {
    method,
    body: body ? JSON.stringify(body) : void 0,
    headers: {
      "Content-Type": "application/json",
      ...headers || {}
    }
  });
  if (res.status === 429) {
    throw new FaucetRateLimitError(
      `Too many requests from this client have been sent to the faucet. Please retry later`
    );
  }
  try {
    const parsed = await res.json();
    if (parsed.error) {
      throw new Error(`Faucet returns error: ${parsed.error}`);
    }
    return parsed;
  } catch (e5) {
    throw new Error(
      `Encountered error when parsing response from faucet, error: ${e5}, status ${res.status}, response ${res}`
    );
  }
}
async function requestSuiFromFaucetV0(input) {
  return faucetRequest({
    host: input.host,
    path: "/gas",
    body: {
      FixedAmountRequest: {
        recipient: input.recipient
      }
    },
    headers: input.headers,
    method: "POST"
  });
}
function getFaucetHost(network) {
  switch (network) {
    case "testnet":
      return "https://faucet.testnet.sui.io";
    case "devnet":
      return "https://faucet.devnet.sui.io";
    case "localnet":
      return "http://127.0.0.1:9123";
    default:
      throw new Error(`Unknown network: ${network}`);
  }
}

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/keypairs/ed25519/keypair.js
var import_tweetnacl3 = __toESM(require_nacl_fast(), 1);

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/cryptography/intent.js
var AppId = ((AppId2) => {
  AppId2[AppId2["Sui"] = 0] = "Sui";
  return AppId2;
})(AppId || {});
var IntentVersion = ((IntentVersion2) => {
  IntentVersion2[IntentVersion2["V0"] = 0] = "V0";
  return IntentVersion2;
})(IntentVersion || {});
var IntentScope = ((IntentScope2) => {
  IntentScope2[IntentScope2["TransactionData"] = 0] = "TransactionData";
  IntentScope2[IntentScope2["TransactionEffects"] = 1] = "TransactionEffects";
  IntentScope2[IntentScope2["CheckpointSummary"] = 2] = "CheckpointSummary";
  IntentScope2[IntentScope2["PersonalMessage"] = 3] = "PersonalMessage";
  return IntentScope2;
})(IntentScope || {});
function intentWithScope(scope) {
  return [
    scope,
    0,
    0
    /* Sui */
  ];
}
function messageWithIntent(scope, message) {
  const intent = intentWithScope(scope);
  const intentMessage = new Uint8Array(intent.length + message.length);
  intentMessage.set(intent);
  intentMessage.set(message, intent.length);
  return intentMessage;
}

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/cryptography/signature-scheme.js
var SIGNATURE_SCHEME_TO_FLAG = {
  ED25519: 0,
  Secp256k1: 1,
  Secp256r1: 2,
  MultiSig: 3,
  ZkLogin: 5
};
var SIGNATURE_SCHEME_TO_SIZE = {
  ED25519: 32,
  Secp256k1: 33,
  Secp256r1: 33
};
var SIGNATURE_FLAG_TO_SCHEME = {
  0: "ED25519",
  1: "Secp256k1",
  2: "Secp256r1",
  3: "MultiSig",
  5: "ZkLogin"
};

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/zklogin/utils.js
function findFirstNonZeroIndex(bytes) {
  for (let i9 = 0; i9 < bytes.length; i9++) {
    if (bytes[i9] !== 0) {
      return i9;
    }
  }
  return -1;
}
function toPaddedBigEndianBytes(num, width) {
  const hex = num.toString(16);
  return hexToBytes(hex.padStart(width * 2, "0").slice(-width * 2));
}
function toBigEndianBytes(num, width) {
  const bytes = toPaddedBigEndianBytes(num, width);
  const firstNonZeroIndex = findFirstNonZeroIndex(bytes);
  if (firstNonZeroIndex === -1) {
    return new Uint8Array([0]);
  }
  return bytes.slice(firstNonZeroIndex);
}

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/zklogin/address.js
function computeZkLoginAddressFromSeed(addressSeed, iss) {
  const addressSeedBytesBigEndian = toBigEndianBytes(addressSeed, 32);
  if (iss === "accounts.google.com") {
    iss = "https://accounts.google.com";
  }
  const addressParamBytes = new TextEncoder().encode(iss);
  const tmp = new Uint8Array(2 + addressSeedBytesBigEndian.length + addressParamBytes.length);
  tmp.set([SIGNATURE_SCHEME_TO_FLAG.ZkLogin]);
  tmp.set([addressParamBytes.length], 1);
  tmp.set(addressParamBytes, 2);
  tmp.set(addressSeedBytesBigEndian, 2 + addressParamBytes.length);
  return normalizeSuiAddress(
    bytesToHex(blake2b(tmp, { dkLen: 32 })).slice(0, SUI_ADDRESS_LENGTH2 * 2)
  );
}

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/zklogin/jwt-utils.js
function base64UrlCharTo6Bits(base64UrlChar) {
  if (base64UrlChar.length !== 1) {
    throw new Error("Invalid base64Url character: " + base64UrlChar);
  }
  const base64UrlCharacterSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
  const index = base64UrlCharacterSet.indexOf(base64UrlChar);
  if (index === -1) {
    throw new Error("Invalid base64Url character: " + base64UrlChar);
  }
  const binaryString = index.toString(2).padStart(6, "0");
  const bits = Array.from(binaryString).map(Number);
  return bits;
}
function base64UrlStringToBitVector(base64UrlString) {
  let bitVector = [];
  for (let i9 = 0; i9 < base64UrlString.length; i9++) {
    const base64UrlChar = base64UrlString.charAt(i9);
    const bits = base64UrlCharTo6Bits(base64UrlChar);
    bitVector = bitVector.concat(bits);
  }
  return bitVector;
}
function decodeBase64URL(s18, i9) {
  if (s18.length < 2) {
    throw new Error(`Input (s = ${s18}) is not tightly packed because s.length < 2`);
  }
  let bits = base64UrlStringToBitVector(s18);
  const firstCharOffset = i9 % 4;
  if (firstCharOffset === 0) {
  } else if (firstCharOffset === 1) {
    bits = bits.slice(2);
  } else if (firstCharOffset === 2) {
    bits = bits.slice(4);
  } else {
    throw new Error(`Input (s = ${s18}) is not tightly packed because i%4 = 3 (i = ${i9}))`);
  }
  const lastCharOffset = (i9 + s18.length - 1) % 4;
  if (lastCharOffset === 3) {
  } else if (lastCharOffset === 2) {
    bits = bits.slice(0, bits.length - 2);
  } else if (lastCharOffset === 1) {
    bits = bits.slice(0, bits.length - 4);
  } else {
    throw new Error(
      `Input (s = ${s18}) is not tightly packed because (i + s.length - 1)%4 = 0 (i = ${i9}))`
    );
  }
  if (bits.length % 8 !== 0) {
    throw new Error(`We should never reach here...`);
  }
  const bytes = new Uint8Array(Math.floor(bits.length / 8));
  let currentByteIndex = 0;
  for (let i22 = 0; i22 < bits.length; i22 += 8) {
    const bitChunk = bits.slice(i22, i22 + 8);
    const byte = parseInt(bitChunk.join(""), 2);
    bytes[currentByteIndex++] = byte;
  }
  return new TextDecoder().decode(bytes);
}
function verifyExtendedClaim(claim) {
  if (!(claim.slice(-1) === "}" || claim.slice(-1) === ",")) {
    throw new Error("Invalid claim");
  }
  const json = JSON.parse("{" + claim.slice(0, -1) + "}");
  if (Object.keys(json).length !== 1) {
    throw new Error("Invalid claim");
  }
  const key = Object.keys(json)[0];
  return [key, json[key]];
}
function extractClaimValue(claim, claimName) {
  const extendedClaim = decodeBase64URL(claim.value, claim.indexMod4);
  const [name, value] = verifyExtendedClaim(extendedClaim);
  if (name !== claimName) {
    throw new Error(`Invalid field name: found ${name} expected ${claimName}`);
  }
  return value;
}

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/zklogin/bcs.js
var zkLoginSignature = bcs.struct("ZkLoginSignature", {
  inputs: bcs.struct("ZkLoginSignatureInputs", {
    proofPoints: bcs.struct("ZkLoginSignatureInputsProofPoints", {
      a: bcs.vector(bcs.string()),
      b: bcs.vector(bcs.vector(bcs.string())),
      c: bcs.vector(bcs.string())
    }),
    issBase64Details: bcs.struct("ZkLoginSignatureInputsClaim", {
      value: bcs.string(),
      indexMod4: bcs.u8()
    }),
    headerBase64: bcs.string(),
    addressSeed: bcs.string()
  }),
  maxEpoch: bcs.u64(),
  userSignature: bcs.vector(bcs.u8())
});

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/zklogin/signature.js
function parseZkLoginSignature(signature) {
  return zkLoginSignature.parse(typeof signature === "string" ? fromB64(signature) : signature);
}

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/cryptography/signature.js
function toSerializedSignature({
  signature,
  signatureScheme,
  publicKey
}) {
  if (!publicKey) {
    throw new Error("`publicKey` is required");
  }
  const pubKeyBytes = publicKey.toRawBytes();
  const serializedSignature = new Uint8Array(1 + signature.length + pubKeyBytes.length);
  serializedSignature.set([SIGNATURE_SCHEME_TO_FLAG[signatureScheme]]);
  serializedSignature.set(signature, 1);
  serializedSignature.set(pubKeyBytes, 1 + signature.length);
  return toB64(serializedSignature);
}
function parseSerializedSignature(serializedSignature) {
  const bytes = fromB64(serializedSignature);
  const signatureScheme = SIGNATURE_FLAG_TO_SCHEME[bytes[0]];
  switch (signatureScheme) {
    case "MultiSig":
      const multisig = suiBcs.MultiSig.parse(bytes.slice(1));
      return {
        serializedSignature,
        signatureScheme,
        multisig,
        bytes
      };
    case "ZkLogin":
      const signatureBytes = bytes.slice(1);
      const { inputs, maxEpoch, userSignature } = parseZkLoginSignature(signatureBytes);
      const { issBase64Details, addressSeed } = inputs;
      const iss = extractClaimValue(issBase64Details, "iss");
      const address = computeZkLoginAddressFromSeed(BigInt(addressSeed), iss);
      return {
        serializedSignature,
        signatureScheme,
        zkLogin: {
          inputs,
          maxEpoch,
          userSignature,
          iss,
          address,
          addressSeed: BigInt(addressSeed)
        },
        signature: bytes
      };
    case "ED25519":
    case "Secp256k1":
    case "Secp256r1":
      const size = SIGNATURE_SCHEME_TO_SIZE[signatureScheme];
      const signature = bytes.slice(1, bytes.length - size);
      const publicKey = bytes.slice(1 + signature.length);
      return {
        serializedSignature,
        signatureScheme,
        signature,
        publicKey,
        bytes
      };
    default:
      throw new Error("Unsupported signature scheme");
  }
}

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/cryptography/keypair.js
var PRIVATE_KEY_SIZE = 32;
var BaseSigner = class {
  /**
   * Sign messages with a specific intent. By combining the message bytes with the intent before hashing and signing,
   * it ensures that a signed message is tied to a specific purpose and domain separator is provided
   */
  async signWithIntent(bytes, intent) {
    const intentMessage = messageWithIntent(intent, bytes);
    const digest = blake2b(intentMessage, { dkLen: 32 });
    const signature = toSerializedSignature({
      signature: await this.sign(digest),
      signatureScheme: this.getKeyScheme(),
      publicKey: this.getPublicKey()
    });
    return {
      signature,
      bytes: toB64(bytes)
    };
  }
  /**
   * Signs provided transaction block by calling `signWithIntent()` with a `TransactionData` provided as intent scope
   */
  async signTransactionBlock(bytes) {
    return this.signWithIntent(bytes, IntentScope.TransactionData);
  }
  /**
   * Signs provided personal message by calling `signWithIntent()` with a `PersonalMessage` provided as intent scope
   */
  async signPersonalMessage(bytes) {
    return this.signWithIntent(
      suiBcs.vector(suiBcs.u8()).serialize(bytes).toBytes(),
      IntentScope.PersonalMessage
    );
  }
  toSuiAddress() {
    return this.getPublicKey().toSuiAddress();
  }
};
var Keypair = class extends BaseSigner {
};

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/cryptography/mnemonics.js
function isValidHardenedPath(path) {
  if (!new RegExp("^m\\/44'\\/784'\\/[0-9]+'\\/[0-9]+'\\/[0-9]+'+$").test(path)) {
    return false;
  }
  return true;
}
function mnemonicToSeed(mnemonics) {
  return mnemonicToSeedSync(mnemonics, "");
}
function mnemonicToSeedHex(mnemonics) {
  return toHEX(mnemonicToSeed(mnemonics));
}

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/keypairs/ed25519/ed25519-hd-key.js
var import_tweetnacl = __toESM(require_nacl_fast(), 1);
var ED25519_CURVE = "ed25519 seed";
var HARDENED_OFFSET = 2147483648;
var pathRegex = new RegExp("^m(\\/[0-9]+')+$");
var replaceDerive = (val) => val.replace("'", "");
var getMasterKeyFromSeed = (seed) => {
  const h10 = hmac.create(sha512, ED25519_CURVE);
  const I12 = h10.update(fromHEX(seed)).digest();
  const IL = I12.slice(0, 32);
  const IR = I12.slice(32);
  return {
    key: IL,
    chainCode: IR
  };
};
var CKDPriv = ({ key, chainCode }, index) => {
  const indexBuffer = new ArrayBuffer(4);
  const cv = new DataView(indexBuffer);
  cv.setUint32(0, index);
  const data = new Uint8Array(1 + key.length + indexBuffer.byteLength);
  data.set(new Uint8Array(1).fill(0));
  data.set(key, 1);
  data.set(new Uint8Array(indexBuffer, 0, indexBuffer.byteLength), key.length + 1);
  const I12 = hmac.create(sha512, chainCode).update(data).digest();
  const IL = I12.slice(0, 32);
  const IR = I12.slice(32);
  return {
    key: IL,
    chainCode: IR
  };
};
var isValidPath = (path) => {
  if (!pathRegex.test(path)) {
    return false;
  }
  return !path.split("/").slice(1).map(replaceDerive).some(
    isNaN
    /* ts T_T*/
  );
};
var derivePath = (path, seed, offset = HARDENED_OFFSET) => {
  if (!isValidPath(path)) {
    throw new Error("Invalid derivation path");
  }
  const { key, chainCode } = getMasterKeyFromSeed(seed);
  const segments = path.split("/").slice(1).map(replaceDerive).map((el) => parseInt(el, 10));
  return segments.reduce((parentKeys, segment) => CKDPriv(parentKeys, segment + offset), {
    key,
    chainCode
  });
};

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/keypairs/ed25519/publickey.js
var import_tweetnacl2 = __toESM(require_nacl_fast(), 1);

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/cryptography/publickey.js
function bytesEqual(a11, b8) {
  if (a11 === b8)
    return true;
  if (a11.length !== b8.length) {
    return false;
  }
  for (let i9 = 0; i9 < a11.length; i9++) {
    if (a11[i9] !== b8[i9]) {
      return false;
    }
  }
  return true;
}
var PublicKey2 = class {
  /**
   * Checks if two public keys are equal
   */
  equals(publicKey) {
    return bytesEqual(this.toRawBytes(), publicKey.toRawBytes());
  }
  /**
   * Return the base-64 representation of the public key
   */
  toBase64() {
    return toB64(this.toRawBytes());
  }
  toString() {
    throw new Error(
      "`toString` is not implemented on public keys. Use `toBase64()` or `toRawBytes()` instead."
    );
  }
  /**
   * Return the Sui representation of the public key encoded in
   * base-64. A Sui public key is formed by the concatenation
   * of the scheme flag with the raw bytes of the public key
   */
  toSuiPublicKey() {
    const bytes = this.toSuiBytes();
    return toB64(bytes);
  }
  verifyWithIntent(bytes, signature, intent) {
    const intentMessage = messageWithIntent(intent, bytes);
    const digest = blake2b(intentMessage, { dkLen: 32 });
    return this.verify(digest, signature);
  }
  /**
   * Verifies that the signature is valid for for the provided PersonalMessage
   */
  verifyPersonalMessage(message, signature) {
    return this.verifyWithIntent(
      suiBcs.vector(suiBcs.u8()).serialize(message).toBytes(),
      signature,
      IntentScope.PersonalMessage
    );
  }
  /**
   * Verifies that the signature is valid for for the provided TransactionBlock
   */
  verifyTransactionBlock(transactionBlock, signature) {
    return this.verifyWithIntent(transactionBlock, signature, IntentScope.TransactionData);
  }
  /**
   * Returns the bytes representation of the public key
   * prefixed with the signature scheme flag
   */
  toSuiBytes() {
    const rawBytes = this.toRawBytes();
    const suiBytes = new Uint8Array(rawBytes.length + 1);
    suiBytes.set([this.flag()]);
    suiBytes.set(rawBytes, 1);
    return suiBytes;
  }
  /**
   * Return the Sui address associated with this Ed25519 public key
   */
  toSuiAddress() {
    return normalizeSuiAddress(
      bytesToHex(blake2b(this.toSuiBytes(), { dkLen: 32 })).slice(0, SUI_ADDRESS_LENGTH2 * 2)
    );
  }
};

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/keypairs/ed25519/publickey.js
var PUBLIC_KEY_SIZE = 32;
var Ed25519PublicKey = class extends PublicKey2 {
  /**
   * Create a new Ed25519PublicKey object
   * @param value ed25519 public key as buffer or base-64 encoded string
   */
  constructor(value) {
    super();
    if (typeof value === "string") {
      this.data = fromB64(value);
    } else if (value instanceof Uint8Array) {
      this.data = value;
    } else {
      this.data = Uint8Array.from(value);
    }
    if (this.data.length !== PUBLIC_KEY_SIZE) {
      throw new Error(
        `Invalid public key input. Expected ${PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`
      );
    }
  }
  /**
   * Checks if two Ed25519 public keys are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  /**
   * Return the byte array representation of the Ed25519 public key
   */
  toRawBytes() {
    return this.data;
  }
  /**
   * Return the Sui address associated with this Ed25519 public key
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG["ED25519"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(message, signature) {
    let bytes;
    if (typeof signature === "string") {
      const parsed = parseSerializedSignature(signature);
      if (parsed.signatureScheme !== "ED25519") {
        throw new Error("Invalid signature scheme");
      }
      if (!bytesEqual(this.toRawBytes(), parsed.publicKey)) {
        throw new Error("Signature does not match public key");
      }
      bytes = parsed.signature;
    } else {
      bytes = signature;
    }
    return import_tweetnacl2.default.sign.detached.verify(message, bytes, this.toRawBytes());
  }
};
Ed25519PublicKey.SIZE = PUBLIC_KEY_SIZE;

// node_modules/@mysten/wallet-kit/node_modules/@mysten/sui.js/dist/esm/keypairs/ed25519/keypair.js
var DEFAULT_ED25519_DERIVATION_PATH = "m/44'/784'/0'/0'/0'";
var Ed25519Keypair = class _Ed25519Keypair extends Keypair {
  /**
   * Create a new Ed25519 keypair instance.
   * Generate random keypair if no {@link Ed25519Keypair} is provided.
   *
   * @param keypair Ed25519 keypair
   */
  constructor(keypair) {
    super();
    if (keypair) {
      this.keypair = keypair;
    } else {
      this.keypair = import_tweetnacl3.default.sign.keyPair();
    }
  }
  /**
   * Get the key scheme of the keypair ED25519
   */
  getKeyScheme() {
    return "ED25519";
  }
  /**
   * Generate a new random Ed25519 keypair
   */
  static generate() {
    return new _Ed25519Keypair(import_tweetnacl3.default.sign.keyPair());
  }
  /**
   * Create a Ed25519 keypair from a raw secret key byte array, also known as seed.
   * This is NOT the private scalar which is result of hashing and bit clamping of
   * the raw secret key.
   *
   * The sui.keystore key is a list of Base64 encoded `flag || privkey`. To import
   * a key from sui.keystore to typescript, decode from base64 and remove the first
   * flag byte after checking it is indeed the Ed25519 scheme flag 0x00 (See more
   * on flag for signature scheme: https://github.com/MystenLabs/sui/blob/818406c5abdf7de1b80915a0519071eec3a5b1c7/crates/sui-types/src/crypto.rs#L1650):
   * ```
   * import { Ed25519Keypair, fromB64 } from '@mysten/sui.js';
   * const raw = fromB64(t[1]);
   * if (raw[0] !== 0 || raw.length !== PRIVATE_KEY_SIZE + 1) {
   *   throw new Error('invalid key');
   * }
   * const imported = Ed25519Keypair.fromSecretKey(raw.slice(1))
   * ```
   * @throws error if the provided secret key is invalid and validation is not skipped.
   *
   * @param secretKey secret key byte array
   * @param options: skip secret key validation
   */
  static fromSecretKey(secretKey, options) {
    const secretKeyLength = secretKey.length;
    if (secretKeyLength !== PRIVATE_KEY_SIZE) {
      throw new Error(
        `Wrong secretKey size. Expected ${PRIVATE_KEY_SIZE} bytes, got ${secretKeyLength}.`
      );
    }
    const keypair = import_tweetnacl3.default.sign.keyPair.fromSeed(secretKey);
    if (!options || !options.skipValidation) {
      const encoder = new TextEncoder();
      const signData = encoder.encode("sui validation");
      const signature = import_tweetnacl3.default.sign.detached(signData, keypair.secretKey);
      if (!import_tweetnacl3.default.sign.detached.verify(signData, signature, keypair.publicKey)) {
        throw new Error("provided secretKey is invalid");
      }
    }
    return new _Ed25519Keypair(keypair);
  }
  /**
   * The public key for this Ed25519 keypair
   */
  getPublicKey() {
    return new Ed25519PublicKey(this.keypair.publicKey);
  }
  async sign(data) {
    return this.signData(data);
  }
  /**
   * Return the signature for the provided data using Ed25519.
   */
  signData(data) {
    return import_tweetnacl3.default.sign.detached(data, this.keypair.secretKey);
  }
  /**
   * Derive Ed25519 keypair from mnemonics and path. The mnemonics must be normalized
   * and validated against the english wordlist.
   *
   * If path is none, it will default to m/44'/784'/0'/0'/0', otherwise the path must
   * be compliant to SLIP-0010 in form m/44'/784'/{account_index}'/{change_index}'/{address_index}'.
   */
  static deriveKeypair(mnemonics, path) {
    if (path == null) {
      path = DEFAULT_ED25519_DERIVATION_PATH;
    }
    if (!isValidHardenedPath(path)) {
      throw new Error("Invalid derivation path");
    }
    const { key } = derivePath(path, mnemonicToSeedHex(mnemonics));
    return _Ed25519Keypair.fromSecretKey(key);
  }
  /**
   * Derive Ed25519 keypair from mnemonicSeed and path.
   *
   * If path is none, it will default to m/44'/784'/0'/0'/0', otherwise the path must
   * be compliant to SLIP-0010 in form m/44'/784'/{account_index}'/{change_index}'/{address_index}'.
   */
  static deriveKeypairFromSeed(seedHex, path) {
    if (path == null) {
      path = DEFAULT_ED25519_DERIVATION_PATH;
    }
    if (!isValidHardenedPath(path)) {
      throw new Error("Invalid derivation path");
    }
    const { key } = derivePath(path, seedHex);
    return _Ed25519Keypair.fromSecretKey(key);
  }
  /**
   * This returns an exported keypair object, the private key field is the pure 32-byte seed.
   */
  export() {
    return {
      schema: "ED25519",
      privateKey: toB64(this.keypair.secretKey.slice(0, PRIVATE_KEY_SIZE))
    };
  }
};

// node_modules/@mysten/wallet-kit/dist/index.mjs
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var __accessCheck5 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet5 = (obj, member, getter) => {
  __accessCheck5(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd5 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var BASE_UNIT = 4;
var makeSize = (amount) => `${amount * BASE_UNIT}px`;
var { styled, css, globalCss, keyframes, getCssText, theme, createTheme, config } = q6({
  media: {
    sm: "(min-width: 640px)",
    md: "(min-width: 768px)",
    lg: "(min-width: 1024px)"
  },
  theme: {
    colors: {
      brand: "#0284AD",
      brandAccent: "#007195",
      secondary: "#C3C5C8",
      secondaryAccent: "#636870",
      textDark: "#182435",
      textLight: "#767A81",
      textOnBrand: "#fff",
      background: "#fff",
      backgroundAccent: "#F7F8F8",
      backdrop: "rgba(24 36 53 / 20%)",
      backgroundIcon: "#F0F1F2",
      icon: "#383F47",
      issue: "#FF794B"
    },
    space: {
      1: makeSize(1),
      2: makeSize(2),
      3: makeSize(3),
      4: makeSize(4),
      5: makeSize(5),
      6: makeSize(6),
      7: makeSize(7),
      8: makeSize(8),
      10: makeSize(10)
    },
    fontSizes: {
      xs: "13px",
      sm: "14px",
      md: "16px",
      lg: "18px",
      xl: "20px"
    },
    fonts: {
      sans: 'ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"',
      mono: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace'
    },
    radii: {
      modal: "16px",
      buttonLg: "12px",
      buttonMd: "8px",
      wallet: "8px",
      close: "9999px"
    },
    fontWeights: {
      copy: 500,
      button: 600,
      title: 600
    },
    transitions: {},
    shadows: {
      button: "0px 4px 12px rgba(0, 0, 0, 0.1)",
      modal: "0px 0px 44px rgba(0, 0, 0, 0.15)",
      wallet: "0px 2px 6px rgba(0, 0, 0, 0.05)"
    }
  }
});
var Button = styled("button", {
  cursor: "pointer",
  border: "none",
  fontFamily: "$sans",
  fontWeight: "$button",
  fontSize: "$sm",
  textDecoration: "none",
  variants: {
    size: {
      md: {
        padding: "$2 $4",
        borderRadius: "$buttonMd"
      },
      lg: {
        padding: "$4 $6",
        borderRadius: "$buttonLg"
      }
    },
    color: {
      primary: {
        backgroundColor: "$brand",
        color: "$textOnBrand",
        "&:hover": {
          backgroundColor: "$brandAccent"
        },
        boxShadow: "$button"
      },
      secondary: {
        backgroundColor: "transparent",
        border: "1px solid $secondary",
        color: "$secondaryAccent"
      },
      connected: {
        boxShadow: "$button",
        backgroundColor: "$background",
        color: "$textDark"
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
var Panel = styled("div", {
  flex: 1,
  boxSizing: "border-box",
  padding: "$5",
  display: "flex",
  flexDirection: "column",
  variants: {
    responsiveHidden: {
      true: {
        display: "none",
        "@md": { display: "flex" }
      }
    }
  }
});
var Truncate = styled("div", {
  overflow: "hidden",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap"
});
var CopyContainer = styled("div", {
  display: "flex",
  flexDirection: "column",
  gap: "$5",
  marginBottom: "$4"
});
var Heading = styled("h3", {
  color: "$textDark",
  fontSize: "$sm",
  margin: 0,
  marginBottom: "$1"
});
var Description = styled("div", {
  color: "$textLight",
  fontSize: "$sm",
  fontWeight: "$copy",
  lineHeight: "1.3"
});
function GettingStarted() {
  return (0, import_jsx_runtime.jsxs)(CopyContainer, { children: [
    (0, import_jsx_runtime.jsxs)("div", { children: [
      (0, import_jsx_runtime.jsx)(Heading, { children: "Install the Sui extension" }),
      (0, import_jsx_runtime.jsx)(Description, { children: "We recommend pinning the Sui Wallet to your taskbar for quicker access." })
    ] }),
    (0, import_jsx_runtime.jsxs)("div", { children: [
      (0, import_jsx_runtime.jsx)(Heading, { children: "Create or Import a Wallet" }),
      (0, import_jsx_runtime.jsx)(Description, { children: "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone." })
    ] }),
    (0, import_jsx_runtime.jsxs)("div", { children: [
      (0, import_jsx_runtime.jsx)(Heading, { children: "Refresh Your Browser" }),
      (0, import_jsx_runtime.jsx)(Description, { children: "Once you set up your wallet, refresh this window browser to load up the extension." })
    ] })
  ] });
}
function BackIcon(props) {
  return (0, import_jsx_runtime2.jsx)("svg", { width: 24, height: 24, fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: (0, import_jsx_runtime2.jsx)(
    "path",
    {
      d: "M7.57 12.262c0 .341.13.629.403.895l5.175 5.059c.204.205.45.307.751.307.609 0 1.101-.485 1.101-1.087 0-.293-.123-.574-.349-.8L10.14 12.27l4.511-4.375A1.13 1.13 0 0 0 15 7.087C15 6.485 14.508 6 13.9 6c-.295 0-.54.103-.752.308l-5.175 5.058c-.28.28-.404.56-.404.896Z",
      fill: "#383F47"
    }
  ) });
}
function CloseIcon(props) {
  return (0, import_jsx_runtime2.jsx)("svg", { width: 10, height: 10, fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: (0, import_jsx_runtime2.jsx)(
    "path",
    {
      d: "M9.708.292a.999.999 0 0 0-1.413 0l-3.289 3.29L1.717.291A.999.999 0 0 0 .305 1.705l3.289 3.289-3.29 3.289a.999.999 0 1 0 1.413 1.412l3.29-3.289 3.288 3.29a.999.999 0 0 0 1.413-1.413l-3.29-3.29 3.29-3.288a.999.999 0 0 0 0-1.413Z",
      fill: "currentColor"
    }
  ) });
}
function SuiIcon(props) {
  return (0, import_jsx_runtime2.jsxs)("svg", { width: 28, height: 28, fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: [
    (0, import_jsx_runtime2.jsx)("rect", { width: 28, height: 28, rx: 6, fill: "#6FBCF0" }),
    (0, import_jsx_runtime2.jsx)(
      "path",
      {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M7.942 20.527A6.875 6.875 0 0 0 13.957 24c2.51 0 4.759-1.298 6.015-3.473a6.875 6.875 0 0 0 0-6.945l-5.29-9.164a.837.837 0 0 0-1.45 0l-5.29 9.164a6.875 6.875 0 0 0 0 6.945Zm4.524-11.75 1.128-1.953a.418.418 0 0 1 .725 0l4.34 7.516a5.365 5.365 0 0 1 .449 4.442 4.675 4.675 0 0 0-.223-.73c-.599-1.512-1.954-2.68-4.029-3.47-1.426-.54-2.336-1.336-2.706-2.364-.476-1.326.021-2.77.316-3.44Zm-1.923 3.332L9.255 14.34a5.373 5.373 0 0 0 0 5.43 5.373 5.373 0 0 0 4.702 2.714 5.38 5.38 0 0 0 3.472-1.247c.125-.314.51-1.462.034-2.646-.44-1.093-1.5-1.965-3.15-2.594-1.864-.707-3.076-1.811-3.6-3.28a4.601 4.601 0 0 1-.17-.608Z",
        fill: "#fff"
      }
    )
  ] });
}
function CheckIcon(props) {
  return (0, import_jsx_runtime2.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "none", ...props, children: (0, import_jsx_runtime2.jsx)(
    "path",
    {
      fill: "#007195",
      d: "m11.726 5.048-4.73 5.156-1.722-1.879a.72.72 0 0 0-.529-.23.722.722 0 0 0-.525.24.858.858 0 0 0-.22.573.86.86 0 0 0 .211.576l2.255 2.458c.14.153.332.24.53.24.2 0 .391-.087.532-.24l5.261-5.735A.86.86 0 0 0 13 5.63a.858.858 0 0 0-.22-.572.722.722 0 0 0-.525-.24.72.72 0 0 0-.529.23Z"
    }
  ) });
}
function ChevronIcon(props) {
  return (0, import_jsx_runtime2.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "none", ...props, children: (0, import_jsx_runtime2.jsx)(
    "path",
    {
      stroke: "#A0B6C3",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      strokeWidth: 1.5,
      d: "m4 6 4 4 4-4"
    }
  ) });
}
var Title = styled((props) => (0, import_jsx_runtime3.jsx)(_t.Title, { ...props }), {
  margin: 0,
  padding: "0 $2",
  fontSize: "$lg",
  fontWeight: "$title",
  color: "$textDark"
});
var Overlay = styled("div", {
  backgroundColor: "$backdrop",
  position: "fixed",
  inset: 0,
  zIndex: 100
});
var Content = styled("div", {
  position: "fixed",
  inset: 0,
  zIndex: 100,
  height: "100%",
  fontFamily: "$sans",
  display: "flex",
  justifyContent: "center",
  alignItems: "flex-end",
  padding: "$4",
  boxSizing: "border-box",
  pointerEvents: "none!important",
  "@md": {
    alignItems: "center"
  }
});
var Body = styled(
  (props) => (0, import_jsx_runtime3.jsx)(_t.Panel, { ...props }),
  {
    position: "relative",
    overflow: "hidden",
    backgroundColor: "$background",
    borderRadius: "$modal",
    boxShadow: "$modal",
    display: "flex",
    flexDirection: "column",
    pointerEvents: "auto",
    variants: {
      connect: {
        true: {
          width: "100%",
          minHeight: "50vh",
          maxWidth: "700px",
          maxHeight: "85vh",
          "@md": {
            flexDirection: "row"
          }
        }
      }
    }
  }
);
var Close = styled("button", {
  position: "absolute",
  cursor: "pointer",
  padding: 7,
  top: "$4",
  right: "$4",
  display: "flex",
  border: "none",
  alignItems: "center",
  justifyContent: "center",
  color: "$icon",
  backgroundColor: "$backgroundIcon",
  borderRadius: "$close"
});
function CloseButton({ onClick }) {
  return (0, import_jsx_runtime3.jsx)(Close, { "aria-label": "Close", onClick, children: (0, import_jsx_runtime3.jsx)(CloseIcon, {}) });
}
var WALLET_NAME = "Unsafe Burner Wallet";
function registerUnsafeBurnerWallet(client = new SuiClient({
  url: getFullnodeUrl("localnet")
}), faucetUrl = getFaucetHost("localnet")) {
  var _on, _connect, _signPersonalMessage, _signTransactionBlock, _signAndExecuteTransactionBlock;
  const wallets2 = getWallets();
  if (wallets2.get().find((wallet) => wallet.name === WALLET_NAME)) {
    console.warn(
      "registerUnsafeBurnerWallet: Unsafe Burner Wallet already registered, skipping duplicate registration"
    );
    return;
  }
  console.warn(
    "Your application is currently using the unsafe burner wallet. Make sure that this wallet is disabled in production."
  );
  const keypair = new Ed25519Keypair();
  const account = new ReadonlyWalletAccount({
    address: keypair.getPublicKey().toSuiAddress(),
    chains: ["sui:unknown"],
    features: ["sui:signAndExecuteTransactionBlock", "sui:signTransactionBlock"],
    publicKey: keypair.getPublicKey().toRawBytes()
  });
  class UnsafeBurnerWallet {
    constructor() {
      __privateAdd5(this, _on, () => {
        return () => {
        };
      });
      __privateAdd5(this, _connect, async () => {
        try {
          await requestSuiFromFaucetV0({
            host: faucetUrl,
            recipient: keypair.getPublicKey().toSuiAddress()
          });
        } catch (e5) {
          console.warn(
            "Failed to request Sui from the faucet. This may prevent transactions from being submitted."
          );
          console.warn(e5);
        }
        return { accounts: this.accounts };
      });
      __privateAdd5(this, _signPersonalMessage, async (messageInput) => {
        const { bytes, signature } = await keypair.signPersonalMessage(messageInput.message);
        return { bytes, signature };
      });
      __privateAdd5(this, _signTransactionBlock, async (transactionInput) => {
        const { bytes, signature } = await transactionInput.transactionBlock.sign({
          client,
          signer: keypair
        });
        return {
          transactionBlockBytes: bytes,
          signature
        };
      });
      __privateAdd5(this, _signAndExecuteTransactionBlock, async (transactionInput) => {
        return await client.signAndExecuteTransactionBlock({
          signer: keypair,
          transactionBlock: transactionInput.transactionBlock,
          options: transactionInput.options,
          requestType: transactionInput.requestType
        });
      });
    }
    get version() {
      return "1.0.0";
    }
    get name() {
      return WALLET_NAME;
    }
    get icon() {
      return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAJrElEQVR42tWbe2xT1x3H7UxAyD3XrdrSbGXlUbKWsq5rWdVuVOMRSEqSOmnVRZMmJqZNYv1nf3R/jWmVmVrtRRM/YwPd1nVTNcrE3pQCoikrIRAC4VVNY0hlD9ZOo1uCfe3ra9979v0dcy3s5Pper76Oh/STE+495/4+5/c85zqe2f7HAx5vKsS+monJj/CdHi/f4/HWW4f6AwdblmXjTM0NyS+movKtw9v+j6C5gKhyTMTTpA2x15Qwy+Pz75motOGdgKep8WF5ATgVZIt5NeO2wMqD0hfVGNPh3oYaYflsjG0l63PeyLCDnqbsLpZIhaRNFI+Ox+Le5KB0RybK8gDmJOkI07U4i/FhT1NDQl8Me5rUIfaDfELOJ0NsFa/SJQHm1WLsHcDqRWiy9BCL8s0N5t6UWWFVvxplejYm60hC91cNjPtzCTZsAptCVoeLP8PDDQJNCSodap6H+LtE8ZcdkvVkkD38vwDn4/Jvy4EhBhZSvRaUHiTXn31gJJxkUPoClBKKFizM+inhVA2cYIdM4HJouPvoe9s9H+KzDhyGK6KkmIqitBhww2C11rjQL2L4kgUwFxk8yPyzauUA3Pk/353XnA6zKbKCaQ2UlMvJF6W5uF5F8yHfZWZpC9HRmBziaEpm1bpY9XvhxuWJRldC7Mt03WlZwpjnkZUNa2DMG2EaPj9MGd2l2mofd0hQ7ZSopsXckHxVCUp32fXGdD0ZktrgFUmMqwhcWFjp87RArsD+9bn585IRaSHAKgBL3SZwOTRc8BKg7yYoskp5OJDiiPmF2Sj7ox0siYJ7lJA04EqvzZ9B1xSVt6PlW0IxZgUMJdZYAJuWngLQt9IRuZXmoTEkmci8ZtTXTViUKyasA9FRun5d8z6bfw0gYWm9mmCXxZatQgxfC7I2NVpRYQOxKWppLs4mcgn5NcibgL1K40xYp8CYY5TXEpjcb3LAJ0OZyyg3+2nySm6fjEtzkEz+7VBx3RTb+60z9dma7pkvwO2QQL5HzTtAdpKF7euw/HuzfrosBHy+ZsBimzbQshjWTVMDgez53B5MbjcGbr1ZjdUJOM5O0SLXzJ2R+uOA1dMAVoLsm5zb73JSId8t8Aa1LsAJdoTCrCaw6e3NC2DdFMUXWRg173mysJNOSUNskUJ1cOlXa2LhcbgmSszXYSn9hl3KSxTDjrZ2cbbfbWDyumsh9m3e7zCG7a3ETt+gtI7fx6lEOanZKDVvuA2cjYmt5xNOd2Louz3IQ12UZ2Zo3lkb9cDlvSs6m4Vk5Yqlabs0B97wT7PUuCXQz0Bnt9QxMPTW4iwBtmUlY8hFsHJPlzcQ1xuG75CVK1kXofCUGnU9fg1aVD7kfE9MoabtYkcAvIUYS2op3Hc3TTrDQzIAeojugTVLFolWDR6wFPtY0R66n6HltwjCIawnE2ymresk9NtN+pfUUi0mX6RJLfrh9zMRaRPOqubSA8W2MNzC0mHpK7j2ruuw5mYkxl5+2+HGQeg4yNYg7vNg+xMxFsuRMuiTsRJZG3cysAl4D9n4aC4un8L9qUyVvbCyYwFXX1nGUxFf1cCiEQqy75O+TpMwYKNKSPQUqhLyyWLsRbESLctx0YnixgfphRWA8pOPc+N4F9d+eV9V4OlCX/As5w5g+wtGhJGukp5go2R3D7EW9rSDcnGL56YgJHj+8GcFND/Vy41jj/H0jxc6HU/AA2QlR01UlH3D7CmITQnJq4lVWBi1yl8XYEh278c5H++F+Iui7r7bYR8tH/gbqoJN7fVODUhLYVVxzmYCEyOxFg7RUVa0egCHZZ55eRHnp/tKgMna6s/bbMdTxZgMzl9CCcmq7k690OzDfaeSN4QcsREjsQpgXHwyWyfg9K5WE7hc6JqTWjyihObfygOFOkv6i5K5TZx8LsL1sVS4NL8ItiB7sgAcEKcWHfUCVhK3kUVnBNbfXIs4l5xAv5sJs234eTUy93L0Au2otQOw5ORMyfQ6WwexFupVSHowG6uThXfebmlhWojMS3fazmMeGxEI6S2SUti6RAo2vKohVuH3qUG5FWm/PjH8kzutgSH5g58xrVwzIbZkxHf7OFjFC+wrMDXcpOqOKX/g01U/XPvVJyxdWsiJblqYmnZoWbDxAcR56X5WPuh4ewcL5PY9JBRUYjc7fzjG6Uc3mHBWbg23X1BLaFHOSnrw4bWiNAXSEWcWRntIignXTP/oDsfKZX66mMbZAPfhviU1AyYmJLYAMZa/QXjUSeIiixpj3UUFtd884KytjN7EjdGNNMbWwtlf3FvbQ4OQtIoYSzbxqVDLXMTxP8jnnbiyKcaJLvueGLD6kXW2sKZov1tpn7hwXf3ZUvq0K2FXOM7Op/Xgb6PhxsWIErYGVuK3WGXWkkwMMZVCVl5kWtax5A6usgemvnx4DelUcYcFC0eIbcbXKzggeyBjeXIhkftaKknJKLtnuSg7KmKQsrH+1nqbmLWY6w/tBGy/8xrruR5SM99LLIjfT/4ZbNZnQEPssIVb21rKTGRIPDagNoLdFMKgcuLc/TF6Bulk6c7ovg4TU+XvS6FNw1tDfVqH9MOPmBDui0hcK6wz744FlDjNe0m3aVldJYagtI6YbF+3ZGPsQHlN1vbeh8lJofqJ+uo9Zi4wXZxKFiXKGxbHT7pNq71oNg4Qi6MviE0FpRVqjGXILYoJ4tCjdYU1rWeMdPLc/ochj3B9pGNGL4NupGPRlUl35KMVxFLNO6ZnxYlBsUPqoMkbUqAb6VhMVKQ7MVT1dYdrL8hzEAcjpmvjHKphgaFb0ZVJZw7dwVD9q5fkgPTRbBxnzmGfgRLQsMCkG+moQdcp6GzzZsL2MGyllvBNGWM9RqMCk26kI7aBK526csVShZTfzid6FEzeiNAGP92jpCPQEbrW7EW5MbZxAz/fN9lg0IbQaaxrQ83/VoKPb/HqJx67Hw+43CDQBPsX0gm6ufXNvH4vP9rZapzx7+Nn+oxZAjfo2caZ3n350c5W6FSEdQ86sNarj3c/jRV+H42AXsdGRBfPPIlnb/mUtxzWXfALn/PmRze2Gud6E/xsXwYtnlsWN8Tc5/oyxjn/jvyJrlY82xLUfWuPr/TqxzuXQZkIP9M7CXiyuP4B4WmsTnNhzinjrD+WO9bRhmdZWLXe4EKRtV5tpN3Hx3s2G+d79/MJf4qff0LnE72kfFEs4ITQvWLMab8C131dP9n9Je1Yx000Nz2jAf+UJwCBchc3NvGR1Qx71XXY2Ww1Jvx7YalzAPkX9rp5E5Z+pv+ja8bE43uN491b9dHO9Xx4lUxziLn21Nai/wXWM6t9vkvtrwAAAABJRU5ErkJggg==";
    }
    // Return the Sui chains that your wallet supports.
    get chains() {
      return SUI_CHAINS;
    }
    get accounts() {
      return [account];
    }
    get features() {
      return {
        "standard:connect": {
          version: "1.0.0",
          connect: __privateGet5(this, _connect)
        },
        "standard:events": {
          version: "1.0.0",
          on: __privateGet5(this, _on)
        },
        "sui:signPersonalMessage": {
          version: "1.0.0",
          signPersonalMessage: __privateGet5(this, _signPersonalMessage)
        },
        "sui:signTransactionBlock": {
          version: "1.0.0",
          signTransactionBlock: __privateGet5(this, _signTransactionBlock)
        },
        "sui:signAndExecuteTransactionBlock": {
          version: "1.0.0",
          signAndExecuteTransactionBlock: __privateGet5(this, _signAndExecuteTransactionBlock)
        }
      };
    }
  }
  _on = /* @__PURE__ */ new WeakMap();
  _connect = /* @__PURE__ */ new WeakMap();
  _signPersonalMessage = /* @__PURE__ */ new WeakMap();
  _signTransactionBlock = /* @__PURE__ */ new WeakMap();
  _signAndExecuteTransactionBlock = /* @__PURE__ */ new WeakMap();
  return wallets2.register(new UnsafeBurnerWallet());
}
var WalletKitContext = (0, import_react52.createContext)(null);
function WalletKitProvider({
  preferredWallets,
  children,
  enableUnsafeBurner,
  storageAdapter,
  storageKey,
  disableAutoConnect,
  features
}) {
  const walletKitRef = (0, import_react52.useRef)(null);
  if (!walletKitRef.current) {
    walletKitRef.current = createWalletKitCore({
      features,
      preferredWallets,
      storageAdapter,
      storageKey
    });
  }
  (0, import_react52.useEffect)(() => {
    if (!enableUnsafeBurner)
      return;
    return registerUnsafeBurnerWallet();
  }, [enableUnsafeBurner]);
  const { wallets: wallets2 } = (0, import_react52.useSyncExternalStore)(
    walletKitRef.current.subscribe,
    walletKitRef.current.getState,
    walletKitRef.current.getState
  );
  (0, import_react52.useEffect)(() => {
    var _a;
    if (!disableAutoConnect) {
      (_a = walletKitRef.current) == null ? void 0 : _a.autoconnect();
    }
  }, [wallets2]);
  return (0, import_jsx_runtime4.jsx)(WalletKitContext.Provider, { value: walletKitRef.current, children });
}
function useWalletKit() {
  const walletKit = (0, import_react52.useContext)(WalletKitContext);
  if (!walletKit) {
    throw new Error("You must call `useWalletKit` within the of the `WalletKitProvider`.");
  }
  const state = (0, import_react52.useSyncExternalStore)(walletKit.subscribe, walletKit.getState, walletKit.getState);
  return (0, import_react52.useMemo)(
    () => ({
      connect: walletKit.connect,
      disconnect: walletKit.disconnect,
      signMessage: walletKit.signMessage,
      signPersonalMessage: walletKit.signPersonalMessage,
      signTransactionBlock: walletKit.signTransactionBlock,
      signAndExecuteTransactionBlock: walletKit.signAndExecuteTransactionBlock,
      selectAccount: walletKit.selectAccount,
      ...state
    }),
    [walletKit, state]
  );
}
var Container = styled(Panel, {
  background: "$background",
  height: "100%",
  "@md": {
    background: "$backgroundAccent"
  }
});
var ListContainer = styled("div", {
  marginTop: "$6",
  display: "flex",
  flexDirection: "column",
  gap: "$1"
});
var WalletItem = styled("button", {
  background: "none",
  display: "flex",
  padding: "$2",
  gap: "$2",
  alignItems: "center",
  cursor: "pointer",
  color: "$textDark",
  border: "none",
  fontWeight: "$button",
  fontSize: "$md",
  borderRadius: "$wallet",
  variants: {
    selected: {
      true: {
        background: "$background",
        boxShadow: "$wallet"
      }
    }
  }
});
var WalletIcon = styled("img", {
  flexShrink: 0,
  background: "white",
  width: 28,
  height: 28,
  borderRadius: 6,
  objectFit: "cover"
});
var SELECTED_GETTING_STARTED = "@@internal/getting-started";
function WalletList({ selected, onChange }) {
  const { wallets: wallets2 } = useWalletKit();
  return (0, import_jsx_runtime5.jsxs)(Container, { children: [
    (0, import_jsx_runtime5.jsx)(Title, { children: "Connect a Wallet" }),
    (0, import_jsx_runtime5.jsx)(ListContainer, { children: wallets2.length === 0 ? (0, import_jsx_runtime5.jsxs)(
      WalletItem,
      {
        onClick: () => onChange(SELECTED_GETTING_STARTED),
        selected: { "@initial": false, "@md": true },
        children: [
          (0, import_jsx_runtime5.jsx)(SuiIcon, {}),
          (0, import_jsx_runtime5.jsx)(Truncate, { children: "Sui Wallet" })
        ]
      }
    ) : wallets2.map((wallet) => (0, import_jsx_runtime5.jsxs)(
      WalletItem,
      {
        selected: wallet.name === selected,
        onClick: () => {
          onChange(wallet.name);
        },
        children: [
          (0, import_jsx_runtime5.jsx)(WalletIcon, { src: wallet.icon }),
          (0, import_jsx_runtime5.jsx)(Truncate, { children: wallet.name })
        ]
      },
      wallet.name
    )) })
  ] });
}
function WhatIsAWallet() {
  return (0, import_jsx_runtime6.jsxs)(CopyContainer, { children: [
    (0, import_jsx_runtime6.jsxs)("div", { children: [
      (0, import_jsx_runtime6.jsx)(Heading, { children: "Easy Login" }),
      (0, import_jsx_runtime6.jsx)(Description, { children: "No need to create new accounts and passwords for every website. Just connect your wallet and get going." })
    ] }),
    (0, import_jsx_runtime6.jsxs)("div", { children: [
      (0, import_jsx_runtime6.jsx)(Heading, { children: "Store your Digital Assets" }),
      (0, import_jsx_runtime6.jsx)(Description, { children: "Send, receive, store, and display your digital assets like NFTs & coins." })
    ] })
  ] });
}
var BackButton = styled("button", {
  position: "absolute",
  cursor: "pointer",
  top: "$4",
  left: "$4",
  display: "flex",
  border: "none",
  alignItems: "center",
  justifyContent: "center",
  color: "$icon",
  backgroundColor: "transparent",
  "@md": {
    display: "none"
  }
});
var BodyCopy = styled("div", {
  padding: "$10",
  display: "flex",
  flexDirection: "column",
  justifyContent: "center",
  alignItems: "center",
  flex: 1
});
var SelectedWalletIcon = styled("img", {
  background: "white",
  objectFit: "cover",
  width: 72,
  height: 72,
  borderRadius: 16
});
var ButtonContainer = styled("div", {
  position: "absolute",
  bottom: "$8",
  right: "$8",
  marginTop: "$4"
});
var LeftPanel = styled("div", {
  display: "flex",
  flexDirection: "column",
  width: "100%",
  flex: 1,
  "@md": {
    flex: 0,
    minWidth: 240
  },
  variants: {
    hasSelected: {
      true: {
        display: "none",
        "@md": {
          display: "block"
        }
      }
    }
  }
});
var OpeningWalletTitle = styled("div", {
  marginTop: "$3",
  marginBottom: "$1",
  color: "$textDark",
  fontSize: "$xl",
  fontWeight: "$title"
});
var ConnectionText = styled("div", {
  fontSize: "$xs",
  variants: {
    isError: {
      true: {
        color: "$issue"
      },
      false: {
        color: "$textLight"
      }
    }
  },
  defaultVariants: {
    isError: false
  }
});
var MobileInfoButton = styled("button", {
  background: "$backgroundAccent",
  textAlign: "center",
  width: "100%",
  padding: "$4",
  border: "none",
  color: "$textLight",
  fontWeight: "$button",
  fontFamily: "$sans",
  cursor: "pointer",
  "@md": {
    display: "none"
  }
});
var SELECTED_INFO = "@@internal/what-is-wallet";
function ConnectModal({ open, onClose }) {
  const { connect, currentWallet, isConnected, isError } = useWalletKit();
  const [selected, setSelected] = (0, import_react49.useState)(null);
  (0, import_react49.useEffect)(() => {
    if (!open) {
      setSelected(null);
    }
  }, [open]);
  (0, import_react49.useEffect)(() => {
    if (isConnected && (currentWallet == null ? void 0 : currentWallet.name) === selected) {
      onClose();
    }
  }, [currentWallet, selected, isConnected]);
  return (0, import_jsx_runtime7.jsxs)(_t, { open, onClose, children: [
    (0, import_jsx_runtime7.jsx)(Overlay, {}),
    (0, import_jsx_runtime7.jsx)(Content, { children: (0, import_jsx_runtime7.jsxs)(Body, { connect: true, children: [
      (0, import_jsx_runtime7.jsxs)(LeftPanel, { hasSelected: !!selected, children: [
        (0, import_jsx_runtime7.jsx)(
          WalletList,
          {
            selected,
            onChange: (walletName) => {
              setSelected(walletName);
              connect(walletName);
            }
          }
        ),
        (0, import_jsx_runtime7.jsx)(MobileInfoButton, { onClick: () => setSelected(SELECTED_INFO), children: "What is a Wallet" })
      ] }),
      (0, import_jsx_runtime7.jsxs)(Panel, { responsiveHidden: !selected, children: [
        (0, import_jsx_runtime7.jsx)(BackButton, { onClick: () => setSelected(null), "aria-label": "Back", children: (0, import_jsx_runtime7.jsx)(BackIcon, {}) }),
        !selected || selected === SELECTED_INFO ? (0, import_jsx_runtime7.jsxs)(import_jsx_runtime7.Fragment, { children: [
          (0, import_jsx_runtime7.jsx)(Title, { css: { textAlign: "center" }, children: "What is a Wallet" }),
          (0, import_jsx_runtime7.jsx)(BodyCopy, { children: (0, import_jsx_runtime7.jsx)(WhatIsAWallet, {}) })
        ] }) : selected && selected !== SELECTED_GETTING_STARTED ? (0, import_jsx_runtime7.jsxs)(BodyCopy, { children: [
          (0, import_jsx_runtime7.jsx)(SelectedWalletIcon, { src: currentWallet == null ? void 0 : currentWallet.icon }),
          (0, import_jsx_runtime7.jsxs)(OpeningWalletTitle, { children: [
            "Opening ",
            selected
          ] }),
          (0, import_jsx_runtime7.jsx)(ConnectionText, { isError, children: isError ? "Connection failed" : "Confirm connection in the wallet..." }),
          isError && (0, import_jsx_runtime7.jsx)(ButtonContainer, { children: (0, import_jsx_runtime7.jsx)(Button, { color: "secondary", onClick: () => connect(selected), children: "Retry Connection" }) })
        ] }) : (0, import_jsx_runtime7.jsxs)(import_jsx_runtime7.Fragment, { children: [
          (0, import_jsx_runtime7.jsx)(Title, { css: { textAlign: "center" }, children: "Get Started with Sui" }),
          (0, import_jsx_runtime7.jsxs)(BodyCopy, { children: [
            (0, import_jsx_runtime7.jsx)(GettingStarted, {}),
            (0, import_jsx_runtime7.jsx)(ButtonContainer, { children: (0, import_jsx_runtime7.jsx)(
              Button,
              {
                as: "a",
                color: "secondary",
                href: "https://chrome.google.com/webstore/detail/sui-wallet/opcgpfmipidbgpenhmajoajpbobppdil",
                target: "_blank",
                rel: "noopener noreferrer",
                children: "Install Wallet Extension"
              }
            ) })
          ] })
        ] })
      ] }),
      (0, import_jsx_runtime7.jsx)(CloseButton, { onClick: onClose })
    ] }) })
  ] });
}
var MenuItems = re5(qe4.Items, {
  position: "absolute",
  right: 0,
  marginTop: "$1",
  width: 180,
  maxHeight: 200,
  overflow: "scroll",
  borderRadius: "$buttonLg",
  backgroundColor: "$background",
  color: "$textDark",
  boxShadow: "$button",
  zIndex: 10,
  padding: "$2",
  display: "flex",
  flexDirection: "column",
  gap: "$2"
});
var Account = re5("button", {
  border: 0,
  display: "flex",
  justifyContent: "space-between",
  alignItems: "center",
  backgroundColor: "white",
  fontFamily: "$mono",
  padding: "$2",
  color: "#758F9E",
  cursor: "pointer",
  textAlign: "left",
  fontSize: 14,
  borderRadius: 3,
  "&:hover": {
    color: "#0284AD",
    backgroundColor: "#E1F3FF80"
  },
  variants: {
    active: {
      true: {
        color: "#007195"
      }
    }
  }
});
function ConnectButton({
  connectText = "Connect Wallet",
  connectedText,
  ...props
}) {
  const [connectModalOpen, setConnectModalOpen] = (0, import_react47.useState)(false);
  const { currentAccount, accounts, selectAccount, disconnect } = useWalletKit();
  return (0, import_jsx_runtime8.jsxs)(import_jsx_runtime8.Fragment, { children: [
    currentAccount ? (0, import_jsx_runtime8.jsxs)(qe4, { as: "div", style: { position: "relative", display: "inline-block" }, children: [
      (0, import_jsx_runtime8.jsxs)(
        qe4.Button,
        {
          as: Button,
          color: "connected",
          size: "lg",
          css: {
            fontFamily: "$mono",
            display: "inline-flex",
            justifyContent: "space-between",
            alignItems: "center",
            gap: "$2"
          },
          type: "button",
          children: [
            connectedText ?? formatAddress(currentAccount.address),
            (0, import_jsx_runtime8.jsx)(ChevronIcon, {})
          ]
        }
      ),
      (0, import_jsx_runtime8.jsxs)(MenuItems, { children: [
        accounts.map((account) => (0, import_jsx_runtime8.jsx)(qe4.Item, { children: (0, import_jsx_runtime8.jsxs)(
          Account,
          {
            active: account.address === currentAccount.address,
            onClick: () => selectAccount(account),
            children: [
              formatAddress(account.address),
              account.address === currentAccount.address && (0, import_jsx_runtime8.jsx)(CheckIcon, {})
            ]
          }
        ) }, account.address)),
        (0, import_jsx_runtime8.jsx)(
          "div",
          {
            style: {
              marginTop: 4,
              marginBottom: 4,
              height: 1,
              background: "#F3F6F8",
              flexShrink: 0
            }
          }
        ),
        (0, import_jsx_runtime8.jsx)(qe4.Item, { children: (0, import_jsx_runtime8.jsx)(Account, { css: { fontFamily: "$sans" }, onClick: () => disconnect(), children: "Disconnect" }) })
      ] })
    ] }) : (0, import_jsx_runtime8.jsx)(
      Button,
      {
        color: "primary",
        size: "lg",
        onClick: () => setConnectModalOpen(true),
        type: "button",
        ...props,
        children: connectText
      }
    ),
    !currentAccount && (0, import_jsx_runtime8.jsx)(ConnectModal, { open: connectModalOpen, onClose: () => setConnectModalOpen(false) })
  ] });
}
export {
  ConnectButton,
  ConnectModal,
  WalletKitContext,
  WalletKitProvider,
  useWalletKit
};
//# sourceMappingURL=@mysten_wallet-kit.js.map
